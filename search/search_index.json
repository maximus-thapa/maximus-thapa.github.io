{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#javascript-compiler","title":"JavaScript Compiler","text":"<p>programiz.com/javascript/online-compiler/</p> <p>Auth</p> <p>/json-placeholder-api</p>"},{"location":"auth/intro/","title":"Intro","text":"<p>Intro</p>"},{"location":"auth/example/context-auth/","title":"Context API","text":""},{"location":"auth/example/context-auth/#context","title":"context","text":"AuthContext.jsx <pre><code>import React, { createContext, useContext, useState, useEffect } from \"react\";\n\n// Create an Auth Context\nconst AuthContext = createContext();\n\n// AuthProvider component to wrap the app\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [token, setToken] = useState(null); // For storing JWT or session token\n\n    // Check local storage for the token on initial load\n    useEffect(() =&gt; {\n        const storedToken = localStorage.getItem(\"token\");\n        console.log(\"Stored Token:\", storedToken);\n\n        if (storedToken) {\n            setIsAuthenticated(true);\n            setToken(storedToken);\n        }\n    }, []);\n\n    // Login function to set authentication state\n    const login = (token) =&gt; {\n        setIsAuthenticated(true);\n        setToken(token);\n        // Optionally, store the token in localStorage\n        localStorage.setItem(\"token\", token);\n    };\n\n    // Logout function to clear authentication state\n    const logout = () =&gt; {\n        setIsAuthenticated(false);\n        setToken(null);\n        localStorage.removeItem(\"token\"); // Clear token from localStorage\n    };\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\n// Custom hook to use the AuthContext\nexport const useAuth = () =&gt; {\n    return useContext(AuthContext);\n};\n</code></pre>"},{"location":"auth/example/context-auth/#routes","title":"routes","text":"AppRoutes.jsxProtectedRoute.jsx <pre><code>import { Routes, Route, Navigate } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport Login from \"../components/Login/login\";\nimport NotFound from \"../components/NotFound\";\nimport ProtectedRoute from \"./ProtectedRoute\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst AppRoutes = () =&gt; {\n    const { isAuthenticated } = useAuth();\n\n    return (\n        &lt;Routes&gt;\n            &lt;Route\n                path=\"/\"\n                element={isAuthenticated ? &lt;Navigate to=\"/home\" /&gt; : &lt;Login /&gt;}\n            /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                    &lt;ProtectedRoute&gt;\n                        &lt;Home /&gt;\n                    &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"\\*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> <pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\nimport { useAuth } from \"../context/AuthContext\";\n\nconst ProtectedRoute = ({ children }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? children : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre>"},{"location":"auth/example/context-auth/#app-index","title":"App &amp; index","text":"App.jsindex.js <pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\";\nimport { AuthProvider } from \"./context/AuthContext\";\nimport \"./App.css\";\n\nfunction App() {\n    return (\n        &lt;AuthProvider&gt;\n            &lt;Router&gt;\n                &lt;div className=\"App\"&gt;\n                    &lt;Navbar /&gt;\n                    {/* {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} */}\n                    &lt;AppRoutes /&gt;\n                &lt;/div&gt;\n            &lt;/Router&gt;\n        &lt;/AuthProvider&gt;\n    );\n}\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n&lt;React.StrictMode&gt;\n    &lt;App /&gt;\n&lt;/React.StrictMode&gt;\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n</code></pre>"},{"location":"auth/example/context-auth/#component","title":"Component","text":"login.jsxNavbar/index.js <pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\nimport { login } from \"../../api/auth\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst Login = () =&gt; {\n    const { login: authenticate } = useAuth();\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate();\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            const response = await login(values.username, values.password);\n            console.log(\"API Response:\", response); // Log the response\n            authenticate(response.access); // Call login method from context\n            message.success(\"login successfull\");\n            navigate(\"/home\"); // Navigate to home after successful login\n        } catch (error) {\n            message.error(error.message || \"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" initialValues={{ remember: true }} onFinish={onFinish}&gt;\n                &lt;Form.Item\n                    name=\"username\"\n                    rules={[{ required: true, message: \"Please input your username!\" }]}\n                &gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item\n                    name=\"password\"\n                    rules={[{ required: true, message: \"Please input your password!\" }]}\n                &gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> <pre><code>import { Link } from \"react-router-dom\";\nimport { Layout, Menu } from \"antd\";\nimport { useAuth } from \"../../context/AuthContext\";\n\nconst { Header } = Layout;\n\nconst Navbar = () =&gt; {\n    const { isAuthenticated, logout } = useAuth();\n\n    return (\n        &lt;Layout&gt;\n            &lt;Header&gt;\n                &lt;Menu theme=\"dark\" mode=\"horizontal\"&gt;\n                    {isAuthenticated ? (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"home\"&gt;\n                            &lt;Link to=\"/home\"&gt;Dashboard&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;Menu.Item key=\"logout\"&gt;\n                            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    ) : (\n                        &lt;&gt;\n                        &lt;Menu.Item key=\"login\"&gt;\n                            &lt;Link to=\"/\"&gt;Login&lt;/Link&gt;\n                        &lt;/Menu.Item&gt;\n                        &lt;/&gt;\n                    )}\n                &lt;/Menu&gt;\n            &lt;/Header&gt;\n        &lt;/Layout&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre>"},{"location":"auth/example/simple-login/","title":"Simple login","text":""},{"location":"auth/example/simple-login/#full-code-example","title":"Full Code Example","text":"<ol> <li> <p>Create Your Project Structure</p> <pre><code>src/\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Home.js\n\u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2514\u2500\u2500 NotFound.js\n\u251c\u2500\u2500 routes/\n\u2502   \u251c\u2500\u2500 AppRoutes.js\n\u2502   \u2514\u2500\u2500 ProtectedRoute.js\n\u251c\u2500\u2500 App.js\n\u2514\u2500\u2500 index.js\n</code></pre> </li> <li> <p>Install Required Packages Make sure you have React Router and Ant Design installed:</p> <pre><code>npm install react-router-dom antd\n</code></pre> </li> <li> <p>Code for Each Component</p> index &amp; AppRoutesComponent index.js<pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"antd/dist/antd.css\"; // Import Ant Design styles\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> App.js<pre><code>import React, { useState } from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport Navbar from \"./components/Navbar\"; // Import your Navbar component\n\nconst App = () =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const handleLogin = (status) =&gt; {\n        setIsAuthenticated(status);\n    };\n\n    return (\n        &lt;Router&gt;\n            {isAuthenticated &amp;&amp; &lt;Navbar /&gt;} {/* Show Navbar only if authenticated */}\n            &lt;AppRoutes isAuthenticated={isAuthenticated} onLogin={handleLogin} /&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> AppRoutes.js<pre><code>import { Routes, Route } from \"react-router-dom\";\nimport Home from \"../components/Home\";\nimport NotFound from \"../components/NotFound\";\nimport Login from \"../components/Login\";\nimport ProtectedRoute from \"./ProtectedRoute\";\n\nconst AppRoutes = ({ isAuthenticated, onLogin }) =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/login\" element={&lt;Login onLogin={onLogin} /&gt;} /&gt;\n            &lt;Route\n                path=\"/home\"\n                element={\n                &lt;ProtectedRoute isAuthenticated={isAuthenticated}&gt;\n                    &lt;Home /&gt;\n                &lt;/ProtectedRoute&gt;\n                }\n            /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre> ProtectedRoute.js<pre><code>import React from \"react\";\nimport { Navigate } from \"react-router-dom\";\n\nconst ProtectedRoute = ({ isAuthenticated, children }) =&gt; {\n    return isAuthenticated ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> Home.js<pre><code>import React from \"react\";\n\nconst Home = () =&gt; {\n    return &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;;\n};\n\nexport default Home;\n</code></pre> NotFound.js<pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;;\n};\n\nexport default NotFound;\n</code></pre> Login.js<pre><code>import React, { useState } from \"react\";\nimport { Form, Input, Button, Card, message } from \"antd\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Login = ({ onLogin }) =&gt; {\n    const [loading, setLoading] = useState(false);\n    const navigate = useNavigate(); // Initialize useNavigate\n\n    const onFinish = async (values) =&gt; {\n        setLoading(true);\n        try {\n            // Simulate an API call\n            const response = await fakeLoginAPI(values);\n            if (response.success) {\n                onLogin(true); // Update the authentication state\n                navigate(\"/home\"); // Navigate to the home (dashboard) route\n            } else {\n                message.error(response.message);\n            }\n        } catch (error) {\n            message.error(\"Login failed. Please try again.\");\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const fakeLoginAPI = async ({ username, password }) =&gt; {\n        // Simulating an API call\n        return new Promise((resolve) =&gt; {\n            setTimeout(() =&gt; {\n                if (username === \"user\" &amp;&amp; password === \"pass\") {\n                    resolve({ success: true });\n                } else {\n                    resolve({ success: false, message: \"Invalid credentials\" });\n                }\n            }, 1000);\n        });\n    };\n\n    return (\n        &lt;Card title=\"Login\" style={{ width: 300, margin: \"auto\", marginTop: 100 }}&gt;\n            &lt;Form name=\"login\" onFinish={onFinish}&gt;\n                &lt;Form.Item name=\"username\" rules={[{ required: true, message: 'Please input your username!' }]}&gt;\n                    &lt;Input placeholder=\"Username\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item name=\"password\" rules={[{ required: true, message: 'Please input your password!' }]}&gt;\n                    &lt;Input.Password placeholder=\"Password\" /&gt;\n                &lt;/Form.Item&gt;\n                &lt;Form.Item&gt;\n                    &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading} block&gt;\n                        Login\n                    &lt;/Button&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Card&gt;\n    );\n};\n\nexport default Login;\n</code></pre> </li> </ol>"},{"location":"auth/example/simple-login/#summary","title":"Summary","text":"<ul> <li>Login Component: Handles user authentication and simulates an API call.</li> <li>Protected Route: Redirects to the login page if the user is not authenticated.</li> <li>App Component: Manages the authentication state and routes.</li> </ul>"},{"location":"auth/example/simple-login/#running-the-application","title":"Running the Application","text":"<ol> <li> <p>Start your React application:</p> <pre><code>npm start\n</code></pre> </li> <li> <p>Navigate to <code>http://localhost:3000/login</code> to access the login page. Use <code>username: user and password: pass</code> to log in and access the home page.</p> <p>This setup provides a complete example of a React application with protected routing and a login flow using Ant Design and React Router. If you have any further questions or need additional features, feel free to ask!</p> </li> </ol>"},{"location":"auth/router/auth-techniques/","title":"Technique","text":"<p>Techniques for Managing Authentication in React</p> <p>Here's a comprehensive overview of various techniques for managing authentication and state in React applications, presented in a structured format for easy reference.</p>"},{"location":"auth/router/auth-techniques/#categorized","title":"Categorized","text":"<p>Here\u2019s a categorized overview of various techniques for managing authentication in React applications, grouped by their complexity and use cases. This should help with memorization!</p>"},{"location":"auth/router/auth-techniques/#1-simple-state-management-techniques","title":"1. Simple State Management Techniques","text":"<ul> <li> <p>Context API</p> <ul> <li>Best For: Small to medium-sized applications.</li> <li>Use Case: Sharing authentication state across multiple components without prop drilling.</li> </ul> </li> <li> <p>Zustand</p> <ul> <li>Best For: Lightweight state management.</li> <li>Use Case: Applications needing a simple and fast solution for state management.</li> </ul> </li> </ul>"},{"location":"auth/router/auth-techniques/#2-intermediate-state-management-techniques","title":"2. Intermediate State Management Techniques","text":"<ul> <li> <p>Recoil</p> <ul> <li>Best For: Medium to large applications.</li> <li>Use Case: Efficient local and global state management with an intuitive API.</li> </ul> </li> <li> <p>MobX</p> <ul> <li>Best For: Reactive programming needs.</li> <li>Use Case: Applications requiring automatic UI updates with minimal boilerplate.</li> </ul> </li> </ul>"},{"location":"auth/router/auth-techniques/#3-advanced-state-management-techniques","title":"3. Advanced State Management Techniques","text":"<ul> <li> <p>Redux</p> <ul> <li>Best For: Large applications with complex state management.</li> <li>Use Case: Centralized state management, especially when using middleware for async actions.</li> </ul> </li> </ul>"},{"location":"auth/router/auth-techniques/#4-server-dependent-techniques","title":"4. Server-Dependent Techniques","text":"<ul> <li> <p>React Query</p> <ul> <li>Best For: Data-heavy applications.</li> <li>Use Case: Efficient data fetching, caching, and synchronizing server data alongside authentication.</li> </ul> </li> <li> <p>Firebase Authentication</p> <ul> <li>Best For: Easy and secure user authentication.</li> <li>Use Case: Applications needing quick integration of various authentication methods (Google, email/password).</li> </ul> </li> </ul>"},{"location":"auth/router/auth-techniques/#summary-table","title":"Summary Table","text":"Category Technique Best For Use Case Simple State Management Context API Small to medium apps State sharing without prop drilling Zustand Lightweight apps Simple and fast state management Intermediate State Management Recoil Medium to large apps Local and global state management MobX Reactive programming Automatic UI updates with minimal boilerplate Advanced State Management Redux Large apps with complex state Centralized state management Server-Dependent Techniques React Query Data-heavy apps Efficient data fetching and caching Firebase Authentication Easy and secure user auth Quick integration of authentication methods"},{"location":"auth/router/auth-techniques/#conclusion","title":"Conclusion","text":"<p>By categorizing these techniques, you can better recall which method to use based on your project's size, complexity, and specific requirements. This structure makes it easier to remember the right tools for different scenarios in React applications!</p>"},{"location":"auth/router/best-method-for-auth/","title":"Best Method","text":"<p>The \"best\" method for implementing login and logout functionality in a React application depends on several factors, including the project's complexity, your team's familiarity with the technologies, and the specific requirements of the application. Here's a breakdown to help you choose the most suitable approach:</p>"},{"location":"auth/router/best-method-for-auth/#1-simple-applications","title":"1. Simple Applications","text":"<ul> <li>Best Method: Context API with Custom Hooks</li> <li>Why: For smaller apps, using the Context API with custom hooks is straightforward, requires minimal setup, and keeps the code clean. It's easy to understand and maintain.</li> </ul>"},{"location":"auth/router/best-method-for-auth/#2-medium-to-large-applications","title":"2. Medium to Large Applications","text":"<ul> <li>Best Method: Redux with Middleware (e.g., Redux Thunk)</li> <li>Why: If your application has multiple interconnected states and requires complex state management, Redux is a robust solution. It provides a clear structure for managing authentication alongside other global states, with middleware allowing for handling asynchronous actions like API calls.</li> </ul>"},{"location":"auth/router/best-method-for-auth/#3-reactive-applications","title":"3. Reactive Applications","text":"<ul> <li>Best Method: MobX</li> <li>Why: If you prefer a more reactive and less boilerplate-heavy approach, MobX is excellent for managing authentication state in a simpler manner. It's particularly beneficial for applications that require frequent state updates.</li> </ul>"},{"location":"auth/router/best-method-for-auth/#4-data-driven-applications","title":"4. Data-Driven Applications","text":"<ul> <li>Best Method: React Query</li> <li>Why: If your app heavily relies on data fetching, using React Query can simplify authentication as part of your data management strategy. It automatically handles caching, loading, and error states, making it efficient for managing authentication requests.</li> </ul>"},{"location":"auth/router/best-method-for-auth/#5-full-featured-authentication-solutions","title":"5. Full-Featured Authentication Solutions","text":"<ul> <li>Best Method: Firebase Authentication or Auth0</li> <li>Why: If you need a robust, secure, and scalable solution with built-in user management, using Firebase or Auth0 is ideal. They provide a wide range of authentication methods and handle security concerns, allowing you to focus on the frontend.</li> </ul>"},{"location":"auth/router/best-method-for-auth/#summary","title":"Summary","text":"<ul> <li>For Simplicity: Context API is great for small projects.</li> <li>For Complexity: Redux is best for larger, more complex applications.</li> <li>For Reactivity: MobX is good for applications needing frequent state updates.</li> <li>For Data Focus: React Query excels in data-driven contexts.</li> <li>For Full Solutions: Firebase and Auth0 are excellent for ready-made authentication systems.</li> </ul> <p>Ultimately, the choice should align with your team's skills, project needs, and how you foresee the application scaling in the future. If unsure, starting with the Context API for smaller projects and transitioning to Redux or a third-party service as complexity grows is a sound strategy.</p>"},{"location":"auth/router/not-found-component/","title":"Not Found","text":"<p>Here\u2019s an example of how you might implement a simple <code>NotFound</code> component to be used with a catch-all route in React Router v6.</p>"},{"location":"auth/router/not-found-component/#example","title":"Example","text":"NotFound ComponentUsage in Your RoutesExplanation <pre><code>import React from 'react';\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: 'center', marginTop: '50px' }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>You can then use this <code>NotFound</code> component in your routing setup like this:</p> <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport About from './About'; // Your About component\nimport Home from './Home';   // Your Home component\nimport NotFound from './NotFound'; // Your NotFound component\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ul> <li>NotFound Component: This component simply displays a message and provides a link to return to the homepage.</li> <li>Catch-All Route: The <code>path=\"*\"</code> route captures any undefined paths and renders the <code>NotFound</code> component, ensuring users have feedback when they navigate to a nonexistent route.</li> </ul> <p>This setup provides a user-friendly experience by guiding users back to valid pages!</p>"},{"location":"auth/router/not-found-component/#folder-struture","title":"Folder Struture","text":"<p>Here\u2019s a suggested folder structure for a React application that includes a NotFound component. This structure promotes organization and scalability:</p> Suggested Folder StructureExplanation of Structure <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u2514\u2500\u2500 NotFound.jsx   // Store your NotFound component here\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages             // Optional: for more complex structures\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles            // Optional: for CSS or styled components\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>/public</code>: Contains static assets and the main HTML file.</li> <li><code>/src</code>: Main source folder for your application.<ul> <li><code>/components</code>: This folder holds your React components, including the <code>NotFound</code> component.</li> <li><code>/pages</code>: (Optional) Useful if you want to separate different pages of your app into their own components, enhancing organization.</li> <li><code>/styles</code>: (Optional) Store your CSS or styled components here.</li> <li><code>App.jsx</code>: The main application file where you can set up your routes.</li> <li><code>index.js</code>: The entry point of your React application.</li> </ul> </li> </ul> <p>By organizing your components this way, you can easily manage and locate your files as your application grows!</p>"},{"location":"auth/router/not-found-component/#advanced","title":"Advanced","text":"<p>Here\u2019s a more advanced example of a React application that uses the <code>NotFound</code> component along with several routes, including nested routes, dynamic routing, and a simple layout.</p> <p>Folder Structure</p> <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u251c\u2500\u2500 NotFound.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Navbar.jsx\n\u2502   \u2502   \u2514\u2500\u2500 UserProfile.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Example</p> index.jsApp.jsxNavbar.jsxHomePage.jsxAboutPage.jsxUserProfile.jsxNotFound.jsx <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./styles/App.css\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport HomePage from \"./pages/HomePage\";\nimport AboutPage from \"./pages/AboutPage\";\nimport NotFound from \"./components/NotFound\";\nimport Navbar from \"./components/Navbar\";\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n                &lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1 Profile&lt;/Link&gt;\n            &lt;Link to=\"/user/2\"&gt;User 2 Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>import React from \"react\";\n\nconst HomePage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default HomePage;\n</code></pre> <pre><code>import React from \"react\";\n\nconst AboutPage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;About Us&lt;/h1&gt;\n            &lt;p&gt;This is the about page.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default AboutPage;\n</code></pre> <pre><code>import React from \"react\";\nimport { useParams } from \"react-router-dom\";\n\nconst UserProfile = () =&gt; {\n    const { id } = useParams();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Displaying profile for user ID: {id}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserProfile;\n</code></pre> <pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: \"center\", marginTop: \"50px\" }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>Explanation</p> <ol> <li>Routing Setup: The <code>App</code> component uses <code>BrowserRouter</code> to wrap the application and Routes to define paths.</li> <li>Dynamic Routing: The <code>UserProfile</code> component uses <code>useParams</code> to extract the user ID from the URL.</li> <li>Catch-All Route: The route <code>path=\"*\"</code> ensures that any undefined paths render the <code>NotFound</code> component.</li> <li>Navigation: The <code>Navbar</code> component provides links to navigate between the home page, about page, and user profiles.</li> </ol> <p>This setup showcases a more advanced application structure with routing, making it easier to manage and expand as your application grows!</p>"},{"location":"auth/router/react-router/","title":"React Router","text":"<p>React Router is a library that enables routing in React applications. It allows you to create single-page applications with navigation and different views without reloading the page. With React Router, you can define routes in your app, manage navigation, and render specific components based on the current URL.</p> <p>Since you've created a React app using npx create-react-app, you'll need to install React Router separately, as it's not included by default. You can install it using npm:</p> <pre><code>npm install react-router-dom\n</code></pre>"},{"location":"auth/router/react-router/#what-react-router-does","title":"What React Router Does:","text":"<ul> <li>Routing: Maps URLs to components, allowing different components to render based on the current path.</li> <li>Navigation: Provides components like <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> for navigation without full page reloads.</li> <li>Dynamic Routing: Supports parameters in routes, enabling you to create dynamic routes based on data.</li> <li>Nested Routes: Allows you to nest routes for better organization of your components.</li> <li>Programmatic Navigation: Offers functionality to navigate programmatically using hooks like <code>useNavigate</code>.</li> </ul> Basic Example <p>Here\u2019s a simple example to illustrate how to use React Router:</p> <ol> <li>Install it (as mentioned above).</li> <li> <p>Create some basic components:</p> <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n</code></pre> </li> <li> <p>Set up routing in your main component (e.g., <code>App.js</code>):</p> <pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\nimport Home from './Home';\nimport About from './About';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/nav&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>This example sets up a basic navigation between a home page and an about page. When you click the links, React Router will render the corresponding component without reloading the page.</p> </li> </ol>"},{"location":"auth/router/router-version/","title":"Version","text":"<ul> <li>React Router v4 - October 2017</li> <li>React Router v5 - February 2019</li> <li>React Router v6 - November 2021</li> <li>React Router v6.4 - June 2022</li> <li>React Router v6.8 - August 2023</li> </ul>"},{"location":"auth/router/router-version/#major-updates","title":"Major Updates","text":"<p>Here are the major updates from the key React Router versions that you should remember:</p> React Router v4React Router v5React Router v6React Router v6.4React Router v6.8 <ul> <li>Component-based API: Introduced a declarative way to define routes using components.</li> <li>Nested Routes: Allowed for easier management of nested routing.</li> <li> <p>Key Update: Component-based API and Nested Routes</p> Example<pre><code>import { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Hooks: Introduced <code>useParams</code>, <code>useLocation</code>, and other hooks for better access to routing data.</li> <li>Improved Redirects: Added more control over route rendering with props on <code>&lt;Route&gt;</code>.</li> <li> <p>Key Update: Hooks (<code>useParams</code>, <code>useLocation</code>)</p> Example<pre><code>import { BrowserRouter as Router, Route, Link, useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams();\n    return &lt;h2&gt;User ID: {id}&lt;/h2&gt;;\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/user/:id\" component={User} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li><code>Routes</code> Component: Replaced <code>Switch</code> for improved route matching.</li> <li>Route Ranking: Enhanced routing logic for better performance.</li> <li>Nested Routes: Simplified nested route definitions.</li> <li> <p>Key Update: <code>Routes</code> Component and Route Ranking</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Data APIs: Introduced loaders and actions for handling data fetching directly in routes.</li> <li>Layout Routes: Enhanced support for layouts in nested routes.</li> <li> <p>Key Update: Data APIs (Loaders and Actions)</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst loader = async () =&gt; {\n    const data = await fetch('/api/data'); // Fetch data\n    return data.json();\n};\n\nconst DataComponent = () =&gt; {\n    // Use data in your component\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Refinements: Continued improvements based on user feedback, focusing on data handling and route management.</li> <li> <p>Key Update: Refinements for improved data handling</p> <p><code>(Similar to v6.4 but with more refined API usage)</code></p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul>"},{"location":"auth/router/router-version/#additional","title":"Additional","text":"<p>In React Router v6, the <code>Routes</code> component replaced the <code>Switch</code> component from previous versions, and this change brought several improvements in how route matching works. Here\u2019s what it means:</p> <ol> <li> <p>Improved Route Matching</p> <ul> <li>Order of Matching:</li> </ul> <p>With <code>Switch</code>, the first route that matched was rendered, which could lead to issues if more specific routes were placed after more general ones. The new <code>Routes</code> component performs better by automatically ranking routes, meaning it will always match the most specific route first.</p> <ul> <li>Simplified Syntax:</li> </ul> <p><code>Routes</code> allows you to define routes using the <code>element</code> prop directly, making the syntax cleaner and easier to read.</p> Using <code>Switch</code> (v5)Using Routes (v6) <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this example, if you navigate to <code>/</code>, the <code>Home</code> component will render because it's matched first. However, if you had a more specific route, such as <code>/about</code>, it could potentially lead to unexpected behavior if not ordered correctly.</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this version with <code>Routes</code>, it handles matching more efficiently. It automatically prioritizes more specific paths, so you can be confident that the correct component will render based on the current URL.</p> </li> <li> <p>No Need for <code>exact</code></p> <p>In <code>v5</code>, you often had to use the <code>exact</code> prop to ensure that a route only matched when the path was exactly as specified. With <code>Routes</code>, the matching logic is more intuitive, and <code>exact</code> is no longer necessary.</p> </li> </ol> <p>Conclusion</p> <p>Overall, the shift from Switch to Routes in React Router v6 enhances route handling by making it more efficient, reducing potential errors, and simplifying the syntax for developers.</p>"},{"location":"auth/router/router-version/#route-ordering","title":"Route Ordering","text":""},{"location":"auth/router/router-version/#before-v6","title":"Before v6","text":"<p>Before React Router v6, specifically in versions 4 and 5, the order of matching was important when using the <code>Switch</code> component. Here's how it worked:</p> Key Points on Order of Matching with Switch <ol> <li> <p>First Match Wins:</p> <ul> <li>The <code>Switch</code> component rendered the first <code>&lt;Route&gt;</code> that matched the current location. This meant that if you had more specific routes after less specific ones, those specific routes would never be reached because the first matching route would take precedence.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>To prevent more general routes from matching, you often had to use the <code>exact</code> prop. This ensured that a route only matched if the path was exactly as specified.</li> </ul> </li> </ol> <p>Example</p> <p>Here's a demonstration of the matching behavior with <code>Switch</code>:</p> Incorrect Order Without <code>exact</code>Correct Order With <code>exact</code> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>If you navigate to <code>/</code>, this setup would render the <code>Home</code> component, and the <code>About</code> route would never be reached because it comes after the <code>/</code> route.</li> </ul> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>In this setup, using exact on the <code>/</code> route means it will only match when the path is exactly <code>/</code>. This allows the <code>/about</code> route to be matched correctly when you navigate to <code>/about</code>.</li> </ul> <p>Conclusion</p> <p>In summary, before v6, the order of routes and the use of the <code>exact</code> prop were crucial for ensuring the correct component rendered based on the URL. With the introduction of <code>Routes</code> in v6, these concerns have largely been alleviated, allowing for more intuitive and error-free routing!</p> <p>Sure! Here\u2019s an example of a React Router setup with multiple routes using Switch in versions 4 or 5. I'll illustrate how to properly order them to ensure the correct components render.</p> <p>Example with Multiple Routes</p> <p>Let\u2019s consider a scenario where we have the following components:</p> <ul> <li><code>Home</code></li> <li><code>About</code></li> <li><code>Contact</code></li> <li><code>AboutDetails</code></li> <li><code>UserProfile</code></li> </ul> ComponentsProper Ordering with <code>Switch</code>Explanation of Route OrderingConclusion <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n\n// Contact.js\nconst Contact = () =&gt; &lt;h2&gt;Contact&lt;/h2&gt;;\n\n// AboutDetails.js\nconst AboutDetails = () =&gt; &lt;h2&gt;About Details&lt;/h2&gt;;\n\n// UserProfile.js\nconst UserProfile = () =&gt; &lt;h2&gt;User Profile&lt;/h2&gt;;\n</code></pre> <pre><code>import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/contact\"&gt;Contact&lt;/Link&gt;\n            &lt;Link to=\"/about/details\"&gt;About Details&lt;/Link&gt;\n            &lt;Link to=\"/user/john\"&gt;User Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n\n        &lt;Switch&gt;\n            {/* Specific routes should come first */}\n            &lt;Route path=\"/about/details\" component={AboutDetails} /&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/contact\" component={Contact} /&gt;\n            &lt;Route path=\"/user/:username\" component={UserProfile} /&gt;\n\n            {/* This should be the last route to match the root path */}\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ol> <li> <p>Specific Routes First:</p> <ul> <li>The <code>/about/details</code> route is placed first because it is more specific than the <code>/about</code> route. If you placed <code>/about</code> first, navigating to <code>/about/details</code> would incorrectly render the About component.</li> </ul> </li> <li> <p>General Routes Last:</p> <ul> <li>The root path (<code>/</code>) is placed last. If it were placed earlier, it would match any path and render the <code>Home</code> component, preventing any of the more specific routes from rendering.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>The <code>exact</code> prop on the root path (<code>/</code>) ensures it only matches the exact URL <code>/</code>, allowing all other routes to be matched properly without interference.</li> </ul> </li> </ol> <p>This setup demonstrates how to structure and order your routes effectively using the <code>Switch</code> component before React Router v6. Proper ordering is crucial to ensure that the intended components render based on the URL, especially when dealing with multiple routes and nested paths!</p>"},{"location":"auth/router/router-version/#after-v6","title":"After v6","text":"<p>In React Router v6, you do not need to worry about the order of matching in the same way you did in previous versions with Switch. Here\u2019s why:</p> Automatic Route Ranking <ul> <li> <p>Specificity:</p> <p>React Router v6 automatically ranks routes based on their specificity. This means that it will match the most specific route first, regardless of the order you define them in your <code>Routes</code>.</p> </li> <li> <p>No Need for <code>exact</code>:</p> <p>Unlike in v5, where you often had to use the <code>exact</code> prop to avoid unintentional matches, v6 handles this internally. A route will only match if it corresponds precisely to the current URL.</p> </li> </ul> Example <p>Here\u2019s an example to illustrate this:</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about/details\" element={&lt;AboutDetails /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this case:</p> <ul> <li>If you navigate to <code>/about/details</code>, it will render the <code>AboutDetails</code> component.</li> <li>If you navigate to <code>/about</code>, it will render the <code>About</code> component.</li> <li>If you navigate to <code>/</code>, it will render the <code>Home</code> component.</li> </ul> <p>Conclusion</p> <p>You can define your routes in any order, and React Router v6 will ensure that the correct component is rendered based on the URL, making it easier to manage your routes without worrying about their sequence. This significantly simplifies routing logic and reduces the potential for errors!</p>"},{"location":"auth/router/routing/","title":"Routing","text":"<p>Routing logic in web applications defines how different URLs (or paths) correspond to various components or views in the application. In React, this is primarily handled by libraries like react-router-dom.</p> <pre><code>-   Basic Routing\n-   Dynamic Routing\n-   Nested Routes\n-   Redirects\n-   Protected Routes\n-   404 Handling\n-   Lazy Loading\n-   History Management\n-   Custom Hooks for Routing\n-   Route Guards\n</code></pre> Install React Router <p>First, ensure you have <code>react-router-dom</code> installed:</p> <pre><code>npm install react-router-dom\n</code></pre> <p>Here are some key concepts and techniques related to routing logic:</p>"},{"location":"auth/router/routing/#1-basic-routing","title":"1. Basic Routing","text":"<ul> <li> <p>Single Page Application (SPA): In SPAs, routing is done client-side. The browser loads a single HTML page and JavaScript takes care of changing views without reloading the page.</p> </li> <li> <p>Route Definition: Routes are defined to map URL paths to React components, usually using <code>&lt;Route&gt;</code> components. Each route specifies a <code>path</code> and the corresponding <code>element</code> to render.</p> </li> </ul> AppRoutes.js (Basic Example) <pre><code>import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from '../components/Home/Home';\nimport About from '../components/About/About';\nimport NotFound from '../components/NotFound/NotFound';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"auth/router/routing/#2-dynamic-routing","title":"2. Dynamic Routing","text":"<ul> <li>Route Parameters: You can create dynamic routes that accept parameters. For example, <code>/user/:id</code> can capture the <code>id</code> of a user, allowing you to render user-specific components based on the URL.</li> </ul> User.js (Dynamic Example) <pre><code>import React from 'react';\nimport { useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams(); // Fetching dynamic parameter\n    return &lt;h1&gt;User Profile: {id}&lt;/h1&gt;;\n};\n\nexport default User;\n</code></pre>"},{"location":"auth/router/routing/#3-nested-routes","title":"3. Nested Routes","text":"<ul> <li>Hierarchy: You can have routes within routes, enabling more complex structures. This is useful for layouts where certain components (like a sidebar or header) are always present.</li> </ul> AppRoutes.js (Advanced with Nested Routes) <pre><code>import User from '../components/User/User';\nimport UserProfile from '../components/User/UserProfile';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;}&gt;\n                &lt;Route path=\"profile\" element={&lt;UserProfile /&gt;} /&gt; {/* Nested route */}\n            &lt;/Route&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/router/routing/#4-redirects","title":"4. Redirects","text":"<ul> <li>Redirecting Users: You can use redirect logic to send users to different paths based on certain conditions, like authentication status or specific URL patterns.</li> </ul> AppRoutes.js (Redirect Example) <p>You can use <code>&lt;Navigate /&gt;</code> for redirects:</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/old-path\" element={&lt;Navigate to=\"/new-path\" replace /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/router/routing/#5-protected-routes","title":"5. Protected Routes","text":"<ul> <li>Authentication Checks: Certain routes can be protected, requiring users to be authenticated. You can create higher-order components (HOCs) or render logic that checks authentication before allowing access.</li> </ul> AuthContext.jsProtectedRoute.jsAdmin.jsAppRoutes.js <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const login = () =&gt; setIsAuthenticated(true);\n    const logout = () =&gt; setIsAuthenticated(false);\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\nexport const useAuth = () =&gt; useContext(AuthContext);\n</code></pre> <pre><code>import React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ element }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p><code>Admin.js</code> (Protected Route Example)</p> <pre><code>import React from 'react';\n\nconst Admin = () =&gt; {\n    return &lt;h1&gt;Admin Page - Access Restricted&lt;/h1&gt;;\n};\n</code></pre> <p><code>AppRoutes.js</code> (Including Protected Routes)</p> <pre><code>import ProtectedRoute from '../components/ProtectedRoute';\nimport Admin from '../components/Admin/Admin';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/admin\" element={&lt;ProtectedRoute element={&lt;Admin /&gt;} /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/router/routing/#6-404-not-found-routes","title":"6. 404 Not Found Routes","text":"<ul> <li>Catch-All Route: A route can be defined to catch all unmatched paths, typically rendering a \"Not Found\" component. This helps in providing a better user experience for invalid URLs.</li> </ul> Example <p>This is already covered in the earlier examples, but the wildcard route (<code>path=\"*\"</code>) ensures that any unmatched route renders the <code>NotFound</code> component.</p>"},{"location":"auth/router/routing/#7-lazy-loading-routes","title":"7. Lazy Loading Routes","text":"<ul> <li>Code Splitting: Use React\u2019s <code>lazy</code> and <code>Suspense</code> to load components only when needed, improving initial load times. This is particularly useful for larger applications with many routes.</li> </ul> User.js (Lazy Loading Example) <p>You can use <code>React.lazy</code> to lazily load components.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nconst UserProfile = lazy(() =&gt; import('./UserProfile'));\n\nconst User = () =&gt; {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;UserProfile /&gt;\n        &lt;/Suspense&gt;\n    );\n};\n</code></pre>"},{"location":"auth/router/routing/#8-history-management","title":"8. History Management","text":"<ul> <li>Browser History: React Router uses the browser's history API to manage navigation. This allows for back and forward navigation without reloading the page.</li> </ul> <p>react-router-dom handles browser history automatically, allowing for back and forward navigation. You can also use <code>useNavigate</code> for programmatic navigation.</p> Example of <code>useNavigate</code> <pre><code>import { useNavigate } from 'react-router-dom';\n\nconst SomeComponent = () =&gt; {\n    const navigate = useNavigate();\n\n    const handleClick = () =&gt; {\n        navigate('/about'); // Programmatically navigate to about\n    };\n\n    return &lt;button onClick={handleClick}&gt;Go to About&lt;/button&gt;;\n};\n</code></pre>"},{"location":"auth/router/routing/#9-custom-route-logic","title":"9. Custom Route Logic","text":"<ul> <li>Custom Hooks: You can create custom hooks for complex routing logic, like checking user roles or fetching data before rendering a route.</li> </ul> useCurrentPath.js <p>You can create custom hooks to access the current path.</p> <pre><code>import { useLocation } from 'react-router-dom';\n\nconst useCurrentPath = () =&gt; {\n    const location = useLocation();\n    return location.pathname;\n};\n\nexport default useCurrentPath;\n</code></pre>"},{"location":"auth/router/routing/#10-using-route-guards","title":"10. Using Route Guards","text":"<ul> <li>Authorization Checks: Implement route guards to restrict access to certain components based on user roles or permissions, enhancing security in your application</li> </ul> Custom Guard Example <p>You can create more complex guards using custom logic.</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst RoleBasedRoute = ({ element, allowedRoles }) =&gt; {\n    const { userRole } = useAuth(); // Assume you have user roles in context\n    return allowedRoles.includes(userRole) ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n</code></pre> <p>Final Setup in <code>App.js</code></p> App.js<pre><code>import React from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport { AuthProvider } from \"./context/AuthContext\";\n\nfunction App() {\n  return (\n    &lt;AuthProvider&gt;\n      &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n          &lt;Navbar /&gt;\n          &lt;AppRoutes /&gt;\n        &lt;/div&gt;\n      &lt;/Router&gt;\n    &lt;/AuthProvider&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"auth/router/routing/#summary","title":"Summary","text":"<p>Routing logic can be simple or complex depending on the application's requirements. Understanding these techniques allows you to create more robust, maintainable, and user-friendly web applications. Here's a brief summary of techniques:</p>"},{"location":"auth/router/routing/#summary-of-concepts","title":"Summary of Concepts","text":"<ol> <li>Basic Routing: Defined straightforward paths to components.</li> <li>Dynamic Routing: Used URL parameters to dynamically render content.</li> <li>Nested Routes: Demonstrated child routes for complex layouts.</li> <li>Redirects: Redirected users based on certain conditions.</li> <li>Protected Routes: Restricted access based on authentication.</li> <li>404 Handling: Managed unmatched routes gracefully.</li> <li>Lazy Loading: Improved performance by loading components only when needed.</li> <li>History Management: Utilized the built-in browser history.</li> <li>Custom Hooks for Routing: Created reusable hooks for accessing routing data.</li> <li>Route Guards: Implemented role-based access control.</li> </ol>"},{"location":"auth/router/routing/#folder-structure","title":"Folder Structure","text":"<pre><code>/src\n  /components\n    /Navbar\n      Navbar.js\n      Navbar.css\n    /Home\n      Home.js\n    /About\n      About.js\n    /NotFound\n      NotFound.js\n    /User\n      User.js\n      UserProfile.js\n    /Admin\n      Admin.js\n  /routes\n    AppRoutes.js\n  /context\n    AuthContext.js\n  App.js\n  index.js\n</code></pre>"},{"location":"auth/router/why-react-router/","title":"Why React Router","text":"<p>React Router is beneficial for several reasons:</p> <ol> <li>Dynamic Routing: It allows you to create routes that can change based on user interaction or application state, enabling a more dynamic user experience.</li> <li>Nested Routing: You can set up nested routes, which helps maintain a clear structure in larger applications, making it easier to manage related components.</li> <li>Code Splitting: React Router supports lazy loading of routes, which improves performance by loading only the necessary code for the current view.</li> <li>Browser History Management: It simplifies managing browser history, allowing users to navigate back and forth seamlessly.</li> <li>URL Management: React Router enables clean and meaningful URLs, which is important for usability and SEO.</li> <li>Declarative Routing: You define routes in a declarative manner, which integrates well with the React component model.</li> <li>State Preservation: It allows you to maintain state across different routes, making it easier to build a consistent user experience.</li> </ol> <p>Overall, while you can build applications without it, React Router makes managing navigation and routing in React apps much easier and more efficient, especially as they grow in complexity.</p>"},{"location":"auth/router/why-react-router/#additional","title":"Additional","text":"<p>Here are some lesser-known aspects and potential pitfalls of React Router that you might want to be aware of:</p> <ol> <li> <p>Route Rendering: The way you render routes can affect your app\u2019s performance. Using <code>component</code> vs. <code>render</code> props can lead to unnecessary re-renders if not handled carefully.</p> </li> <li> <p>Data Fetching: While React Router itself doesn\u2019t handle data fetching, it\u2019s common to implement data loading in route components, which can lead to duplicated logic if not structured properly.</p> </li> <li> <p>Context Issues: If you\u2019re using multiple routers or nesting, managing context can become complex. Be cautious about how context providers interact with router components.</p> </li> <li> <p>Use of <code>Link</code>: Always use the <code>Link</code> component for navigation instead of anchor (<code>&lt;a&gt;</code>) tags. This prevents a full page reload and ensures that React Router can manage the app\u2019s history correctly.</p> </li> <li> <p>Nested Routes Complexity: While nested routes can be powerful, they can also add complexity to your routing logic. It\u2019s important to manage props and state effectively when dealing with deeply nested routes.</p> </li> <li> <p>404 Handling: Setting up a catch-all route for handling 404 pages can sometimes be overlooked, leading to a poor user experience when users navigate to nonexistent routes.</p> </li> <li> <p>Browser History Management: Understanding how React Router interacts with the browser\u2019s history stack is crucial. Mismanagement can lead to issues with the back and forward buttons.</p> </li> <li> <p>Version Changes: Keep an eye on version changes and breaking changes. React Router has gone through significant changes over versions, particularly from v5 to v6.</p> </li> <li> <p>Custom Route Matching: You can create custom route matching logic, but it can get tricky if not well-documented within your codebase.</p> </li> <li> <p>Accessibility: Ensure that your routing and navigation components are accessible, as React Router does not automatically handle ARIA roles and attributes.</p> </li> </ol> <p>Being aware of these nuances can help you use React Router more effectively and avoid common pitfalls!</p>"},{"location":"auth/router/why-react-router/#example","title":"Example","text":"<p>Sure! Here are some examples of good and bad practices with React Router:</p>"},{"location":"auth/router/why-react-router/#1-route-rendering","title":"1. Route Rendering","text":"Bad Example: Using <code>component</code> Prop <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This approach can lead to unnecessary re-renders if the About component's props change.</p> <p><code>Fine with v5</code></p> Good Example: Using <code>element</code> Prop (React Router v6) <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <p>Using the <code>element</code> prop helps maintain a clean render and optimizes performance.</p>"},{"location":"auth/router/why-react-router/#2-conditional-rendering","title":"2. Conditional Rendering","text":"Bad Example: Conditional Logic in Route Definition <pre><code>&lt;Route path=\"/profile\" render={() =&gt; user ? &lt;Profile /&gt; : &lt;Redirect to=\"/login\" /&gt;} /&gt;\n</code></pre> <p>This can be harder to read and maintain.</p> Good Example: Use a Wrapper Component <pre><code>const PrivateRoute = ({ children }) =&gt; {\n    return user ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\n// Usage\n&lt;Route path=\"/profile\" element={&lt;PrivateRoute&gt;&lt;Profile /&gt;&lt;/PrivateRoute&gt;} /&gt;\n</code></pre> <p>This keeps your routes cleaner and separates concerns.</p>"},{"location":"auth/router/why-react-router/#3-handling-404-pages","title":"3. Handling 404 Pages","text":"Bad Example: Not Defining a Catch-All Route <p>If you forget to handle undefined routes, users might just see a blank page.</p> Good Example: Defining a Catch-All Route <pre><code>&lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n</code></pre> <p>This way, users will always have feedback if they navigate to a nonexistent route.</p>"},{"location":"auth/router/why-react-router/#4-navigation-with-link","title":"4. Navigation with <code>Link</code>","text":"Bad Example: Using <code>&lt;a&gt;</code> Tag for Navigation <pre><code>&lt;a href=\"/about\"&gt;About&lt;/a&gt;\n</code></pre> <p>This causes a full page reload, losing the single-page app experience.</p> Good Example: Using <code>&lt;Link&gt;</code> <pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> <p>This enables React Router to manage navigation without reloading the page.</p>"},{"location":"auth/router/why-react-router/#5-nested-routes","title":"5. Nested Routes","text":"Bad Example: Deeply Nested Routes Without Organization <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n    // more deeply nested routes...\n&lt;/Route&gt;\n</code></pre> <p>This can get confusing and hard to manage.</p> Good Example: Clear Nested Structure <pre><code>&lt;Route path=\"/dashboard/*\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n&lt;/Route&gt;\n</code></pre> <p>Using <code>/*</code> makes it clear that more routes are nested under <code>/dashboard</code>.</p> <p>Summary</p> <p>Using React Router effectively involves keeping your code organized, making good use of props, and handling navigation and state management thoughtfully. Following these good practices will lead to a cleaner, more maintainable, and more user-friendly application!</p>"},{"location":"auth/router/why-react-router/#changes-v5-vs-v6","title":"Changes <code>v5</code> vs <code>v6</code>","text":"<p>Exactly! Here\u2019s a breakdown:</p> In React Router v5In React Router v6Why the Change? <p>Using this syntax is perfectly acceptable:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This correctly renders the <code>About</code> component when the path matches. It\u2019s a standard practice for v5.</p> <p>This syntax becomes outdated and not recommended:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>In v6, you should use:</p> <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <ul> <li>Simpler API: The v6 <code>element</code> prop allows you to directly pass a React element, which can help avoid issues with re-renders and make the code cleaner.</li> <li>Consistency: It aligns better with how React works, encouraging the use of JSX for rendering.</li> </ul> <p>So, in summary, while the original example is good practice in v5, it becomes a bad example in v6 due to the API changes. Always make sure to follow the guidelines specific to the version you\u2019re using!</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/","title":"Callback Function and useCallback is not same","text":"<p>No, a callback function and the <code>useCallback</code> hook in React are not the same thing, though they are related concepts. Here\u2019s a breakdown of each:</p>","tags":["react"]},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/#callback-function","title":"Callback Function","text":"<ul> <li>Definition: A callback function is simply a function that you pass as an argument to another function. It is executed at a later time when a certain condition is met or an event occurs.</li> <li>Usage: In React, callback functions are often used for handling events, managing state updates, or communicating between components.</li> </ul> <pre><code>const handleClick = () =&gt; {\n  console.log(\"Button clicked!\");\n};\n\n// Using it as a callback\n&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/#usecallback-hook","title":"<code>useCallback</code> Hook","text":"<ul> <li>Definition: The <code>useCallback</code> hook is a React hook that returns a memoized version of a callback function. It\u2019s used to optimize performance by preventing unnecessary re-creations of functions on every render.</li> <li>Usage: You typically use <code>useCallback</code> when passing callback functions to child components to avoid re-renders when the parent component updates.</li> </ul> <pre><code>import React, { useState, useCallback } from \"react\";\n\nconst App = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  // Memoized callback function using useCallback\n  const handleIncrement = useCallback(() =&gt; {\n    setCount((prevCount) =&gt; prevCount + 1);\n  }, []); // Dependency array\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/#key-differences","title":"Key Differences","text":"<ol> <li> <p>Purpose:</p> <ul> <li>Callback Function: A general concept for any function passed as an argument.</li> <li><code>useCallback</code>: A specific hook to memoize a function, optimizing performance and avoiding unnecessary re-renders.</li> </ul> </li> <li> <p>Performance:</p> <ul> <li>Callback Function: Can lead to performance issues if the function is re-created on every render.</li> <li><code>useCallback</code>: Helps prevent performance issues by keeping the same function instance between renders when dependencies don\u2019t change.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/#summary","title":"Summary","text":"<p>While both terms involve functions that can be passed around, a callback function is a general programming concept, whereas <code>useCallback</code> is a specific React hook used to optimize performance.</p>","tags":["react"]},{"location":"blog/2024/07/15/callback-function-and-usecallback-is-not-same/#additional","title":"Additional","text":"<p>In the example you provided, <code>handleClick</code> is considered a callback function because it is passed as an argument to another function, specifically the event handler for the button's <code>onClick</code> event.</p> Breakdown of the ExampleHow It Works <ol> <li> <p>Definition of the Callback Function:</p> <pre><code>const handleClick = () =&gt; {\n    console.log(\"Button clicked!\");\n};\n</code></pre> <ul> <li>Here, <code>handleClick</code> is a function defined using an arrow function syntax. It will execute the code inside its body when called.</li> </ul> </li> <li> <p>Using the Callback in an Event Handler:</p> <pre><code>&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;\n</code></pre> <ul> <li>The <code>handleClick</code> function is passed as the value for the <code>onClick</code> property of the <code>&lt;button&gt;</code> element.</li> <li>In this context, <code>handleClick</code> is not executed immediately; instead, it will be invoked later by React when the button is clicked.</li> </ul> </li> </ol> <ul> <li> <p>Event Handling: When the user clicks the button, the <code>onClick</code> event is triggered. React calls the <code>handleClick</code> function at that moment, executing its contents (in this case, logging \"Button clicked!\" to the console).</p> </li> <li> <p>Callback Nature: Because <code>handleClick</code> is not executed until the button is clicked, it acts as a \"callback\" \u2014 a function that will be called later in response to an event.</p> </li> </ul> <p>Summary</p> <p>In this example, <code>handleClick</code> is a callback function because it is passed to the <code>onClick</code> event handler and is executed when the user interacts with the button. This pattern is common in React for managing user interactions and handling events.</p>","tags":["react"]},{"location":"blog/2024/07/12/conditionally-rendering-navbar-in-react/","title":"Conditionally Rendering Navbar in React","text":"<p>Using <code>{isAuthenticated &amp;&amp; &lt;Navbar /&gt;}</code> to conditionally render the <code>Navbar</code> is a common and effective approach in React. It provides a simple way to show or hide components based on a boolean state.</p> <p>Here are some points to consider regarding this approach:</p>","tags":["react"]},{"location":"blog/2024/07/12/conditionally-rendering-navbar-in-react/#advantages","title":"Advantages","text":"<ol> <li> <p>Simplicity: This approach is straightforward and easy to understand, making it clear that the <code>Navbar</code> is tied directly to the authentication state.</p> </li> <li> <p>Performance: Conditional rendering ensures that the <code>Navbar</code> component is not mounted in the DOM unless the user is authenticated, which can save on unnecessary rendering and processing.</p> </li> <li> <p>Readability: The code remains clean and readable, maintaining a clear separation between the authentication logic and the UI rendering.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/12/conditionally-rendering-navbar-in-react/#alternatives","title":"Alternatives","text":"<p>While the current approach works well, there are alternative methods you could consider, depending on your application's needs:</p> <ol> <li> <p>Higher-Order Component (HOC): You could create a HOC that wraps your main app or specific routes, handling the logic of showing or hiding the <code>Navbar</code>. This could make it reusable across different parts of your app.</p> </li> <li> <p>Context API: If your app grows and requires more complex state management, you might consider using the Context API to manage authentication state across your application. This allows for more flexibility and scalability.</p> </li> <li> <p>Route-Based Rendering: Instead of conditionally rendering in the main <code>App</code> component, you could manage the <code>Navbar</code> directly in your <code>AppRoutes</code>. For example, you could show the <code>Navbar</code> on all authenticated routes and hide it on public routes.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/12/conditionally-rendering-navbar-in-react/#conclusion","title":"Conclusion","text":"<p>For many applications, using <code>{isAuthenticated &amp;&amp; &lt;Navbar /&gt;}</code> is perfectly suitable and efficient. As your application grows, you can always refactor your authentication logic as needed. If you find that your authentication logic or routing becomes more complex, considering alternatives like HOCs or the Context API might be beneficial.</p> <p>If you have any specific requirements or future plans for your application, feel free to share, and I can provide more tailored advice!</p>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/","title":"The Functional Update Pattern Explained","text":"<p>The functional update pattern in React is a method of updating state by using a function that takes the previous state as an argument. This pattern ensures that you always work with the most current state value, which is especially important in scenarios where state updates may be batched or occur in quick succession.</p> <p>Mastering State Management in React: The Functional Update Pattern Explained</p>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#key-features-of-the-functional-update-pattern","title":"Key Features of the Functional Update Pattern","text":"<ol> <li> <p>Access to Previous State:</p> <ul> <li>The function you provide to the state updater (like setState) receives the previous state as an argument. This allows you to derive the new state based on the most recent value.</li> </ul> </li> <li> <p>Asynchronous Updates:</p> <ul> <li>React's state updates can be asynchronous. By using the functional update pattern, you avoid issues that can arise from referencing a stale state value.</li> </ul> </li> <li> <p>Prevents Bugs:</p> <ul> <li>When multiple updates depend on the previous state, using this pattern can prevent bugs related to incorrect state values due to overlapping updates.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#example-of-the-functional-update-pattern","title":"Example of the Functional Update Pattern","text":"<p>Here\u2019s a simple example using a counter component:</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount((prevCount) =&gt; prevCount + 1); // Using functional update\n  };\n\n  const decrement = () =&gt; {\n    setCount((prevCount) =&gt; prevCount - 1); // Using functional update\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Counter;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#why-use-the-functional-update-pattern","title":"Why Use the Functional Update Pattern?","text":"<ol> <li>Accuracy: Ensures that you are working with the latest state value, preventing errors due to outdated references.</li> <li>Simplicity: Keeps your state updates straightforward and clear, especially when the new state depends on the previous state.</li> <li>Better Performance: Helps React optimize re-renders, as it can determine more efficiently when state updates occur.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#conclusion","title":"Conclusion","text":"<p>The functional update pattern is an essential technique in React for managing state updates accurately. By utilizing this pattern, you can create more reliable and maintainable components, ensuring that your application behaves as expected even in complex scenarios.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/","title":"Understanding the Importance of Using Previous State in React","text":"<p>In React, managing state efficiently is crucial for building responsive and bug-free applications. One common practice that developers should adopt is using the previous state when updating state values.</p> <p>This simple pattern can prevent a range of issues related to state management, especially in dynamic applications where multiple updates may occur rapidly.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#why-use-previous-state","title":"Why Use Previous State?","text":"<ol> <li> <p>Accurate Updates:</p> <p>When you use the previous state, you ensure that each update is based on the most current value. This is particularly important when multiple state updates are triggered in quick succession. If you simply rely on the current state, you risk missing updates, leading to incorrect values.</p> <p>For example:</p> <pre><code>setCount(count + 1); // May lead to missed increments\n</code></pre> <p>Instead, using the previous state guarantees accurate calculations:</p> <pre><code>setCount((prevCount) =&gt; prevCount + 1); // Safely increments the count\n</code></pre> </li> <li> <p>Functional Updates:</p> <p>React allows state updates to be made using a function that receives the previous state as an argument. This functional update pattern enhances clarity and ensures that you\u2019re working with the most recent state.</p> <pre><code>setCount((prevCount) =&gt; prevCount - 1); // Decrements reliably\n</code></pre> </li> <li> <p>Asynchronous Nature of State Updates:</p> <p>React state updates are asynchronous, meaning they don\u2019t occur immediately. Without using the previous state, you might inadvertently work with a stale value, leading to unexpected behavior in your application.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#conclusion","title":"Conclusion","text":"<p>Using the previous state when updating values in React is a best practice that enhances the reliability and accuracy of your state management. By adopting this pattern, developers can avoid potential bugs and ensure that their components respond correctly to user interactions. Next time you\u2019re updating state, remember to use (prevState) to maintain the integrity of your application\u2019s data flow!</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#additional","title":"Additional","text":"ExampleExplanationConclusion <pre><code>import React, { useState } from 'react';\n\nconst ItemList = () =&gt; {\n    const [items, setItems] = useState([\n        { id: 1, name: 'Item 1' },\n        { id: 2, name: 'Item 2' },\n    ]);\n\n    const [newItemName, setNewItemName] = useState('');\n\n    // Adding an item using previous state\n    const addItem = () =&gt; {\n        if (newItemName.trim() === '') return; // Prevent adding empty items\n            const newItem = {\n            id: items.length + 1, // Simple ID generation\n            name: newItemName,\n        };\n        setItems((prevItems) =&gt; [...prevItems, newItem]); // Use previous state to add a new item\n        setNewItemName(''); // Clear input field\n    };\n\n    // Removing an item using previous state\n    const removeItem = (id) =&gt; {\n        setItems((prevItems) =&gt; prevItems.filter(item =&gt; item.id !== id)); // Use previous state to filter out the item\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Item List&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newItemName}\n                onChange={(e) =&gt; setNewItemName(e.target.value)} // Handle input change\n                placeholder=\"Add new item\"\n            /&gt;\n            &lt;button onClick={addItem}&gt;Add Item&lt;/button&gt;\n\n            &lt;ul&gt;\n                {items.map((item) =&gt; (\n                &lt;li key={item.id}&gt;\n                    {item.name}\n                    &lt;button onClick={() =&gt; removeItem(item.id)}&gt;Remove&lt;/button&gt;\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ItemList;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>items</code>: An array of objects representing the list of items, where each object has an <code>id</code> and a <code>name</code>.</li> <li><code>newItemName</code>: A string for the input field to capture the new item's name.</li> </ul> </li> <li> <p>Using Previous State:</p> <ul> <li>Adding Items: When adding a new item, we use the previous state with <code>setItems((prevItems) =&gt; [...prevItems, newItem])</code>. This ensures that we're working with the most current version of the <code>items</code> array.</li> <li>Removing Items: The <code>removeItem</code> function also utilizes the previous state to filter out the item by its ID, ensuring that we accurately reflect the current list.</li> </ul> </li> <li> <p>Rendering:</p> <ul> <li>An input field captures the new item's name, and a button adds it to the list.</li> <li>The list of items is displayed, with a \"Remove\" button for each item that allows users to delete it.</li> </ul> </li> </ol> <p>Using the previous state when managing complex data structures like lists in React is crucial for maintaining data integrity. It helps ensure that updates reflect the current state accurately, especially in scenarios involving asynchronous updates or multiple rapid interactions. By adopting this practice, developers can create more reliable and bug-free applications.</p>","tags":["react"]},{"location":"blog/2024/07/06/folder-structure-for-large-react-application/","title":"Folder Structure for Large React Application","text":"<p>Sure! For a larger React application, an advanced folder structure helps maintain organization and scalability. Here\u2019s an example:</p> Folder StructureExplanation of the StructureAdditional Considerations <pre><code>my-large-react-app/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u2514\u2500\u2500 assets/\n\u2502       \u251c\u2500\u2500 images/\n\u2502       \u2514\u2500\u2500 fonts/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/                  # API calls and services\n\u2502   \u2502   \u251c\u2500\u2500 userService.js\n\u2502   \u2502   \u2514\u2500\u2500 postService.js\n\u2502   \u251c\u2500\u2500 components/           # Shared components\n\u2502   \u2502   \u251c\u2500\u2500 Button/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Button.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Button.css\n\u2502   \u2502   \u251c\u2500\u2500 Navbar/\n\u2502   \u2502   \u2514\u2500\u2500 Footer/\n\u2502   \u251c\u2500\u2500 features/             # Feature-specific components\n\u2502   \u2502   \u251c\u2500\u2500 auth/             # Authentication feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Register.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authSlice.js   # Redux slice or context\n\u2502   \u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dashboard.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 posts/\n\u2502   \u2502       \u251c\u2500\u2500 PostList.js\n\u2502   \u2502       \u251c\u2500\u2500 PostDetail.js\n\u2502   \u2502       \u2514\u2500\u2500 postSlice.js\n\u2502   \u251c\u2500\u2500 hooks/                # Custom hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 useFetch.js\n\u2502   \u251c\u2500\u2500 context/              # Context API files\n\u2502   \u2502   \u251c\u2500\u2500 AuthContext.js\n\u2502   \u2502   \u2514\u2500\u2500 ThemeContext.js\n\u2502   \u251c\u2500\u2500 pages/                # Page components\n\u2502   \u2502   \u251c\u2500\u2500 HomePage.js\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.js\n\u2502   \u2502   \u2514\u2500\u2500 ContactPage.js\n\u2502   \u251c\u2500\u2500 routes/               # Route configuration\n\u2502   \u2502   \u2514\u2500\u2500 AppRoutes.js\n\u2502   \u251c\u2500\u2500 styles/               # Global styles\n\u2502   \u2502   \u251c\u2500\u2500 variables.css\n\u2502   \u2502   \u2514\u2500\u2500 global.css\n\u2502   \u251c\u2500\u2500 utils/                # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js\n\u2502   \u2502   \u2514\u2500\u2500 constants.js\n\u2502   \u251c\u2500\u2500 App.js                # Main App component\n\u2502   \u251c\u2500\u2500 index.js              # Entry point\n\u2502   \u2514\u2500\u2500 store/                # Redux or global state management\n\u2502       \u251c\u2500\u2500 store.js\n\u2502       \u2514\u2500\u2500 rootReducer.js\n\u251c\u2500\u2500 .env                      # Environment variables\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 README.md\n</code></pre> <ul> <li> <p><code>public/</code>: Contains static assets and the main HTML file.</p> </li> <li> <p><code>src/</code>: The core of your application.</p> <ul> <li> <p><code>api/</code>: Contains files for making API calls or managing external services.</p> </li> <li> <p><code>components/</code>: Shared components that can be reused across the application, organized in subfolders by component name.</p> </li> <li> <p><code>features/</code>: Group components, slices (if using Redux), and logic by feature. This can help keep related functionality together.</p> </li> <li> <p><code>hooks/</code>: Custom hooks to encapsulate reusable logic.</p> </li> <li> <p><code>context/</code>: Files related to the Context API, useful for managing global state.</p> </li> <li> <p><code>pages/</code>: Components that correspond to different pages or views of the application.</p> </li> <li> <p><code>routes/</code>: Centralized route configuration for organizing application routes.</p> </li> <li> <p><code>styles/</code>: Global styles and variables for consistent theming.</p> </li> <li> <p><code>utils/</code>: Utility functions and constants that are used throughout the app.</p> </li> <li> <p><code>store/</code>: Redux or other global state management setup, including the store and root reducer.</p> </li> </ul> </li> </ul> <ul> <li>Testing: You might want to add a <code>__tests__</code> folder within relevant directories for unit tests.</li> <li>Assets: A dedicated assets folder can be useful for images, icons, and fonts.</li> <li>Documentation: Consider a <code>docs/</code> folder if your project requires extensive documentation.</li> </ul> <p>This structure supports scalability and maintainability, making it easier for developers to navigate and manage the application as it grows!</p>","tags":["react"]},{"location":"blog/2024/07/06/folder-structure-for-large-react-application/#features-folder","title":"<code>features/</code> Folder","text":"<p>The <code>features/</code> folder in a large React application serves as a way to organize components, logic, and state management related to specific features or sections of the application. This approach helps in keeping related code together, making it easier to manage and scale.</p> Structure of the <code>features/</code> Folder <p>Here\u2019s an example of how you might structure a <code>features/</code> folder:</p> StructureExplanation of Each Feature Folder <pre><code>src/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 auth/\n    \u2502   \u251c\u2500\u2500 Login.js\n    \u2502   \u251c\u2500\u2500 Register.js\n    \u2502   \u251c\u2500\u2500 authSlice.js         # Redux slice for auth state\n    \u2502   \u2514\u2500\u2500 authAPI.js           # API calls related to authentication\n    \u251c\u2500\u2500 dashboard/\n    \u2502   \u251c\u2500\u2500 Dashboard.js\n    \u2502   \u251c\u2500\u2500 Stats.js\n    \u2502   \u251c\u2500\u2500 dashboardSlice.js     # Redux slice for dashboard state\n    \u2502   \u2514\u2500\u2500 dashboardAPI.js       # API calls related to dashboard\n    \u2514\u2500\u2500 posts/\n        \u251c\u2500\u2500 PostList.js\n        \u251c\u2500\u2500 PostDetail.js\n        \u251c\u2500\u2500 postSlice.js          # Redux slice for posts state\n        \u2514\u2500\u2500 postAPI.js            # API calls related to posts\n</code></pre> <ol> <li> <p>Feature Folder: Each feature (e.g., <code>auth</code>, <code>dashboard</code>, <code>posts</code>) has its own folder. This keeps all related files together.</p> </li> <li> <p>Component Files: Each feature folder contains component files specific to that feature. For example:</p> <ul> <li><code>Login.js</code> and <code>Register.js</code> handle user authentication.</li> <li><code>Dashboard.js</code> manages the main dashboard view.</li> <li><code>PostList.js</code> and <code>PostDetail.js</code> are used to display posts.</li> </ul> </li> <li> <p>State Management: Each feature can have its own state management file (like <code>authSlice.js</code>, <code>dashboardSlice.js</code>, <code>postSlice.js</code>) if you\u2019re using Redux or similar libraries. This file typically includes:</p> <ul> <li>Actions: Functions that define how to update the state.</li> <li>Reducers: Functions that handle the state changes based on actions.</li> </ul> </li> <li> <p>API Handling: Each feature can also have its own API handling file (like <code>authAPI.js</code>, <code>dashboardAPI.js</code>, <code>postAPI.js</code>) to manage API calls specific to that feature. This keeps the API logic separated and organized.</p> </li> </ol> <p>Example of the <code>auth/</code> Feature</p> authSlice.jsauthAPI.jsLogin.js <pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { loginUser, registerUser } from \"./authAPI\";\n\nexport const login = createAsyncThunk(\"auth/login\", async (userData) =&gt; {\n    const response = await loginUser(userData);\n    return response.data;\n});\n\nexport const register = createAsyncThunk(\"auth/register\", async (userData) =&gt; {\n    const response = await registerUser(userData);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: \"auth\",\n    initialState: { user: null, status: \"idle\" },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.status = \"loading\";\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.user = action.payload;\n                state.status = \"succeeded\";\n            });\n    },\n});\n\nexport const { logout } = authSlice.actions;\nexport default authSlice.reducer;\n</code></pre> <pre><code>import axios from \"axios\";\n\nexport const loginUser = async (userData) =&gt; {\n    const response = await axios.post(\"/api/auth/login\", userData);\n    return response;\n};\n\nexport const registerUser = async (userData) =&gt; {\n    const response = await axios.post(\"/api/auth/register\", userData);\n    return response;\n};\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { login } from \"./authSlice\";\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const [email, setEmail] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n\n    const handleSubmit = (e) =&gt; {\n        e.preventDefault();\n        dispatch(login({ email, password }));\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"email\"\n                value={email}\n                onChange={(e) =&gt; setEmail(e.target.value)}\n                placeholder=\"Email\"\n            /&gt;\n            &lt;input\n                type=\"password\"\n                value={password}\n                onChange={(e) =&gt; setPassword(e.target.value)}\n                placeholder=\"Password\"\n            /&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\nexport default Login;\n</code></pre> Benefits of the <code>features/</code> Folder Structure <ul> <li>Modularity: Each feature is self-contained, making it easier to manage and update without affecting other parts of the application.</li> <li>Scalability: As the application grows, adding new features or modifying existing ones becomes straightforward.</li> <li>Readability: New developers can quickly understand the structure and locate related files.</li> </ul> <p>This organization helps maintain clarity and order, especially in larger applications where multiple features and components are in play!</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/","title":"Where to Define the Navigation Links in a React Application","text":"<p>In a React application that uses React Router, navigation links should typically be defined in a separate component that serves as your navigation bar. This approach enhances modularity and keeps your code organized</p> <p>Here\u2019s how you can effectively implement navigation links in your app.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#recommended-structure","title":"Recommended Structure","text":"<ol> <li>Create a Navbar Component: This component will contain your navigation links, making it reusable across different parts of your application.</li> <li>Place the Navbar in <code>App.js</code>: By including the Navbar in your main <code>App.js</code> component, it will be visible on all pages where you have defined your routes.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#example-implementation","title":"Example Implementation","text":"1. Create a Navbar Component2. Update Your <code>App.js</code>Benefits of This Approach <p>First, create a file called <code>Navbar.jsx</code> in your <code>components</code> directory.</p> <pre><code>// src/components/Navbar.jsx\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/2\"&gt;User 2&lt;/Link&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <p>Now, import and include the Navbar component in your App.js file:</p> <pre><code>// src/App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nimport NotFound from './components/NotFound';\nimport Navbar from './components/Navbar';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n            &lt;Navbar /&gt; {/* Include the Navbar here */}\n            &lt;header className=\"App-header\"&gt;\n                &lt;h1&gt;My React App&lt;/h1&gt;\n            &lt;/header&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <ol> <li>Modularity: By separating the Navbar into its own component, you create a modular design that is easier to maintain and update.</li> <li>Reusability: You can use the <code>Navbar</code> component across different parts of your application without repeating code.</li> <li>Clear Structure: Including the Navbar in <code>App.js</code> keeps your layout clear, showing that navigation is an integral part of the app structure.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#conclusion","title":"Conclusion","text":"<p>Defining your navigation links in a separate <code>Navbar</code> component and including it in <code>App.js</code> promotes a clean, modular approach. This not only enhances maintainability but also aligns with best practices in React development, making your application easier to navigate and manage as it grows.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#addtional","title":"Addtional","text":"<p>so we should put the nav link and routes in the same file</p> <p>Yes, it's generally a good practice to keep the navigation links and routes in the same file (specifically, in your main <code>App.js</code> file). Here\u2019s why this approach is beneficial:</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#benefits-of-combining-navigation-links-and-routes-in-appjs","title":"Benefits of Combining Navigation Links and Routes in <code>App.js</code>","text":"<ol> <li> <p>Centralized Structure: By defining both your navigation links and routes in <code>App.js</code>, you create a clear and centralized structure for your application. This makes it easier to see how different parts of your app are connected.</p> </li> <li> <p>Simplified Navigation: It allows you to quickly add or update routes and navigation links in one place. When you need to change a route, you can easily update the corresponding link in the navigation.</p> </li> <li> <p>Enhanced Readability: Keeping related components (like routes and navigation) together improves the readability of your code. Developers can quickly understand the flow of the application by looking at a single file.</p> </li> <li> <p>Modular Design: While the navigation links are part of the layout, they are logically connected to the routes they lead to. This modularity makes it easier to manage larger applications.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#example-structure","title":"Example Structure","text":"<p>Here\u2019s an example to illustrate this approach:</p> <pre><code>// src/App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Routes, Route, Link } from \"react-router-dom\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;div className=\"App\"&gt;\n        {/* Navigation Links */}\n        &lt;nav&gt;\n          &lt;ul&gt;\n            &lt;li&gt;\n              &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n              &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/li&gt;\n          &lt;/ul&gt;\n        &lt;/nav&gt;\n\n        {/* Routes */}\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n          &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#alternative-approach","title":"Alternative Approach","text":"<p>If your application grows larger, you might choose to separate the Navbar into its own component to keep things organized while still importing it in <code>App.js</code>:</p> <pre><code>// src/components/Navbar.jsx\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; (\n  &lt;nav&gt;\n    &lt;ul&gt;\n      &lt;li&gt;\n        &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/nav&gt;\n);\n\nexport default Navbar;\n</code></pre> <p>Then import and use the Navbar in <code>App.js</code>:</p> <pre><code>// src/App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;div className=\"App\"&gt;\n        &lt;Navbar /&gt; {/* Separate Navbar component */}\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n          &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#conclusion_1","title":"Conclusion","text":"<p>Combining navigation links and routes in the same file, or using a separate component for the navigation while keeping routes in <code>App.js</code>, provides a clean and organized structure. This approach enhances the maintainability and readability of your code as your application scales.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#additional-2","title":"Additional 2","text":"<p>Leveraging Component Reusability: Using Navbar in Multiple Parts of Your React Application</p> <p>Yes, you can absolutely use the <code>Navbar</code> component in any other component within your React application, not just in <code>App.js</code>. This flexibility allows you to structure your app in a way that fits your needs.</p> How to Use the Navbar Component in Other Components <ol> <li>Define the Navbar Component: First, ensure that your <code>Navbar</code> component is defined, as shown previously.</li> <li>Import and Use the Navbar: You can import and use the <code>Navbar</code> component in any other component, such as a <code>Home</code> or <code>About</code> page.</li> </ol> <p>Example Implementation</p> Navbar ComponentUsing ComponentApp.js <p><code>1. Navbar Component</code></p> <pre><code>// src/components/Navbar.jsx\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/2\"&gt;User 2&lt;/Link&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <p><code>2. Using Navbar in Other Components</code></p> <p>Suppose you want to use the <code>Navbar</code> in a <code>Home</code> component:</p> <pre><code>// src/components/Home.jsx\nimport React from 'react';\nimport Navbar from './Navbar'; // Importing the Navbar\n\nconst Home = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;Navbar /&gt; {/* Use the Navbar here */}\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n            &lt;p&gt;This is the home page content.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Home;\n</code></pre> <p><code>3. App.js</code></p> <p>You can also use the <code>Navbar</code> in <code>App.js</code> or anywhere else as needed:</p> <pre><code>// src/App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nimport NotFound from './components/NotFound';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> Key Points <ol> <li>Reusable Component: By defining <code>Navbar</code> separately, you make it reusable across multiple components, not just <code>App.js</code>.</li> <li>Component Flexibility: You can decide where to place the <code>Navbar</code> based on the layout you want. For instance, you might want it to be present on every page, or only on specific pages.</li> <li>Modular Design: This modular design keeps your application organized and helps maintain a clear separation of concerns.</li> </ol> <p>Conclusion</p> <p>You can certainly use the Navbar component in any other component, giving you flexibility in how you structure your application. This approach enhances the modularity and maintainability of your code, allowing you to scale your React application more easily.</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/","title":"React State Updates Explained","text":"<p>Certainly! Let\u2019s explore the concept of asynchronous state updates in React with a detailed example.</p> <p>React State Updates Explained: The Importance of Asynchronous Behavior</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#example-understanding-asynchronous-state-updates","title":"Example: Understanding Asynchronous State Updates","text":"<p>Suppose we have a simple counter component that increments the count when a button is clicked.</p> Initial Component Without Functional UpdatesWhat Happens Here? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount(count + 1); // Attempt to increment the count\n        setCount(count + 2); // Attempt to increment the count again\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>When you click the \"Increment\" button, the <code>handleIncrement</code> function is called.</li> <li>The first <code>setCount(count + 1)</code> is executed, but it doesn't update the state immediately.</li> <li>The second <code>setCount(count + 2)</code> is called right after, referencing the same initial <code>count</code> value.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, both updates reference the same value, and you may expect the count to be 3 (0 + 1 + 2). However, because the updates are batched, the final state remains 2 (0 + 2) instead of 3.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#fixing-it-with-functional-updates","title":"Fixing It with Functional Updates","text":"<p>To correctly manage the updates, we can use the functional update pattern:</p> ExampleWhat Happens Now? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount((prevCount) =&gt; prevCount + 1); // Correctly increments by 1\n        setCount((prevCount) =&gt; prevCount + 2); // Correctly increments by 2\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>The first <code>setCount</code> now uses the previous state <code>prevCount</code> to increment the count by 1.</li> <li>The second <code>setCount</code> also uses the latest <code>prevCount</code>, which is now updated.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, the first update correctly sets it to 1, and the second update then sets it to 3 (1 + 2). This yields the expected behavior.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#summary-of-asynchronous-updates","title":"Summary of Asynchronous Updates","text":"<ul> <li>Batched Updates: In the initial example, React batched the updates. The state didn\u2019t update immediately after each call, which led to unexpected results.</li> <li>Using Previous State: By using the functional update pattern, you ensure each update correctly references the most recent state value.</li> <li>Performance and Consistency: This pattern prevents potential issues and allows React to optimize rendering, providing a smoother user experience.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#conclusion","title":"Conclusion","text":"<p>Understanding how asynchronous state updates work in React helps developers avoid common pitfalls and write more reliable code. Using functional updates ensures that state changes are predictable and accurate, especially in scenarios with multiple rapid updates.</p>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/","title":"Transitioning from Switch to Routes","text":"<p>The differences between <code>Switch</code> and <code>Routes</code> in React Router are primarily about functionality, behavior, and syntax in React Router v6 compared to v5.</p> <p>Understanding React Router v6: Transitioning from Switch to Routes</p> <p>Here are the key distinctions:</p>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#1-component-replacement","title":"1. Component Replacement","text":"<ul> <li><code>Switch</code> (v5): The <code>Switch</code> component renders the first matching <code>Route</code> it finds among its children. It essentially works as a container for <code>Route</code> components.</li> <li><code>Routes</code> (v6): <code>Routes</code> also renders the first matching <code>Route</code>, but it introduces a more streamlined syntax and improved matching capabilities.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#2-route-matching","title":"2. Route Matching","text":"<ul> <li><code>Switch</code>: Uses a \"greedy\" matching algorithm, meaning it matches the first <code>Route</code> that fits, even if other more specific routes exist below it. This could lead to unexpected matches if not carefully ordered.</li> <li><code>Routes</code>: Uses a more predictable \"hierarchical\" matching algorithm. It matches routes in a more controlled manner, ensuring that it considers the most specific routes first.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#3-route-definition","title":"3. Route Definition","text":"<ul> <li><code>Switch</code> (v5):</li> </ul> <pre><code>&lt;Switch&gt;\n  &lt;Route path=\"/about\" component={About} /&gt;\n  &lt;Route path=\"/\" component={Home} /&gt;\n&lt;/Switch&gt;\n</code></pre> <ul> <li><code>Routes</code> (v6):</li> </ul> <pre><code>&lt;Routes&gt;\n  &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n  &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n&lt;/Routes&gt;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#4-element-prop","title":"4. Element Prop","text":"<ul> <li><code>Switch</code>: Uses the <code>component</code> prop to specify the component to render.</li> <li><code>Routes</code>: Uses the <code>element</code> prop, which requires the component to be passed as JSX. This change enhances the component rendering process, allowing for better handling of nested routes and more complex routing scenarios.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#5-nested-routes","title":"5. Nested Routes","text":"<ul> <li><code>Routes</code> (v6): Supports nested routes more intuitively and simplifies how nested routes are defined, making it easier to manage complex route structures.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/11/transitioning-from-switch-to-routes/#summary","title":"Summary","text":"<p>In summary, while both <code>Switch</code> and <code>Routes</code> serve to manage route rendering, <code>Routes</code> in v6 offers improved performance, a more intuitive API, and better handling of route matching and nesting. Transitioning to <code>Routes</code> helps create clearer and more maintainable routing structures in your application.</p>","tags":["react"]},{"location":"blog/2024/07/14/understanding-authentication-in-react-using-context-api/","title":"Understanding Authentication in React: Using Context API","text":"<p>In modern web applications, managing authentication is crucial for providing secure and personalized user experiences. React offers various techniques for state management, and one effective way to handle authentication is through the Context API.</p> <p>In this blog, we'll explore the process, techniques used, and why <code>useContext</code> is a preferred choice for authentication management.</p>","tags":["react"]},{"location":"blog/2024/07/14/understanding-authentication-in-react-using-context-api/#the-process","title":"The Process","text":"<ol> <li>Context Setup: We create an <code>AuthContext</code> using React's <code>createContext</code> to store authentication state and provide methods for logging in and out.</li> <li> <p>State Management: The context manages two key pieces of state:</p> <ul> <li><code>isAuthenticated</code>: A boolean indicating whether the user is logged in.</li> <li><code>token</code>: The JWT or any token used for API requests.</li> </ul> </li> <li> <p>Persisting Authentication State: To maintain the user's authentication status across page refreshes, we check for a stored token in local storage using the <code>useEffect</code> hook when the application first loads. If a token exists, we set the authentication state accordingly.</p> </li> <li>Routing and Navigation: Based on the authentication state, we conditionally render different routes and components. Authenticated users are redirected to protected routes, while unauthenticated users see the login page.</li> <li>Login Logic: When the user logs in, the application calls the login function provided by the context, which updates the state and stores the token in local storage.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/14/understanding-authentication-in-react-using-context-api/#why-use-usecontext","title":"Why Use <code>useContext</code>?","text":"<ul> <li> <p>Simplicity: The Context API allows for easy sharing of authentication state across the entire application without prop drilling. This means you don\u2019t have to pass props through multiple layers of components.</p> </li> <li> <p>Scalability: As applications grow, managing state in a centralized location becomes increasingly important. Context provides a clean solution for scaling state management.</p> </li> <li> <p>Improved Readability: Using <code>useContext</code> enhances code readability and maintainability. It clearly defines where your state comes from and how it is updated.</p> </li> <li> <p>No External Dependencies: Unlike state management libraries like Redux, the Context API is built into React, meaning there\u2019s no need for additional dependencies or boilerplate code.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/07/14/understanding-authentication-in-react-using-context-api/#do-we-need-to-check-local-storage","title":"Do We Need to Check Local Storage?","text":"<p>Yes, checking local storage for the token on the initial load is essential for a couple of reasons:</p> <ol> <li> <p>Persistence Across Refreshes: When a user logs in, their authentication status should persist even if they refresh the page. By checking local storage, we can restore the user's authenticated state seamlessly.</p> </li> <li> <p>User Experience: Without this check, users would have to log in again every time they refresh the page, leading to a frustrating experience.</p> </li> </ol> <p>Here\u2019s the crucial part of the code:</p> <pre><code>useEffect(() =&gt; {\n  const storedToken = localStorage.getItem(\"token\");\n  console.log(\"Stored Token:\", storedToken);\n  if (storedToken) {\n    setIsAuthenticated(true);\n    setToken(storedToken);\n  }\n}, []);\n</code></pre> <p>This snippet ensures that when the application loads, it retrieves the token from local storage. If the token is present, it updates the authentication state, allowing the user to remain logged in.</p>","tags":["react"]},{"location":"blog/2024/07/14/understanding-authentication-in-react-using-context-api/#conclusion","title":"Conclusion","text":"<p>Using the Context API for authentication in React applications provides a powerful, simple, and efficient way to manage user state. Coupled with local storage for persistence, this approach enhances user experience while maintaining a clean and scalable codebase. Whether you\u2019re building a small application or a large-scale web platform, implementing authentication via useContext is a technique worth considering.</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/","title":"When to Use <code>.jsx</code> vs <code>.js</code> in react","text":"<p>In React, the choice between using <code>.js</code> and <code>.jsx</code> file extensions is largely a matter of convention and team preferences.</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#overview","title":"Overview","text":"<p>Here's a breakdown of when to use each:</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#use-jsx-when","title":"Use <code>.jsx</code> When:","text":"<ol> <li> <p>JSX Syntax:</p> <p>The file contains JSX syntax. JSX is the XML-like syntax used in React to describe UI components. If a file includes JSX, it's common to use the <code>.jsx</code> extension to make that clear.</p> <pre><code>// ExampleComponent.jsx\nimport React from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n};\n\nexport default ExampleComponent;\n</code></pre> </li> <li> <p>Component Files:</p> <p>When defining React components that use JSX, many developers prefer <code>.jsx</code> for clarity.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#use-js-when","title":"Use <code>.js</code> When:","text":"<ol> <li> <p>JavaScript Logic:</p> <p>The file contains only standard JavaScript code without any JSX. This could include utility functions, configurations, or any JavaScript logic that doesn\u2019t interact with React\u2019s rendering process.</p> <pre><code>// utils.js\nexport const add = (a, b) =&gt; a + b;\n</code></pre> </li> <li> <p>Non-Component Files:</p> <p>For files that do not define React components (like context providers, hooks, or configurations), <code>.js</code> is often used.</p> </li> <li> <p>Conventional Use:</p> <p>In many projects, especially those created with Create React App, <code>.js</code> is the default extension. Using <code>.js</code> for all files (including those with JSX) is perfectly acceptable, as long as it\u2019s consistent.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>.jsx</code> for files that contain JSX, particularly for React components.</li> <li>Use <code>.js</code> for files that are pure JavaScript or do not use JSX.</li> </ul> <p>Ultimately, it\u2019s important to maintain consistency within your project or team. Choose a convention that works for everyone and stick with it!</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#naming-files-for-jsx-js","title":"Naming files for <code>.jsx</code> &amp; <code>.js</code>","text":"<p>Naming files in React, whether they use the <code>.jsx</code> or <code>.js</code> extension, follows some common conventions to enhance clarity, maintainability, and organization.</p> <p>Here\u2019s a breakdown of standard practices for naming files in both cases:</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#1-file-naming-conventions","title":"1. File Naming Conventions","text":"For <code>.jsx</code> FilesFor <code>.js</code> Files <ul> <li> <p>Component Names: Use PascalCase (also known as UpperCamelCase) for naming component files. This helps distinguish components from regular JavaScript files and indicates they are React components.</p> </li> <li> <p>Examples:</p> <pre><code>-   MyComponent.jsx\n-   UserProfile.jsx\n-   HeaderNav.jsx\n</code></pre> </li> <li> <p>Folder Structure: For components with related files (like styles or tests), consider creating a folder for each component.</p> </li> <li> <p>Example:</p> <pre><code>/components\n    /MyComponent\n        MyComponent.jsx\n        MyComponent.css\n        MyComponent.test.jsx\n</code></pre> </li> </ul> <ul> <li> <p>Utility Functions and Hooks: Use camelCase for naming utility files or custom hooks, which typically do not represent components.</p> </li> <li> <p>Examples:</p> <pre><code>-   formatDate.js\n-   useFetchData.js\n-   mathUtils.js\n</code></pre> </li> <li> <p>Configuration and Context Files: Use kebab-case or camelCase based on personal/team preference. These files usually represent non-component logic.</p> </li> <li> <p>Examples:</p> <pre><code>-   authContext.js\n-   apiConfig.js\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#2-reasons-for-these-conventions","title":"2. Reasons for These Conventions","text":"<ul> <li> <p>Clarity: PascalCase for components helps immediately identify files that export React components, making it easier for developers to navigate the codebase.</p> </li> <li> <p>Organization: Grouping related files in folders (especially for components) keeps the structure clean and manageable, facilitating easier development and testing.</p> </li> <li> <p>Consistency: Following a standardized naming convention across the project makes the codebase more predictable and easier to read. New developers can quickly understand the structure.</p> </li> <li> <p>Avoiding Confusion: By clearly distinguishing between components and utility/helper functions, developers can avoid mistakes, like trying to render a utility function as a component.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#3-summary","title":"3. Summary","text":"<ul> <li>Use PascalCase for <code>.jsx</code> component files (e.g., <code>MyComponent.jsx</code>).</li> <li>Use camelCase for <code>.js</code> utility and hook files (e.g., <code>useFetchData.js</code>).</li> <li>Organize related files within folders to enhance clarity and maintainability.</li> </ul> <p>By adhering to these conventions, you create a more organized, understandable, and maintainable codebase, which is especially beneficial in larger projects.</p>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/","title":"Deciding Where to Define Your Variables in React","text":"<p>Placing <code>const { Header } = Layout;</code> outside the component is generally considered better practice.</p> <p>Code Clarity and Performance: Deciding Where to Define Your Variables in React</p>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#overview","title":"Overview","text":"<p>Here\u2019s why:</p>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#reasons-for-placing-outside","title":"Reasons for Placing Outside:","text":"<ol> <li> <p>Performance: When you destructure components outside the functional component, it prevents unnecessary re-declaration on every render. This is more efficient, especially if the component gets re-rendered frequently.</p> </li> <li> <p>Clarity and Readability: Keeping imports and destructuring at the top of your file can make it easier to read and understand the code. It separates the definition of components from their usage, which can help clarify the structure of your component.</p> </li> <li> <p>Consistency: It follows a common pattern seen in many React projects, making the codebase easier for other developers to read and understand.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#standard-practice","title":"Standard Practice","text":"<p>The standard practice in React (and JavaScript in general) is to keep declarations that don\u2019t depend on component props or state outside the component function. For example, you would typically see:</p> <pre><code>import { Layout } from \"antd\";\n\nconst { Header } = Layout;\n\nconst Navbar = () =&gt; {\n  // Component logic and JSX here\n};\n\nexport default Navbar;\n</code></pre> <p>This way, <code>Header</code> is defined once and reused across renders, which is cleaner and slightly more performant.</p>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#conclusion","title":"Conclusion","text":"<p>While it's not wrong to place destructuring inside the component, doing so can lead to minor inefficiencies and decreased readability. Thus, for most cases, especially when dealing with components or variables that don't change, it\u2019s better to keep them outside the functional component.</p>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#additional","title":"Additional","text":"","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#when-to-define-inside-the-component","title":"When to Define Inside the Component:","text":"<p>You might want to define variables or destructure properties inside a component in the following situations:</p> <ol> <li> <p>Dependent on Props or State:</p> <p>If the value you're destructuring depends on props or state, it must be defined inside the component. For example:</p> <pre><code>const MyComponent = ({ user }) =&gt; {\n  const { name, age } = user; // Must be inside because it depends on the user prop\n  return (\n    &lt;div&gt;\n      {name} is {age} years old.\n    &lt;/div&gt;\n  );\n};\n</code></pre> </li> <li> <p>Scoped Variables:</p> <p>If you have variables that are only relevant to the logic within that component and don\u2019t need to be accessed outside, defining them inside keeps your code clean and encapsulated.</p> </li> <li> <p>Dynamic Imports:</p> <p>In cases where you're dynamically importing components or libraries based on certain conditions, those imports will need to be inside the component.</p> </li> <li> <p>Conditional Logic:</p> <p>If the destructured values change based on some conditions or computations, they should be defined inside the component to maintain the appropriate context.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/10/deciding-where-to-define-your-variables-in-react/#conclusion_1","title":"Conclusion","text":"<p>While it\u2019s generally better to define stable components outside of functional components for performance and clarity, there are specific situations where defining variables inside is necessary or makes more sense. Balancing performance, readability, and context is key to structuring your React components effectively.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/","title":"Where to Place Your Router Setup","text":"<p>When building a React application, you may wonder where to place your routing logic using React Router. Should it go in <code>index.js</code> or <code>App.js</code>? Understanding the best practices in structuring your application can help ensure scalability and maintainability.</p> <p>Integrating React Router: Where to Place Your Router Setup</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#standard-practice-place-the-router-in-appjs","title":"Standard Practice: Place the Router in <code>App.js</code>","text":"Why Use <code>App.js</code> for Routing? <ol> <li> <p>Separation of Concerns: By placing the router in <code>App.js</code>, you keep your routing logic separate from your application entry point. This separation enhances readability and helps manage the complexity of your application as it grows.</p> </li> <li> <p>Component Structure: <code>App.js</code> is designed to be the main component that renders your application\u2019s structure. Adding the router here allows you to encapsulate all your routes and their components in one place. This makes it easier to visualize how different parts of your app interact.</p> </li> <li> <p>Flexibility for Future Enhancements: If you decide to add more complex routing features (like nested routes or context providers), having the router in <code>App.js</code> allows you to manage those changes without cluttering <code>index.js</code>.</p> </li> <li> <p>Consistency with React's Component-Based Architecture: React encourages a component-based approach. By keeping the router in <code>App.js</code>, you align with this philosophy, making your app easier to understand for other developers.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#example-implementation","title":"Example Implementation","text":"<p>Here\u2019s how you can structure your application with React Router in <code>App.js</code>:</p> index.jsApp.js <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;div className=\"App\"&gt;\n                &lt;header className=\"App-header\"&gt;\n                    &lt;h1&gt;My React App&lt;/h1&gt;\n                &lt;/header&gt;\n                &lt;Routes&gt;\n                    &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                    &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                    &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n                &lt;/Routes&gt;\n            &lt;/div&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#conclusion","title":"Conclusion","text":"<p>By placing the router in <code>App.js</code>, you maintain a clean and organized codebase. This approach not only improves readability but also sets a solid foundation for future enhancements. Following standard practices like this will help you and your team work more efficiently, leading to a more maintainable and scalable React application.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/","title":"Why Props are Objects in React","text":"<p>In React, props (short for \"properties\") are a fundamental concept that enables components to communicate and share data. One of the key reasons props are implemented as objects is to streamline data handling and enhance component reusability. </p> <p>Here\u2019s a closer look at why this design choice is beneficial.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#1-simplicity-of-data-transfer","title":"1. Simplicity of Data Transfer","text":"<p>By using an object to bundle props, React simplifies the process of passing multiple values to a component. Instead of needing to pass individual parameters, developers can group related data together in a single object. For example:</p> <pre><code>&lt;MyComponent name=\"Alice\" age={25} /&gt;\n</code></pre> <p>This translates into a single props object:</p> <pre><code>{\n  name: \"Alice\",\n  age: 25\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#2-flexibility-in-data-types","title":"2. Flexibility in Data Types","text":"<p>Props as objects allow for various data types to be passed seamlessly. A single props object can contain strings, numbers, arrays, functions, or even other objects. This flexibility makes it easy to manage complex data structures without changing the fundamental way props are passed:</p> <pre><code>&lt;MyComponent \n  user={{ id: 1, name: \"Alice\" }} \n  items={[1, 2, 3]} \n  onClick={() =&gt; alert(\"Clicked!\")} \n/&gt;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#3-destructuring-for-cleaner-code","title":"3. Destructuring for Cleaner Code","text":"<p>Using an object allows developers to take advantage of JavaScript destructuring, resulting in cleaner and more readable code. Instead of accessing props with <code>props.name</code>, you can destructure directly in the function signature:</p> <pre><code>function MyComponent({ name, age }) {\n  return &lt;div&gt;{name} is {age} years old.&lt;/div&gt;;\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#4-easier-component-reusability","title":"4. Easier Component Reusability","text":"<p>Since props are objects, you can easily create reusable components by passing different props without altering the component's core functionality. This leads to a more modular design, making your codebase easier to maintain and extend.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#conclusion","title":"Conclusion","text":"<p>Props being objects in React is a deliberate design choice that enhances simplicity, flexibility, and reusability. By allowing multiple data types to be bundled into a single structure, React makes it easier for developers to create dynamic, interactive user interfaces while keeping their code organized and manageable. Understanding this foundational concept is crucial for building efficient React applications.</p>","tags":["react"]},{"location":"nepali/intro/","title":"Intro","text":""},{"location":"nepali/intro/#in-nepali","title":"In Nepali","text":"<p>JavaScript \u092e\u093e \"parameter\" \u0930 \"argument\" \u092c\u0940\u091a\u0915\u094b \u092d\u093f\u0928\u094d\u0928\u0924\u093e \u0915\u0947 \u0939\u094b \u092d\u0928\u0947:</p> <ul> <li>Parameter: \u091c\u092c \u0924\u092a\u093e\u0908\u0901\u0932\u0947 \u0915\u0941\u0928\u0948 \u092b\u0919\u094d\u0915\u094d\u0936\u0928 \u092c\u0928\u093e\u0909\u0928\u0941\u0939\u0941\u0928\u094d\u091b, \u0924\u094d\u092f\u0939\u093e\u0901\u0915\u094b \u092d\u093f\u0924\u094d\u0930\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u0932\u093e\u0908 \"parameter\" \u092d\u0928\u093f\u0928\u094d\u091b\u0964 \u092f\u0940 \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u0932\u0947 \u092b\u0919\u094d\u0915\u094d\u0936\u0928\u0932\u0947 \u0932\u093f\u0928\u0947 \u092e\u093e\u0928\u0939\u0930\u0942\u0932\u093e\u0908 \u091c\u0928\u093e\u0909\u0901\u091b\u0928\u094d\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f:</li> </ul> <pre><code>function greet(name) {\n  console.log(\"Hello, \" + name);\n}\n</code></pre> <p>\u092f\u0939\u093e\u0901 <code>name</code> \u090f\u0915 parameter \u0939\u094b\u0964</p> <ul> <li>Argument: \u091c\u092c \u0924\u092a\u093e\u0908\u0901\u0932\u0947 \u092b\u0919\u094d\u0915\u094d\u0936\u0928\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u0928\u0941\u0939\u0941\u0928\u094d\u091b \u0930 \u092f\u0938\u092e\u093e \u0915\u0941\u0928\u0948 \u092e\u093e\u0928\u0939\u0930\u0942 \u092a\u0920\u093e\u0909\u0928\u0941\u0939\u0941\u0928\u094d\u091b, \u0924\u093f\u0928\u0932\u093e\u0908 \"argument\" \u092d\u0928\u093f\u0928\u094d\u091b\u0964 \u091c\u0938\u094d\u0924\u0948:</li> </ul> <pre><code>greet(\"Sita\");\n</code></pre> <p>\u092f\u0939\u093e\u0901 <code>\"Sita\"</code> \u090f\u0915 argument \u0939\u094b \u091c\u0941\u0928 <code>greet</code> \u092b\u0919\u094d\u0915\u094d\u0936\u0928\u0932\u093e\u0908 \u092a\u0920\u093e\u0907\u090f\u0915\u094b \u091b\u0964</p> <p>\u0938\u0902\u0915\u094d\u0937\u0947\u092a\u092e\u093e, parameter \u092d\u0928\u0947\u0915\u094b \u092b\u0919\u094d\u0915\u094d\u0936\u0928\u0915\u094b \u092a\u0930\u093f\u092d\u093e\u0937\u093e\u092e\u093e \u0930\u0939\u0947\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942 \u0939\u0941\u0928\u094d, \u0930 argument \u092d\u0928\u0947\u0915\u094b \u092b\u0919\u094d\u0915\u094d\u0936\u0928\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u0926\u093e \u092a\u094d\u0930\u0926\u093e\u0928 \u0917\u0930\u093f\u090f\u0915\u093e \u092e\u093e\u0928\u0939\u0930\u0942 \u0939\u0941\u0928\u094d\u0964</p>"},{"location":"nepali/designpattern/intro/","title":"Intro","text":""},{"location":"nepali/designpattern/intro/#what-is","title":"what is \u0935\u0938\u094d\u0924\u0941\u0939","text":"<p>\"\u0935\u0938\u094d\u0924\u0941\" (Object) \u092d\u0928\u0947\u0915\u094b \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919\u092e\u093e \u0921\u0947\u091f\u093e \u0930 \u0915\u093e\u0930\u094d\u092f\u0915\u094d\u0937\u092e\u0924\u093e\u0915\u094b \u0938\u0902\u092f\u094b\u091c\u0928 \u0939\u094b\u0964 \u092f\u094b \u090f\u0915 \u0935\u093f\u0936\u0947\u0937\u0924\u093e (Properties) \u0930 \u0935\u093f\u0927\u093f\u0939\u0930\u0942 (Methods) \u0938\u092e\u093e\u0935\u0947\u0936 \u0917\u0930\u094d\u0926\u091b\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f, \u092f\u0926\u093f \u0924\u092a\u093e\u0908\u0902\u0932\u0947 \"\u0917\u093e\u0921\u0940\" \u092d\u0928\u094d\u0928\u0947 \u0935\u0938\u094d\u0924\u0941 \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u0917\u0930\u094d\u0928\u0941\u092d\u092f\u094b \u092d\u0928\u0947, \u092f\u0938\u092e\u093e \u0935\u093f\u0936\u0947\u0937\u0924\u093e\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 \u0930\u0902\u0917, \u092e\u094b\u0921\u0947\u0932, \u0930 \u0917\u0924\u093f\u0915\u094b \u091c\u093e\u0928\u0915\u093e\u0930\u0940 \u0939\u0941\u0928\u0947\u091b, \u0930 \u0935\u093f\u0927\u093f\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 \u091a\u0932\u093e\u0909\u0928\u0947, \u0930\u094b\u0915\u093f\u0928\u0947, \u0930 \u092e\u0941\u0921\u094d\u0928\u0947 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u092a\u0928\u093f \u0939\u0941\u0928\u0947\u091b\u0964</p> <p>JavaScript \u091c\u0938\u094d\u0924\u093e \u0935\u0938\u094d\u0924\u0941-\u0909\u0928\u094d\u092e\u0941\u0916 \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919 \u092d\u093e\u0937\u093e\u092e\u093e \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942 \u0921\u0947\u091f\u093e \u0930 \u0915\u093e\u0930\u094d\u092f\u0915\u094d\u0937\u092e\u0924\u093e \u0938\u0902\u0917\u0920\u093f\u0924 \u0917\u0930\u094d\u0928\u0915\u093e \u0932\u093e\u0917\u093f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0938\u094d\u092a\u0937\u094d\u091f \u0930 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093e\u092a\u0928 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"nepali/designpattern/intro/#_1","title":"\u0905\u0935\u0932\u094b\u0915\u0928","text":"<p>\u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928 \u092d\u0928\u0947\u0915\u094b \u0915\u0941\u0928\u0948 \u0938\u092e\u0938\u094d\u092f\u093e \u0938\u092e\u093e\u0927\u093e\u0928 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u0938\u094d\u0925\u093e\u092a\u093f\u0924 \u0930 \u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u0947 \u0924\u0930\u093f\u0915\u093e \u0939\u094b\u0964 \u092f\u094b \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919 \u0930 \u0938\u092b\u094d\u091f\u0935\u0947\u092f\u0930 \u0935\u093f\u0915\u093e\u0938\u092e\u093e \u0935\u093f\u0936\u0947\u0937 \u0917\u0930\u0940 \u0909\u092a\u092f\u094b\u0917\u0940 \u0939\u0941\u0928\u094d\u091b\u0964 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u091b\u0928\u094d, \u091c\u0938\u092e\u093e \u0928\u093f\u0930\u094d\u092e\u093e\u0923\u093e\u0924\u094d\u092e\u0915, \u0938\u0902\u0930\u091a\u0928\u093e\u0924\u094d\u092e\u0915, \u0930 \u0935\u094d\u092f\u0935\u0939\u093e\u0930\u093e\u0924\u094d\u092e\u0915 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928 \u0938\u092e\u093e\u0935\u0947\u0936 \u091b\u0928\u094d\u0964 \u092f\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093f\u0924, \u092e\u0930\u094d\u092e\u0924\u092f\u094b\u0917\u094d\u092f, \u0930 \u092a\u0941\u0928: \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u092f\u094b\u0917\u094d\u092f \u092c\u0928\u093e\u0909\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0928\u094d\u0964</p>"},{"location":"nepali/designpattern/intro/#javascript","title":"JavaScript \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u092e\u093e \u092e\u0939\u093e\u0930\u0924 \u0939\u093e\u0938\u093f\u0932 \u0917\u0930\u094d\u0928\u0915\u093e \u0932\u093e\u0917\u093f \u0924\u0932\u0915\u093e \u0915\u0947\u0939\u093f \u0909\u092a\u093e\u092f\u0939\u0930\u0942 \u091b\u0928\u094d:","text":"<ol> <li> <p>\u092e\u0942\u0932\u092d\u0942\u0924 \u091c\u094d\u091e\u093e\u0928 \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: JavaScript \u0915\u093e \u0906\u0927\u093e\u0930\u092d\u0942\u0924 \u0924\u0924\u094d\u0935\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 \u092d\u0947\u0930\u093f\u090f\u092c\u0932, \u092b\u0919\u094d\u0936\u0928, \u0930 \u0913\u092c\u094d\u091c\u0947\u0915\u094d\u091f\u094d\u0938\u0915\u094b \u0930\u093e\u092e\u094d\u0930\u094b \u0938\u092e\u091d \u0939\u0941\u0928\u0941 \u0906\u0935\u0936\u094d\u092f\u0915 \u091b\u0964</p> </li> <li> <p>\u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0915\u093e \u092a\u094d\u0930\u0915\u093e\u0930\u0939\u0930\u0942 \u0905\u0927\u094d\u092f\u092f\u0928 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: \u0928\u093f\u0930\u094d\u092e\u093e\u0923\u093e\u0924\u094d\u092e\u0915, \u0938\u0902\u0930\u091a\u0928\u093e\u0924\u094d\u092e\u0915, \u0930 \u0935\u094d\u092f\u0935\u0939\u093e\u0930\u093e\u0924\u094d\u092e\u0915 \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0915\u093e \u092c\u093e\u0930\u0947\u092e\u093e \u0905\u0927\u094d\u092f\u092f\u0928 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u0939\u0930\u0947\u0915 \u092a\u094d\u0930\u0915\u093e\u0930\u0915\u093e \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0915\u094b \u0935\u093f\u0936\u0947\u0937\u0924\u093e \u0930 \u092a\u094d\u0930\u092f\u094b\u0917 \u0925\u093e\u0939\u093e \u092a\u093e\u0909\u0928\u0941\u0939\u094b\u0938\u094d\u0964</p> </li> <li> <p>\u0909\u0926\u093e\u0939\u0930\u0923\u0939\u0930\u0942 \u0905\u0927\u094d\u092f\u092f\u0928 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0915\u094b \u0915\u094b\u0921 \u0909\u0926\u093e\u0939\u0930\u0923\u0939\u0930\u0942 \u0939\u0947\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964 GitHub \u0930 \u0905\u0928\u094d\u092f \u0905\u0928\u0932\u093e\u0907\u0928 \u0938\u094d\u0930\u094b\u0924\u0939\u0930\u0942\u092e\u093e \u091c\u093e\u0901\u0926\u093e \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u092a\u0930\u093f\u092f\u094b\u091c\u0928\u093e\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u092d\u090f\u0915\u093e \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u092b\u0947\u0932\u093e \u092a\u093e\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0938\u093f\u0915\u094d\u0928\u0941\u0939\u094b\u0938\u094d: \u0938\u093f\u0915\u0947\u0915\u093e \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u093e\u0928\u093e \u092a\u094d\u0930\u094b\u091c\u0947\u0915\u094d\u091f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0905\u092d\u094d\u092f\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u0935\u093e\u0938\u094d\u0924\u0935\u093f\u0915 \u0938\u092e\u0938\u094d\u092f\u093e\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u092e\u093e\u0927\u093e\u0928 \u0917\u0930\u094d\u0928\u0947 \u092a\u094d\u0930\u092f\u093e\u0938 \u0917\u0930\u094d\u0926\u093e \u0924\u092a\u093e\u0908\u0915\u094b \u091c\u094d\u091e\u093e\u0928 \u0917\u0939\u093f\u0930\u094b \u0939\u0941\u0928\u0947\u091b\u0964</p> </li> <li> <p>\u092a\u0941\u0938\u094d\u0924\u0915 \u0930 \u0905\u0928\u0932\u093e\u0907\u0928 \u0915\u094b\u0930\u094d\u0938\u0939\u0930\u0942: JavaScript \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0915\u094b \u092c\u093e\u0930\u0947\u092e\u093e \u0915\u093f\u0924\u093e\u092c\u0939\u0930\u0942 \u092a\u0922\u094d\u0928\u0941\u0939\u094b\u0938\u094d \u0930 \u0905\u0928\u0932\u093e\u0907\u0928 \u0915\u094b\u0930\u094d\u0938\u0939\u0930\u0942\u092e\u093e \u092d\u093e\u0917 \u0932\u093f\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u092f\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0932\u093e\u0908 \u0917\u0939\u093f\u0930\u093e\u0907\u092e\u093e \u091c\u093e\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u0928\u0947\u091b\u0964</p> </li> <li> <p>\u0938\u092e\u0941\u0926\u093e\u092f\u092e\u093e \u0938\u0902\u0932\u0917\u094d\u0928 \u0939\u0941\u0928\u0941\u0939\u094b\u0938\u094d: JavaScript \u0938\u092e\u0941\u0926\u093e\u092f\u092e\u093e \u0938\u093e\u092e\u0947\u0932 \u0939\u0941\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u092b\u094b\u0930\u092e\u0939\u0930\u0942, \u0938\u092e\u0942\u0939\u0939\u0930\u0942, \u0930 \u0938\u093e\u092e\u093e\u091c\u093f\u0915 \u092e\u093f\u0921\u093f\u092f\u093e \u091a\u094d\u092f\u093e\u0928\u0932\u0939\u0930\u0942\u092e\u093e \u0938\u0915\u094d\u0930\u093f\u092f \u0930\u0939\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u092f\u0939\u093e\u0901\u0915\u093e \u0905\u0928\u0941\u092d\u0935 \u0930 \u091c\u094d\u091e\u093e\u0928\u0938\u0901\u0917 \u0938\u093e\u091d\u093e \u0917\u0930\u094d\u0928\u093e\u0932\u0947 \u0924\u092a\u093e\u0908\u0932\u093e\u0908 \u0927\u0947\u0930\u0948 \u0915\u0941\u0930\u093e \u0938\u093f\u0915\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u0928\u0947\u091b\u0964</p> </li> <li> <p>\u0915\u0938\u0930\u0940 \u0932\u093e\u0917\u0942 \u0917\u0930\u094d\u0928\u0947 \u0905\u092d\u094d\u092f\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: \u0915\u0941\u0928\u0948 \u092a\u094d\u0930\u094b\u091c\u0947\u0915\u094d\u091f\u092e\u093e \u0915\u093e\u092e \u0917\u0930\u094d\u0926\u093e \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u0932\u093e\u0917\u0942 \u0917\u0930\u094d\u0928\u0947 \u092a\u094d\u0930\u092f\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f, \u092f\u0926\u093f \u0924\u092a\u093e\u0908\u0901 \u090f\u0909\u091f\u093e \u0938\u093f\u0902\u0917\u0932 \u092a\u0947\u091c \u090f\u092a\u094d\u0932\u093f\u0915\u0947\u0938\u0928 \u092c\u0928\u093e\u0907\u0930\u0939\u0928\u0941 \u092d\u090f\u0915\u094b \u091b \u092d\u0928\u0947, \u092e\u094b\u0921\u094d\u092f\u0941\u0932\u0930 \u0930\u093e\u0908\u091f\u093f\u0919 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928 \u0932\u093e\u0917\u0942 \u0917\u0930\u094d\u0928 \u092a\u094d\u0930\u092f\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964</p> </li> <li> <p>\u092a\u0941\u0928\u0930\u093e\u0935\u0932\u094b\u0915\u0928 \u0930 \u0938\u0941\u0927\u093e\u0930 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: \u0924\u092a\u093e\u0908\u0901\u0915\u094b \u0915\u094b\u0921\u0932\u093e\u0908 \u092c\u093e\u0930\u092e\u094d\u092c\u093e\u0930 \u092a\u0941\u0928\u0930\u093e\u0935\u0932\u094b\u0915\u0928 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d \u0930 \u0928\u092f\u093e\u0901 \u091c\u094d\u091e\u093e\u0928\u0915\u094b \u0906\u0927\u093e\u0930\u092e\u093e \u0938\u0941\u0927\u093e\u0930 \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d\u0964</p> </li> </ol> <p>\u092f\u0940 \u0909\u092a\u093e\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0927\u094d\u092f\u093e\u0928\u092e\u093e \u0930\u093e\u0916\u0947\u0930 \u0924\u092a\u093e\u0908\u0932\u0947 JavaScript \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u092e\u093e \u092e\u0939\u093e\u0930\u0924 \u0939\u093e\u0938\u093f\u0932 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u0928\u0941\u0939\u0941\u0928\u094d\u091b\u0964 \u0927\u0948\u0930\u094d\u092f \u0930 \u0928\u093f\u0930\u0928\u094d\u0924\u0930\u0924\u093e\u0915\u093e \u0938\u093e\u0925 \u0905\u092d\u094d\u092f\u093e\u0938 \u0917\u0930\u094d\u0926\u0948 \u091c\u093e\u0928\u0941\u0939\u094b\u0938\u094d!</p>"},{"location":"nepali/designpattern/intro/#_2","title":"\u0905\u0935\u0932\u094b\u0915\u0928","text":"<p>\u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u0938\u092b\u094d\u091f\u0935\u0947\u092f\u0930 \u0935\u093f\u0915\u093e\u0938\u092e\u093e \u0938\u092e\u0938\u094d\u092f\u093e \u0938\u092e\u093e\u0927\u093e\u0928 \u0917\u0930\u094d\u0928\u0947 \u0938\u093f\u0926\u094d\u0927\u093e\u0928\u094d\u0924\u0939\u0930\u0942 \u0939\u0941\u0928\u094d\u0964 \u092f\u0939\u093e\u0901\u0915\u093e \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u092a\u094d\u0930\u0915\u093e\u0930\u0915\u093e \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0915\u094b \u0925\u094d\u092f\u094b\u0930\u0940, \u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e, \u0930 \u092a\u094d\u0930\u092f\u094b\u0917\u0915\u094b \u0938\u0928\u094d\u0926\u0930\u094d\u092d\u092e\u093e \u091a\u0930\u094d\u091a\u093e \u0917\u0930\u094c\u0902:</p>"},{"location":"nepali/designpattern/intro/#creational-patterns","title":"\u0967. \u0928\u093f\u0930\u094d\u092e\u093e\u0923\u093e\u0924\u094d\u092e\u0915 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 (Creational Patterns)","text":"<p>\u0925\u094d\u092f\u094b\u0930\u0940: \u092f\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0915\u094b \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u092a\u094d\u0930\u0915\u094d\u0930\u093f\u092f\u093e\u092e\u093e \u0927\u094d\u092f\u093e\u0928 \u0915\u0947\u0928\u094d\u0926\u094d\u0930\u093f\u0924 \u0917\u0930\u094d\u091b\u0928\u094d\u0964 \u092f\u0938\u0932\u0947 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0915\u094b \u0928\u093f\u0930\u094d\u092e\u093e\u0923\u0932\u093e\u0908 \u0938\u0930\u0932 \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p> <p>\u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e: \u091c\u092c \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0915\u094b \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u091c\u091f\u093f\u0932 \u0935\u093e \u0935\u093f\u0936\u0947\u0937 \u0905\u0935\u0938\u094d\u0925\u093e\u0939\u0930\u0942\u092e\u093e \u0928\u093f\u0930\u094d\u092d\u0930 \u0917\u0930\u094d\u0926\u091b\u0964</p> <p>\u0915\u0938\u0930\u0940 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0947:</p> <ul> <li>\u0938\u093f\u0902\u0917\u0932\u091f\u0928: \u091c\u092c \u0924\u092a\u093e\u0908\u0902\u0932\u093e\u0908 \u090f\u0909\u091f\u093e \u092e\u093e\u0924\u094d\u0930 \u0935\u0938\u094d\u0924\u0941 \u091a\u093e\u0939\u093f\u0928\u094d\u091b\u0964</li> <li>\u092b\u094d\u092f\u093e\u0915\u094d\u091f\u0930\u0940 \u092e\u0947\u0925\u0921: \u091c\u092c \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0932\u093e\u0908 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0924\u0930\u093f\u0915\u093e\u092c\u093e\u091f \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u0917\u0930\u094d\u0928 \u0906\u0935\u0936\u094d\u092f\u0915 \u091b\u0964</li> </ul>"},{"location":"nepali/designpattern/intro/#structural-patterns","title":"\u0968. \u0938\u0902\u0930\u091a\u0928\u093e\u0924\u094d\u092e\u0915 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 (Structural Patterns)","text":"<p>\u0925\u094d\u092f\u094b\u0930\u0940: \u092f\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0932\u0947 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0915\u094b \u0938\u0902\u0930\u091a\u0928\u093e \u0930 \u0938\u0902\u0917\u0920\u0928\u0932\u093e\u0908 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093f\u0924 \u0917\u0930\u094d\u091b\u0928\u094d\u0964 \u092f\u0938\u0932\u0947 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0932\u093e\u0908 \u090f\u0915\u0938\u093e\u0925 \u092e\u093f\u0932\u093e\u090f\u0930 \u0920\u0942\u0932\u094b \u0938\u0902\u0930\u091a\u0928\u093e \u092c\u0928\u093e\u0909\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964</p> <p>\u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e: \u091c\u092c \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942 \u092c\u0940\u091a\u0915\u094b \u0938\u092e\u094d\u092c\u0928\u094d\u0927\u0932\u093e\u0908 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093f\u0924 \u0917\u0930\u094d\u0928\u0941\u092a\u0930\u094d\u0928\u0947 \u0939\u0941\u0928\u094d\u091b\u0964</p> <p>\u0915\u0938\u0930\u0940 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0947:</p> <ul> <li>\u0905\u0921\u093e\u092a\u094d\u091f\u0930: \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0907\u0928\u094d\u091f\u0930\u092b\u0947\u0938\u0939\u0930\u0942\u0932\u093e\u0908 \u090f\u0915\u0938\u093e\u0925 \u0915\u093e\u092e \u0917\u0930\u094d\u0928 \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u0921\u0947\u0915\u094b\u0930\u0947\u091f\u0930: \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u092e\u093e \u0928\u092f\u093e\u0901 \u0915\u093e\u0930\u094d\u092f\u0915\u094d\u0937\u092e\u0924\u093e \u0925\u092a\u094d\u091b \u092c\u093f\u0928\u093e \u0924\u093f\u0928\u0940\u0939\u0930\u0942\u0915\u094b \u0938\u0902\u0930\u091a\u0928\u093e \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0928\u0917\u0930\u0940\u0964</li> </ul>"},{"location":"nepali/designpattern/intro/#behavioral-patterns","title":"\u0969. \u0935\u094d\u092f\u0935\u0939\u093e\u0930\u093e\u0924\u094d\u092e\u0915 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 (Behavioral Patterns)","text":"<p>\u0925\u094d\u092f\u094b\u0930\u0940: \u092f\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0932\u0947 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942 \u092c\u0940\u091a\u0915\u094b \u0905\u0928\u094d\u0924\u0930\u0915\u094d\u0930\u093f\u092f\u093e \u0930 \u091c\u093f\u092e\u094d\u092e\u0947\u0935\u093e\u0930\u0940\u0915\u094b \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093e\u092a\u0928 \u0917\u0930\u094d\u091b\u0928\u094d\u0964</p> <p>\u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e: \u091c\u092c \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u092c\u0940\u091a\u0915\u094b \u0935\u094d\u092f\u0935\u0939\u093e\u0930 \u0930 \u0938\u0902\u091a\u093e\u0930\u0932\u093e\u0908 \u0938\u092e\u094d\u092f\u094b\u091c\u093f\u0924 \u0917\u0930\u094d\u0928 \u0906\u0935\u0936\u094d\u092f\u0915 \u091b\u0964</p> <p>\u0915\u0938\u0930\u0940 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0947:</p> <ul> <li>\u0905\u0935\u094d\u091c\u0930\u094d\u092d\u0930: \u090f\u0909\u091f\u093e \u0935\u0938\u094d\u0924\u0941\u092e\u093e \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0939\u0941\u0901\u0926\u093e \u0905\u0928\u094d\u092f \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u0942\u091a\u093f\u0924 \u0917\u0930\u094d\u091b\u0964</li> <li>\u0915\u092e\u093e\u0923\u094d\u0921: \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0935\u0938\u094d\u0924\u0941\u0939\u0930\u0942\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u094d\u0930\u0935\u093f\u0937\u094d\u091f \u0917\u0930\u094d\u091b \u091c\u0938\u0932\u0947 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0915\u094b \u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u094b\u0917\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> </ul>"},{"location":"nepali/designpattern/intro/#_3","title":"\u091c\u092c \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0947?","text":"<ul> <li>\u0938\u092e\u0938\u094d\u092f\u093e\u0915\u094b \u091c\u091f\u093f\u0932\u0924\u093e: \u092f\u0926\u093f \u0924\u092a\u093e\u0908\u0902\u0915\u094b \u092a\u094d\u0930\u094b\u091c\u0947\u0915\u094d\u091f\u092e\u093e \u0915\u094b\u0921 \u091c\u091f\u093f\u0932 \u091b \u092d\u0928\u0947 \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917\u0932\u0947 \u0938\u092e\u0938\u094d\u092f\u093e \u0938\u092e\u093e\u0927\u093e\u0928 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u092e\u0930\u094d\u092e\u0924 \u0930 \u0935\u093f\u0938\u094d\u0924\u093e\u0930: \u092f\u0926\u093f \u092d\u0935\u093f\u0937\u094d\u092f\u092e\u093e \u092a\u094d\u0930\u094b\u091c\u0947\u0915\u094d\u091f\u092e\u093e \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0930 \u0938\u0941\u0927\u093e\u0930 \u0906\u0935\u0936\u094d\u092f\u0915 \u091b \u092d\u0928\u0947 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917\u0932\u0947 \u092e\u0930\u094d\u092e\u0924 \u0930 \u0935\u093f\u0938\u094d\u0924\u093e\u0930\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u094b\u0917: \u091c\u092c \u0924\u092a\u093e\u0908\u0902\u0932\u0947 \u0935\u093f\u0936\u0947\u0937 \u0915\u093e\u0930\u094d\u092f\u0915\u094b \u0932\u093e\u0917\u093f \u0938\u094d\u0925\u093e\u092a\u093f\u0924 \u0924\u0930\u093f\u0915\u093e \u092c\u0928\u093e\u0909\u0928 \u091a\u093e\u0939\u0928\u0941\u0939\u0941\u0928\u094d\u091b, \u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964</li> </ul>"},{"location":"nepali/designpattern/intro/#_4","title":"\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937","text":"<p>\u0921\u093f\u091c\u093e\u0907\u0928 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942 \u0938\u092b\u094d\u091f\u0935\u0947\u092f\u0930 \u0935\u093f\u0915\u093e\u0938\u092e\u093e \u0905\u0928\u0941\u0936\u093e\u0938\u0928 \u0930 \u0938\u0941\u0927\u093e\u0930\u0915\u094b \u0932\u093e\u0917\u093f \u092e\u0939\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0939\u0941\u0928\u094d\u091b\u0928\u094d\u0964 \u092f\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0939\u0930\u0942\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093f\u0924, \u092e\u0930\u094d\u092e\u0924\u092f\u094b\u0917\u094d\u092f, \u0930 \u092a\u0941\u0928\u0903 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u092f\u094b\u0917\u094d\u092f \u092c\u0928\u093e\u0909\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u0938\u0939\u0940 \u0938\u092e\u092f\u092e\u093e \u0930 \u0938\u0939\u0940 \u092a\u094d\u092f\u093e\u091f\u0930\u094d\u0928\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u093e \u0935\u093f\u0915\u093e\u0938 \u092a\u094d\u0930\u0915\u094d\u0930\u093f\u092f\u093e \u0927\u0947\u0930\u0948 \u0938\u0939\u091c \u0930 \u092a\u094d\u0930\u092d\u093e\u0935\u0915\u093e\u0930\u0940 \u0939\u0941\u0928\u094d\u091b\u0964</p>"},{"location":"nepali/js/callbackfunction/","title":"callback function","text":""},{"location":"nepali/js/callbackfunction/#callback-function","title":"Callback Function (\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u090f\u0909\u091f\u093e \u092f\u0938\u094d\u0924\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b \u091c\u0941\u0928 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u0928\u094d\u091b \u0930 \u0924\u094d\u092f\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u090f\u092a\u091b\u093f \u092f\u0938\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u0932\u093e\u0908 \u0938\u093e\u092e\u093e\u0928\u094d\u092f\u0924\u092f\u093e \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923 <pre><code>function calculateSum(a, b, callback) {\n    const sum = a + b; // \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u091b\n    callback(sum);     // \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u092a\u0930\u093f\u0923\u093e\u092e\u0938\u0939\u093f\u0924 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\nfunction printResult(result) {\n    console.log(\"\u0928\u0924\u093f\u091c\u093e \u0939\u094b:\", result);\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\ncalculateSum(5, 3, printResult);\n</code></pre>"},{"location":"nepali/js/callbackfunction/#inner-function","title":"Inner Function (\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u092d\u093f\u0924\u094d\u0930 \u092a\u0930\u093f\u092d\u093e\u0937\u093f\u0924 \u0917\u0930\u093f\u090f\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u0930 \u0938\u094d\u0915\u094b\u092a\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093f\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u091b\u094c\u0902? <pre><code>function outerFunction() {\n    const greeting = \"\u0928\u092e\u0938\u094d\u0915\u093e\u0930\";\n\n    function innerFunction() {\n        console.log(greeting); // \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u091b\n    }\n\n    innerFunction(); // \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\nouterFunction();\n</code></pre> <ol> <li>\u0915\u094b\u0921\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928: \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0927\u0947\u0930\u0948 \u0938\u092b\u093e \u0930 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942: \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u093f\u0919\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0939\u0941\u0928\u094d\u091b\u0964</li> <li>\u0938\u094d\u0915\u094b\u092a: \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b, \u091c\u0938\u0932\u0947 \u0915\u094b\u0921\u0915\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u0930 \u0935\u094d\u092f\u093e\u0935\u0939\u093e\u0930\u093f\u0915\u0924\u093e \u092c\u0922\u093e\u0909\u0901\u091b\u0964</li> </ol> <p>\u092f\u0940 \u0915\u093e\u0930\u0923\u0932\u0947 \u0917\u0930\u094d\u0926\u093e \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0930 \u0909\u092a\u092f\u094b\u0917\u0940 \u091b\u0928\u094d\u0964</p> <p>why we need to pass function in arguments in another function. explain me in nepali.</p> <p>\u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u092a\u0930\u094d\u0928\u0947 \u0915\u093e\u0930\u0923\u0939\u0930\u0942 \u0924\u0932 \u0935\u094d\u092f\u093e\u0916\u094d\u092f\u093e \u0917\u0930\u093f\u090f\u0915\u093e \u091b\u0928\u094d:</p> <ol> <li> <p>\u0915\u093e\u0930\u094d\u092f\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928 (Separation of Concerns)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u092f\u0938\u0932\u0947 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0905\u0932\u0917 \u0917\u0930\u094d\u0928\u0947 \u092e\u094c\u0915\u093e \u0926\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u092e\u0941\u0916\u094d\u092f \u0915\u093e\u0930\u094d\u092f \u0930 \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0939\u0941\u0928\u0947 \u0915\u093e\u0930\u094d\u092f \u0905\u0932\u0917 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f, \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928 \u0930 \u092a\u0930\u093f\u0923\u093e\u092e\u0932\u093e\u0908 \u092a\u094d\u0930\u0926\u0930\u094d\u0936\u0928 \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u091b\u0941\u091f\u094d\u091f\u0948 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0932\u091a\u093f\u0932\u094b\u092a\u0928 (Flexibility)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u0924\u094d\u092f\u0938\u0915\u094b \u0905\u0930\u094d\u0925 \u0939\u093e\u092e\u0940 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0938\u094b\u0939\u0940 \u092e\u0942\u0932 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0935\u094d\u092f\u0935\u0939\u093e\u0930 \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u094c\u0902\u0964 \u092f\u0938\u0932\u0947 \u0939\u093e\u092e\u0940\u0932\u093e\u0908 \u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e \u0905\u0928\u0941\u0938\u093e\u0930 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u0930\u0939\u0930\u0942 \u092c\u0928\u093e\u0909\u0928\u0947 \u0905\u0935\u0938\u0930 \u0926\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 (Usage in Asynchronous Operations)</p> <p>\u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u0927\u0947\u0930\u0948 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0939\u0941\u0928\u094d\u091b\u0928\u094d, \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u0964 \u091c\u092c \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u0939\u0941\u0928\u094d\u091b, \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0928\u0924\u093f\u091c\u093e \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932 \u0917\u0930\u094d\u0928\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0928\u0924\u093f\u091c\u093e \u092a\u093e\u090f\u0915\u093e \u092c\u0947\u0932\u093e \u0915\u0941\u0928\u0948 \u0935\u093f\u0936\u0947\u0937 \u0915\u093e\u0930\u094d\u092f \u0917\u0930\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> <li> <p>\u0938\u094d\u0915\u094b\u092a\u0915\u094b \u092a\u0939\u0941\u0901\u091a (Access to Scope)</p> <p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0928\u094d\u0964 \u092f\u0938\u0932\u0947 \u092b\u0919\u094d\u0938\u0928\u092d\u093f\u0924\u094d\u0930\u0915\u094b \u0921\u0947\u091f\u093e \u0930 \u0938\u094d\u0925\u093f\u0924\u093f \u0938\u0941\u0930\u0915\u094d\u0937\u093f\u0924 \u0930\u093e\u0916\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u0915\u094b\u0921\u0932\u0947 \u0920\u0942\u0932\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> </ol> \u0909\u0926\u093e\u0939\u0930\u0923\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937 <pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n        callback(data);\n    }, 2000);\n}\n\nfunction handleData(data) {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n}\n\n// \u092f\u0939\u093e\u0901 fetchData \u0932\u093e\u0908 handleData \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u090f\u0915\u094b \u091b\nfetchData(handleData);\n</code></pre> <p>\u092f\u0938\u0948\u0932\u0947, \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u091b\u0964 \u092f\u0938\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b, \u0932\u091a\u093f\u0932\u094b \u0930 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u0937\u092e \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"nepali/js/callbackfunction/#alternative-to-callback-function","title":"Alternative to callback function","text":"<p>what are the advance alternative to callback function. explain in nepali</p> <p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u091f\u094d\u091f\u093e\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u0947 \u0915\u0947\u0939\u0940 \u0909\u0928\u094d\u0928\u0924 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942 \u0928\u093f\u092e\u094d\u0928\u0932\u093f\u0916\u093f\u0924 \u091b\u0928\u094d:</p> <ol> <li> <p>\u092a\u094d\u0930\u092e\u093f\u0938 (Promises)</p> <p>\u092a\u094d\u0930\u092e\u093f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u092e\u093f\u0932\u094d\u0928\u0947 \u092c\u0928\u093e\u0909\u0901\u091b\u0964 \u092f\u0938\u0932\u0947 \u0926\u0941\u0908 \u092e\u0941\u0916\u094d\u092f \u0905\u0935\u0938\u094d\u0925\u093e\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0926\u091b: \"fulfilled\" (\u0938\u092b\u0932\u0924\u093e) \u0930 \"rejected\" (\u0905\u0938\u094d\u0935\u0940\u0915\u0943\u0924\u093f)\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n            resolve(data); // \u0938\u092b\u0932\u0924\u093e\u0938\u093e\u0925 \u0921\u0947\u091f\u093e \u092a\u0920\u093e\u0909\u0901\u091b\n        }, 2000);\n    });\n}\n\nfetchData()\n    .then(data =&gt; {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    })\n    .catch(error =&gt; {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    });\n</code></pre> </li> <li> <p>Async/Await</p> <p>Async/Await \u092a\u094d\u0930\u092e\u093f\u0938\u0939\u0930\u0942\u0915\u094b \u0905\u0927\u093f\u0915 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u0920\u0928\u0940\u092f\u0924\u093e \u092d\u090f\u0915\u094b \u0924\u0930\u093f\u0915\u093e \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u094b\u0921\u0932\u093e\u0908 \u0938\u092e\u093e\u0928\u094d\u092f \u0915\u094b\u0921 \u091c\u0938\u094d\u0924\u0948 \u0932\u0947\u0916\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>async function getData() {\n    try {\n        const data = await fetchData(); // \u092a\u094d\u0930\u092e\u093f\u0938\u0915\u094b \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u092a\u094d\u0930\u0924\u0940\u0915\u094d\u0937\u093e \u0917\u0930\u094d\u091b\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    } catch (error) {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    }\n}\n\ngetData();\n</code></pre> </li> <li> <p>Observables (RxJS)</p> <p>Observables\u0932\u0947 \u0921\u0947\u091f\u093e \u0938\u094d\u091f\u094d\u0930\u0940\u092e\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0902\u0932\u093e\u0908 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0918\u091f\u0928\u093e\u0939\u0930\u0942\u0915\u094b \u0938\u0941\u091a\u0928\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b \u0930 \u0927\u0947\u0930\u0948 \u0936\u0915\u094d\u0924\u093f\u0936\u093e\u0932\u0940 \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>import { Observable } from 'rxjs';\n\nconst dataObservable = new Observable(subscriber =&gt; {\n    setTimeout(() =&gt; {\n        subscriber.next({ id: 1, name: \"\u0930\u093e\u092e\" });\n        subscriber.complete(); // \u0938\u092e\u093e\u092a\u094d\u0924\n    }, 2000);\n});\n\ndataObservable.subscribe({\n    next(data) {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    },\n    complete() {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u0915\u094d\u0930\u093f\u092f\u093e \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u092f\u094b\");\n    }\n});\n</code></pre> </li> <li> <p>Event Emitter</p> <p>Event Emitter\u0939\u0930\u0942\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f \u0921\u094d\u0930\u093f\u092d\u0928 \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919\u0915\u094b \u0932\u093e\u0917\u093f \u0909\u092a\u092f\u0941\u0915\u094d\u0924 \u0939\u0941\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u0941\u0928\u094d\u0928 \u0930 \u0924\u093f\u0928\u0940\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>const EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\nmyEmitter.on('dataReceived', (data) =&gt; {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n});\n\n// \u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u0907\u092d\u0947\u0928\u094d\u091f\u0932\u093e\u0908 \u091f\u094d\u0930\u093f\u0917\u0930 \u0917\u0930\u094d\u091b\nsetTimeout(() =&gt; {\n    myEmitter.emit('dataReceived', { id: 1, name: \"\u0930\u093e\u092e\" });\n}, 2000);\n</code></pre> </li> </ol> <p>\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937</p> <p>\u092f\u0940 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942\u0932\u0947 \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u0940\u092e\u093e\u0939\u0930\u0942 \u0930 \u091c\u091f\u093f\u0932\u0924\u093e\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u092e\u0947\u091f\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092a\u094d\u0930\u092e\u093f\u0938, Async/Await, Observables, \u0930 Event Emitters\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b, \u092a\u0920\u0928\u0940\u092f \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"nepali/js/example/","title":"Example","text":"<p>Sure! Here\u2019s a complete example that includes a higher-order function and a callback function. This example simulates a simple game where you can choose different actions to play with.</p>"},{"location":"nepali/js/example/#complete-example","title":"Complete Example","text":"<pre><code>// Higher-order function\nfunction toyBox(action) {\n  console.log(\"Let's play with the toy!\");\n  action(); // Using the callback function\n}\n\n// Callback function 1\nfunction jump() {\n  console.log(\"Jumping up and down!\");\n}\n\n// Callback function 2\nfunction spin() {\n  console.log(\"Spinning around!\");\n}\n\n// Callback function 3\nfunction dance() {\n  console.log(\"Dancing to the music!\");\n}\n\n// Using the toy box with different toys (callback functions)\ntoyBox(jump); // Will call the jump function\ntoyBox(spin); // Will call the spin function\ntoyBox(dance); // Will call the dance function\n</code></pre> <p>What Happens Here</p> <ol> <li>Higher-Order Function: <code>toyBox</code> is the higher-order function that accepts another function (<code>action</code>) as an argument.</li> <li>Callback Functions: <code>jump</code>, <code>spin</code>, and <code>dance</code> are the callback functions that define different actions.</li> </ol> Output <p>When you run this code, you\u2019ll see:</p> <pre><code>Let's play with the toy!\nJumping up and down!\nLet's play with the toy!\nSpinning around!\nLet's play with the toy!\nDancing to the music!\n</code></pre> <p>Summary</p> <ul> <li>The toyBox function can take any of the action functions (<code>jump</code>, <code>spin</code>, or <code>dance</code>) and use them.</li> <li>Each action is a callback function that gets executed inside the higher-order function.</li> </ul> <p>how a function becomes a callback function in JavaScript.</p>"},{"location":"nepali/js/example/#callback-function","title":"Callback Function","text":"<p>Standalone Function vs. Callback Function</p> <ol> <li> <p>Standalone Function:</p> <ul> <li>The function <code>dance</code> on its own is just a regular function. It doesn't do anything until you call it.</li> </ul> <pre><code>function dance() {\n  console.log(\"Dancing to the music!\");\n}\n</code></pre> </li> <li> <p>Callback Function:</p> <ul> <li>A function becomes a callback when it is passed as an argument to another function and called within that function. For example:</li> </ul> <pre><code>function toyBox(action) {\n  console.log(\"Let's play with the toy!\");\n  action(); // Here, action is calling the callback function\n}\n\ntoyBox(dance); // Now, dance is used as a callback function\n</code></pre> </li> </ol> <p>Summary</p> <ul> <li>Standalone Function: Just a regular function that can be called independently.</li> <li>Callback Function: A function that is passed to another function as an argument and is executed within that function.</li> </ul> <p>In the example above, <code>dance</code> becomes a callback function when we pass it to <code>toyBox</code>. It\u2019s all about the context in which the function is used!</p> <p>how function becomes high order function in javascript</p>"},{"location":"nepali/js/example/#high-order-function","title":"High-Order Function","text":"<p>A function becomes a higher-order function in JavaScript when it meets one of the following criteria:</p> <ul> <li>Takes a Function as an Argument: The function accepts another function as an input parameter.</li> <li>Returns a Function: The function produces another function as its output.</li> </ul> Examples <ol> <li> <p>Higher-Order Function Taking a Function as an Argument</p> <p>Here\u2019s an example where a function takes another function as an argument:</p> <pre><code>// Higher-order function\nfunction greetUser(greetingFunction) {\n    const userName = \"Alice\";\n    greetingFunction(userName); // Calling the passed function\n}\n\n// Callback function\nfunction sayHello(name) {\n    console.log(\"Hello, \" + name + \"!\");\n}\n\n// Using the higher-order function\ngreetUser(sayHello); // sayHello is passed as an argument\n</code></pre> </li> <li> <p>Higher-Order Function Returning a Function</p> <p>Here\u2019s an example where a function returns another function:</p> <pre><code>// Higher-order function\nfunction createMultiplier(multiplier) {\n    return function (number) {\n        return number * multiplier; // Inner function\n    };\n}\n\n// Using the higher-order function\nconst double = createMultiplier(2); // Returns a function that doubles numbers\nconsole.log(double(5)); // Outputs: 10\n</code></pre> </li> </ol> <p>Summary</p> <ul> <li>A function becomes a higher-order function if it either takes a function as an argument or returns a function.</li> <li>This allows for more flexible and reusable code, enabling you to create more abstract and powerful functionality in your programs.</li> </ul>"},{"location":"nepali/js/explain-to-5-year-old/","title":"Explain","text":""},{"location":"nepali/js/explain-to-5-year-old/#explain-to-5-year-old","title":"Explain to 5 year old","text":"<p>Sure! Let\u2019s think about it like toys and games.</p> <ul> <li> <p>Higher-Order Function: Imagine you have a toy box (the higher-order function) that can hold other toys (functions). You can put a toy in the box, or take one out to play with later.</p> </li> <li> <p>Callback Function: Now, think of a specific toy (the callback function) that you can ask your friend to play with. You tell your friend, \"Here\u2019s my toy, play with it when you want!\"</p> </li> </ul> <p>So:</p> <ul> <li>Toy Box (Higher-Order Function): It can hold toys or give you toys to play with.</li> <li>Specific Toy (Callback Function): It's just one toy you can use whenever you need it.</li> </ul> <p>All toy boxes can hold specific toys, but not every toy is a toy box. Does that help?</p>"},{"location":"nepali/js/explain-to-5-year-old/#example","title":"Example","text":"<p>Absolutely! Here\u2019s a simple example using our toy box and toy analogy.</p>"},{"location":"nepali/js/explain-to-5-year-old/#higher-order-function-example","title":"Higher-Order Function Example","text":"<p>Imagine you have a toy box that can take a toy and play with it:</p> <pre><code>function toyBox(playWithToy) {\n  console.log(\"Let's play!\");\n  playWithToy(); // Using the toy (callback function)\n}\n</code></pre>"},{"location":"nepali/js/explain-to-5-year-old/#callback-function-example","title":"Callback Function Example","text":"<p>Now, here\u2019s a specific toy you want to play with:</p> <pre><code>function myToy() {\n  console.log(\"I'm a toy! Whee!\");\n}\n\n// Using the toy box with the toy\ntoyBox(myToy); // myToy is the callback function\n</code></pre>"},{"location":"nepali/js/explain-to-5-year-old/#what-happens-here","title":"What Happens Here","text":"<ul> <li>Toy Box (<code>toyBox</code>): This is the higher-order function because it can take another function (playWithToy) as an argument.</li> <li>Specific Toy (<code>myToy</code>): This is the callback function that you pass to the toy box to play with.</li> </ul> <p>When you run this code, it will say:</p> <pre><code>Let's play!\nI'm a toy! Whee!\n</code></pre> <p>So, the toy box (higher-order function) used the toy (callback function) to have fun!</p>"},{"location":"nepali/js/highorderfunction/","title":"highorder function","text":""},{"location":"nepali/js/highorderfunction/#difference-betweeen-callback-high-order-function","title":"Difference betweeen Callback &amp; High-order function","text":"<p>Callback function \u0930 Higher-order function \u092c\u0940\u091a\u0915\u094b \u092e\u0941\u0916\u094d\u092f \u092d\u093f\u0928\u094d\u0928\u0924\u093e \u0915\u0947 \u0939\u094b \u092d\u0928\u0947:</p> <ul> <li> <p>Higher-order function \u092d\u0928\u0947\u0915\u094b function \u0939\u094b, \u091c\u0938\u0932\u0947 function \u0932\u093e\u0908 parameter \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u0932\u093f\u0928\u094d\u091b \u0935\u093e function \u0932\u093e\u0908 return \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 function \u0932\u093e\u0908 \u0928\u093f\u092f\u0928\u094d\u0924\u094d\u0930\u0923 \u0917\u0930\u094d\u091b\u0964</p> </li> <li> <p>Callback function \u092d\u0928\u0947\u0915\u094b function \u0939\u094b, \u091c\u0941\u0928 \u0905\u0930\u094d\u0915\u094b function \u0932\u093e\u0908 argument \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u0926\u093f\u0907\u0928\u094d\u091b, \u0930 \u092a\u091b\u093f \u0924\u094d\u092f\u0939\u0940 function \u092d\u093f\u0924\u094d\u0930\u092c\u093e\u091f \u092c\u094b\u0932\u093e\u0907\u0928\u094d\u091b\u0964</p> </li> </ul>"},{"location":"nepali/js/highorderfunction/#_1","title":"\u092e\u0941\u0916\u094d\u092f \u092b\u0930\u0915:","text":"<ul> <li>Higher-order function \u0932\u0947 function \u0932\u093e\u0908 parameter \u0935\u093e return \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u091b\u0964</li> <li>Callback function \u092d\u0928\u0947\u0915\u094b function \u0939\u094b, \u091c\u0941\u0928 \u0905\u0930\u094d\u0915\u094b function \u0915\u094b argument \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u0926\u093f\u0907\u0928\u094d\u091b \u0930 \u092a\u091b\u093f \u091a\u0932\u093e\u0907\u0928\u094d\u091b\u0964</li> </ul> \u0909\u0926\u093e\u0939\u0930\u0923: <pre><code>// Higher-order function\nfunction higherOrder(func) {\n    return func();\n}\n\n// Callback function\nfunction greet(callback) {\n    console.log(\"Hello\");\n    callback(); // callback function \u092c\u094b\u0932\u093e\u0907\u0928\u094d\u091b\n}\n</code></pre>"},{"location":"nepali/js/highorderfunction/#_2","title":"\u0938\u0902\u0915\u094d\u0937\u0947\u092a\u092e\u093e:","text":"<ul> <li>Higher-order function \u0932\u0947 control \u0917\u0930\u094d\u091b\u0964</li> <li>Callback function \u0932\u0947 reaction \u0917\u0930\u094d\u091b\u0964</li> </ul>"},{"location":"nepali/js/related/","title":"Related","text":""},{"location":"nepali/js/related/#overview","title":"Overview","text":"<p>Yes, exactly! Callback functions and higher-order functions are closely related:</p> <ul> <li> <p>Higher-Order Functions: These are functions that can take other functions as arguments or return functions. They create the context in which callbacks are used.</p> </li> <li> <p>Callback Functions: These are functions that are passed to higher-order functions to be executed later. They rely on higher-order functions to be called.</p> </li> </ul>"},{"location":"nepali/js/related/#relationship","title":"Relationship","text":"<ul> <li> <p>Creating Callbacks: To use a callback function, you typically need a higher-order function that will call it. For example, a function that takes a callback and invokes it based on certain conditions.</p> </li> <li> <p>Execution Context: The higher-order function provides the environment where the callback is executed. It determines when and how the callback function is called.</p> </li> </ul>"},{"location":"nepali/js/related/#example","title":"Example","text":"<p>Here\u2019s a summary with an example:</p> <pre><code>// Higher-order function\nfunction processData(callback) {\n  let data = [1, 2, 3];\n  callback(data); // Invoking the callback with data\n}\n\n// Callback function\nfunction displayData(data) {\n  console.log(\"Data received:\", data);\n}\n\n// Using the higher-order function with a callback\nprocessData(displayData); // displayData is the callback\n</code></pre>"},{"location":"nepali/js/related/#summary","title":"Summary","text":"<ul> <li>Higher-order functions enable the use of callback functions by accepting them as arguments.</li> <li>Callback functions rely on higher-order functions to be executed in response to specific events or conditions.</li> </ul> <p>So yes, you need a higher-order function to effectively use a callback function!</p>"},{"location":"nepali/js/usecase/","title":"Use Case","text":"<p>Higher-order functions and callback functions are fundamental concepts in JavaScript that enable more flexible and reusable code. Here are some real use cases for both:</p>"},{"location":"nepali/js/usecase/#use-cases-for-higher-order-functions","title":"Use Cases for Higher-Order Functions","text":"<ol> <li> <p>Array Methods: Many built-in array methods in JavaScript, like <code>map</code>, <code>filter</code>, and <code>reduce</code>, are higher-order functions. They take a callback function to process array elements.</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((num) =&gt; num * 2); // `map` is a higher-order function\n</code></pre> </li> <li> <p>Event Handling: When dealing with user interactions (like clicks), you often use higher-order functions to define how the application should respond.</p> <pre><code>button.addEventListener(\"click\", function () {\n  console.log(\"Button clicked!\");\n}); // `addEventListener` is a higher-order function\n</code></pre> </li> <li> <p>Function Composition: Higher-order functions can combine multiple functions to create new functionality.</p> <pre><code>function compose(f, g) {\n  return function (x) {\n    return f(g(x)); // Combines two functions\n  };\n}\n</code></pre> </li> </ol>"},{"location":"nepali/js/usecase/#use-cases-for-callback-functions","title":"Use Cases for Callback Functions","text":"<ol> <li> <p>Asynchronous Operations: Callbacks are commonly used in asynchronous programming, such as handling results from API calls.</p> <pre><code>fetch(\"/api/data\")\n  .then((response) =&gt; response.json())\n  .then((data) =&gt; {\n    console.log(data); // Callback for handling data after fetching\n  });\n</code></pre> </li> <li> <p>Custom Logic: Callbacks allow you to define custom logic to execute in specific contexts, such as sorting arrays with custom comparison functions.</p> <pre><code>const fruits = [\"banana\", \"apple\", \"orange\"];\nfruits.sort((a, b) =&gt; a.localeCompare(b)); // Callback for sorting\n</code></pre> </li> <li> <p>Control Flow: In scenarios like iterating through collections, callbacks can be used to control the flow of operations.</p> <pre><code>function forEach(array, callback) {\n  for (let item of array) {\n    callback(item); // Calls the callback for each item\n  }\n}\n</code></pre> </li> </ol>"},{"location":"nepali/js/usecase/#summary","title":"Summary","text":"<ul> <li>Higher-Order Functions: Enable more abstract and reusable code, such as processing data with built-in array methods, composing functions, or handling events.</li> <li>Callback Functions: Allow you to define custom behavior for asynchronous operations, handle data, or control the flow of logic.</li> </ul> <p>Together, they help make JavaScript code more modular, maintainable, and expressive!</p>"},{"location":"nepali/js/usecase/#additional","title":"Additional","text":"Example of Using a Callback FunctionExample of Using a Higher-Order FunctionSummary <p>Scenario: Handling an asynchronous operation, like fetching data from an API.</p> <pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { message: \"Hello, world!\" };\n        callback(data); // Execute the callback with the fetched data\n    }, 1000); // Simulating an API call with setTimeout\n}\n\n// Callback function\nfunction handleData(data) {\n    console.log(data.message); // Handle the data received\n}\n\n// Using the fetchData function with a callback\nfetchData(handleData);\n</code></pre> <p>When to Use a Callback:</p> <p>Use callbacks when you want to define custom behavior that should occur after an asynchronous operation completes, like handling the result of a data fetch.</p> <p>Scenario: Creating a function that modifies behavior by accepting a function as an argument.</p> <pre><code>// Higher-order function\nfunction applyOperation(numbers, operation) {\n    return numbers.map(operation); // Apply the operation to each number\n}\n\n// Callback function for squaring numbers\nfunction square(num) {\n    return num * num;\n}\n\n// Callback function for doubling numbers\nfunction double(num) {\n    return num * 2;\n}\n\n// Using the higher-order function\nconst nums = [1, 2, 3, 4];\nconst squaredNumbers = applyOperation(nums, square); // Using square function\nconst doubledNumbers = applyOperation(nums, double); // Using double function\n\nconsole.log(squaredNumbers); // Outputs: [1, 4, 9, 16]\nconsole.log(doubledNumbers); // Outputs: [2, 4, 6, 8]\n</code></pre> <p>When to Use a Higher-Order Function:</p> <ul> <li>Use higher-order functions when you want to create reusable logic that can operate on functions, like transforming arrays or implementing custom operations.</li> </ul> <ul> <li>Callback Function: Use when you need to define behavior that runs after an asynchronous operation, such as processing data after fetching it.</li> <li>Higher-Order Function: Use when you want to create flexible, reusable functions that can accept other functions as arguments to modify their behavior.</li> </ul> <p>These patterns help keep your code clean, modular, and maintainable!</p>"},{"location":"nepali/js/usecase/#when-to-use","title":"When to use","text":"When to Use Callback FunctionsWhen to Use Higher-Order FunctionsSummary <ol> <li> <p>Asynchronous Operations: Fetching data from an API.</p> <pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { message: \"Hello, world!\" };\n        callback(data); // Execute the callback with the fetched data\n    }, 1000); // Simulating an API call with setTimeout\n}\n\n// Callback function\nfunction handleData(data) {\n    console.log(data.message); // Handle the data received\n}\n\n// Using the fetchData function with a callback\nfetchData(handleData);\n</code></pre> </li> <li> <p>Event Handling: Responding to user clicks.</p> <pre><code>const button = document.createElement('button');\nbutton.textContent = \"Click Me\";\ndocument.body.appendChild(button);\n\n// Callback function for button click\nbutton.addEventListener('click', function() {\n    console.log(\"Button was clicked!\"); // Handle click event\n});\n</code></pre> </li> <li> <p>Custom Behavior in Loops: Processing items in an array.</p> <pre><code>const numbers = [1, 2, 3, 4];\n\n// Callback function for processing\nfunction processNumber(num) {\n    console.log(num * 2); // Double each number\n}\n\n// Using forEach to apply the callback\nnumbers.forEach(processNumber); // Outputs: 2, 4, 6, 8\n</code></pre> </li> </ol> <ol> <li> <p>Reusable Logic: Applying operations to an array.</p> <pre><code>// Higher-order function\nfunction applyOperation(numbers, operation) {\n    return numbers.map(operation); // Apply the operation to each number\n}\n\n// Callback function for squaring numbers\nfunction square(num) {\n    return num * num;\n}\n\nconst nums = [1, 2, 3, 4];\nconst squaredNumbers = applyOperation(nums, square); // Using square function\n\nconsole.log(squaredNumbers); // Outputs: [1, 4, 9, 16]\n</code></pre> </li> <li> <p>Function Composition: Combining functions.</p> <pre><code>// Higher-order function for composition\nfunction compose(f, g) {\n    return function(x) {\n        return f(g(x)); // Combines two functions\n    };\n}\n\n// Example functions\nfunction add1(x) {\n    return x + 1;\n}\n\nfunction multiply2(x) {\n    return x * 2;\n}\n\nconst addThenMultiply = compose(multiply2, add1);\nconsole.log(addThenMultiply(3)); // Outputs: 8 (3 + 1 = 4, then 4 * 2 = 8)\n</code></pre> </li> <li> <p>Flexible Operations: Applying different operations.</p> <pre><code>// Higher-order function\nfunction calculate(numbers, operation) {\n    return numbers.map(operation); // Apply the operation\n}\n\n// Different callback functions\nfunction double(num) {\n    return num * 2;\n}\n\nfunction triple(num) {\n    return num * 3;\n}\n\nconst nums2 = [1, 2, 3];\nconst doubled = calculate(nums2, double); // Using double function\nconst tripled = calculate(nums2, triple); // Using triple function\n\nconsole.log(doubled); // Outputs: [2, 4, 6]\nconsole.log(tripled); // Outputs: [3, 6, 9]\n</code></pre> </li> </ol> <ul> <li>Callback Functions: Best for handling events, asynchronous operations, and custom logic during iterations.</li> <li>Higher-Order Functions: Ideal for creating reusable logic, function composition, and flexible operations that depend on passed functions.</li> </ul> <p>These guidelines can help you determine when to use each concept in your JavaScript programming!</p>"},{"location":"nepali/react/context/","title":"context api","text":""},{"location":"nepali/react/context/#context","title":"Context \u0915\u0947 \u0939\u094b?","text":"<p>React \u092e\u093e Context \u090f\u0915 \u0935\u093f\u0936\u0947\u0937\u0924\u093e \u0939\u094b \u091c\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0932\u093e\u0908 \"props drilling\" \u092c\u093f\u0928\u093e \u0928\u0948 \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0915\u094b \u092c\u0940\u091a\u092e\u093e \u0921\u0947\u091f\u093e \u0938\u093e\u091d\u093e \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0932\u093e\u0908 \u090f\u0915\u0948 \u092a\u091f\u0915\u092e\u093e \u0927\u0947\u0930\u0948 \u0938\u094d\u0924\u0930\u0915\u093e \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u092e\u093e \u0921\u0947\u091f\u093e \u092a\u0920\u093e\u0909\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u0926\u091b\u0964</p>"},{"location":"nepali/react/context/#context_1","title":"Context \u0915\u094b \u092a\u094d\u0930\u092e\u0941\u0916 \u0924\u0924\u094d\u0935\u0939\u0930\u0942:","text":"<ol> <li> <p>Context \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d:</p> <p>Context \u0938\u093f\u0930\u094d\u091c\u0928\u093e \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f <code>createContext</code> \u092b\u0902\u0915\u094d\u0936\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u094b \u090f\u0915 \u0928\u092f\u093e\u0901 Context \u0935\u0938\u094d\u0924\u0941 \u092b\u0930\u094d\u0915\u093e\u0909\u0901\u091b \u091c\u0941\u0928 \u0924\u092a\u093e\u0908\u0932\u0947 \u0938\u0901\u0917\u0948 \u0921\u0947\u091f\u093e \u0930 \u092b\u0902\u0915\u094d\u0936\u0928\u0939\u0930\u0942 \u0938\u093e\u091d\u093e \u0917\u0930\u094d\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0941\u0939\u0941\u0928\u094d\u091b\u0964</p> <pre><code>const MyContext = createContext();\n</code></pre> </li> <li> <p>Provider:</p> <p>Provider \u090f\u0915 \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f \u0939\u094b \u091c\u0938\u0932\u0947 Context \u0915\u094b \u092e\u0942\u0932\u094d\u092f \u0938\u0947\u091f \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0906\u092b\u094d\u0928\u094b \u0938\u092c\u0948 \u092c\u093e\u0932 \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0932\u093e\u0908 \u0909\u0915\u094d\u0924 \u092e\u0942\u0932\u094d\u092f \u092a\u094d\u0930\u0926\u093e\u0928 \u0917\u0930\u094d\u091b\u0964</p> <pre><code>&lt;MyContext.Provider value={/* \u0915\u0941\u0928\u0948 \u092e\u0942\u0932\u094d\u092f */}&gt;\n    {/* \u092c\u093e\u0932 \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942 */}\n&lt;/MyContext.Provider&gt;\n</code></pre> </li> <li> <p>Consumer:</p> <p>Consumer \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0932\u0947 Context \u092c\u093e\u091f \u092e\u0942\u0932\u094d\u092f \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 Context \u0915\u094b \u092e\u0942\u0932\u094d\u092f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f <code>useContext</code> \u0939\u0941\u0915 \u0935\u093e <code>MyContext.Consumer</code> \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0964</p> <pre><code>const value = useContext(MyContext);\n</code></pre> </li> </ol>"},{"location":"nepali/react/context/#_1","title":"\u092a\u094d\u0930\u092f\u094b\u0917\u0915\u094b \u092b\u093e\u0907\u0926\u093e:","text":"<ul> <li> <p>\u0938\u0939\u091c \u0921\u0947\u091f\u093e \u0938\u093e\u091d\u093e \u0917\u0930\u094d\u0928\u0941\u0939\u094b\u0938\u094d: Context \u0932\u0947 \u0924\u092a\u093e\u0908\u0932\u093e\u0908 \u0917\u0939\u093f\u0930\u093e\u0907\u0938\u092e\u094d\u092e\u0915\u094b \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u092e\u093e \u0921\u0947\u091f\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b, \u091c\u0938\u0932\u0947 \u0917\u0930\u094d\u0926\u093e \u0924\u092a\u093e\u0908\u0932\u0947 props \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u092a\u0930\u094d\u0928\u0947 \u091d\u0928\u094d\u091d\u091f\u092c\u093e\u091f \u092c\u091a\u094d\u0928 \u0938\u0915\u094d\u0928\u0941\u0939\u0941\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0935\u0948\u0936\u094d\u0935\u093f\u0915 \u0938\u094d\u091f\u0947\u091f \u092e\u094d\u092f\u093e\u0928\u0947\u091c\u092e\u0947\u0928\u094d\u091f: Context \u0932\u093e\u0908 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0920\u093e\u0909\u0901\u092e\u093e \u0938\u092e\u093e\u0928 \u0921\u0947\u091f\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b, \u091c\u0938\u094d\u0924\u0948 \u092a\u094d\u0930\u092f\u094b\u0917\u0915\u0930\u094d\u0924\u093e \u092a\u094d\u0930\u092e\u093e\u0923\u0940\u0915\u0930\u0923, \u0925\u0940\u092e, \u092d\u093e\u0937\u093e, \u0906\u0926\u093f\u0964</p> </li> </ul>"},{"location":"nepali/react/context/#_2","title":"\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937:","text":"<p>Context React \u092e\u093e \u0921\u0947\u091f\u093e \u0938\u093e\u091d\u093e \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u090f\u0915 \u0936\u0915\u094d\u0924\u093f\u0936\u093e\u0932\u0940 \u0909\u092a\u0915\u0930\u0923 \u0939\u094b\u0964 \u092f\u094b \u0935\u093f\u0936\u0947\u0937 \u0917\u0930\u0940 \u0920\u0941\u0932\u093e \u090f\u092a\u094d\u0932\u093f\u0915\u0947\u0938\u0928\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0909\u092a\u092f\u0941\u0915\u094d\u0924 \u091b \u091c\u0939\u093e\u0901 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0915\u092e\u094d\u092a\u094b\u0928\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0932\u0947 \u0938\u092e\u093e\u0928 \u091c\u093e\u0928\u0915\u093e\u0930\u0940 \u0906\u0935\u0936\u094d\u092f\u0915 \u092a\u0930\u094d\u0926\u091b\u0964 Context \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0924\u092a\u093e\u0908\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0905\u0927\u093f\u0915 \u0938\u092b\u093e \u0930 \u0935\u094d\u092f\u0935\u0938\u094d\u0925\u093e\u092a\u0928 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0928 \u0938\u0915\u094d\u0928\u0941\u0939\u0941\u0928\u094d\u091b\u0964</p>"},{"location":"nepali/react/context/#real-example","title":"Real Example","text":"ExampleExplanation <p>Here's a simple example of using React Context to manage a theme (light/dark mode) across a React application.</p> <p>Step 1: Create the Context</p> <p>Create a new file called <code>ThemeContext.js</code>.</p> <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\n// Create a Context\nconst ThemeContext = createContext();\n\n// Provider component\nexport const ThemeProvider = ({ children }) =&gt; {\n    const [theme, setTheme] = useState(\"light\"); // Default theme\n\n    const toggleTheme = () =&gt; {\n        setTheme((prevTheme) =&gt; (prevTheme === \"light\" ? \"dark\" : \"light\"));\n    };\n\n    return (\n        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;\n            {children}\n        &lt;/ThemeContext.Provider&gt;\n    );\n};\n\n// Custom hook to use the ThemeContext\nexport const useTheme = () =&gt; {\n    return useContext(ThemeContext);\n};\n</code></pre> <p>Step 2: Create the App Component</p> <p>Now, let's use this <code>ThemeProvider</code> in our main application file, usually <code>App.js</code>.</p> <pre><code>import React from \"react\";\nimport { ThemeProvider } from \"./ThemeContext\";\nimport ThemedComponent from \"./ThemedComponent\";\n\nconst App = () =&gt; {\n    return (\n        &lt;ThemeProvider&gt;\n            &lt;ThemedComponent /&gt;\n        &lt;/ThemeProvider&gt;\n    );\n};\n\nexport default App;\n</code></pre> <p>Step 3: Create a Themed Component</p> <p>Now, create a component that uses the theme context. Create a file called <code>ThemedComponent.js</code>.</p> <pre><code>import React from \"react\";\nimport { useTheme } from \"./ThemeContext\";\n\nconst ThemedComponent = () =&gt; {\n    const { theme, toggleTheme } = useTheme();\n\n    return (\n        &lt;div\n            style={{\n                background: theme === \"light\" ? \"#fff\" : \"#333\",\n                color: theme === \"light\" ? \"#000\" : \"#fff\",\n                padding: \"20px\",\n            }}\n        &gt;\n            &lt;h1&gt;{theme.charAt(0).toUpperCase() + theme.slice(1)} Mode&lt;/h1&gt;\n            &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ThemedComponent;\n</code></pre> <p>1. <code>ThemeContext.js</code>:</p> <ul> <li>We create a context called <code>ThemeContext</code>.</li> <li><code>ThemeProvider</code> manages the state of the theme (<code>light</code> or <code>dark</code>).</li> <li><code>toggleTheme</code> function switches between light and dark modes.</li> <li>The context value (theme and toggle function) is provided to all children.</li> </ul> <p>2. <code>App.js</code>:</p> <ul> <li>Wraps the <code>ThemedComponent</code> with <code>ThemeProvider</code>, allowing it to access the theme context.</li> </ul> <p>3. <code>ThemedComponent.js</code>:</p> <ul> <li>Uses the <code>useTheme</code> hook to access the current theme and the function to toggle it.</li> <li>It changes its style based on the current theme and includes a button to switch themes.</li> </ul> <p>Unlocking the Power of React Context: Your Go-To for Global State</p>"},{"location":"nepali/react/context/#without-custom-hooks","title":"Without custom hooks","text":"<p>The custom hook <code>useTheme</code> is not strictly necessary, but it provides some benefits that can enhance your code</p>"},{"location":"nepali/react/context/#benefits-of-using-a-custom-hook","title":"Benefits of Using a Custom Hook","text":"<ul> <li> <p>Encapsulation: It encapsulates the logic of accessing the context. This keeps your components cleaner and focused on rendering, rather than on how to get context values.</p> </li> <li> <p>Reusability: If you ever need to change the way you access the context (e.g., adding logging or additional logic), you can do it in one place (the custom hook) rather than in every component that uses the context.</p> </li> <li> <p>Readability: It improves readability. When you see <code>useTheme()</code>, it's immediately clear that you're accessing theme-related data, rather than having to remember which context you're accessing.</p> </li> </ul>"},{"location":"nepali/react/context/#using-without-the-custom-hook","title":"Using Without the Custom Hook","text":"<p>You can directly use <code>useContext(ThemeContext)</code> in your components without creating a custom hook. Here\u2019s how you could modify <code>ThemedComponent</code> to do that:</p> <pre><code>import React, { useContext } from \"react\";\nimport { ThemeContext } from \"./ThemeContext\";\n\nconst ThemedComponent = () =&gt; {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    &lt;div\n      style={{\n        background: theme === \"light\" ? \"#fff\" : \"#333\",\n        color: theme === \"light\" ? \"#000\" : \"#fff\",\n        padding: \"20px\",\n      }}\n    &gt;\n      &lt;h1&gt;{theme.charAt(0).toUpperCase() + theme.slice(1)} Mode&lt;/h1&gt;\n      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ThemedComponent;\n</code></pre>"},{"location":"nepali/react/context/#conclusion","title":"Conclusion","text":"<p>While you can certainly use <code>useContext</code> directly, using a custom hook like <code>useTheme</code> is a good practice that improves code organization, readability, and maintainability. It\u2019s a small abstraction that can lead to better structure in larger applications.</p>"},{"location":"nextjs/intro/","title":"Intro","text":"<p>Next.js is a popular React framework that enables developers to build server-side rendered (SSR) and static web applications with ease. It offers features like:</p> <ol> <li>Server-Side Rendering: Pages can be rendered on the server, which improves performance and SEO.</li> <li>Static Site Generation: You can pre-render pages at build time, making them fast and efficient.</li> <li>API Routes: You can create backend API endpoints within the same application.</li> <li>Automatic Code Splitting: It optimizes loading by splitting code into smaller bundles.</li> <li>File-Based Routing: Pages are created based on the file structure in the <code>pages</code> directory.</li> </ol> <p>Next.js simplifies the development process while providing flexibility, making it suitable for a wide range of applications, from blogs to large enterprise sites.</p>"},{"location":"nextjs/intro/#when-to-use","title":"When to use","text":"<p>Here\u2019s a breakdown of when to use Next.js versus when to use React on its own:</p> When to Use Next.jsWhen to Use React Alone <ol> <li> <p>SEO-Friendly Applications:</p> <ul> <li>Ideal for blogs, marketing sites, or any application where search engine optimization is crucial, thanks to server-side rendering (SSR) and static site generation (SSG).</li> </ul> </li> <li> <p>Dynamic and Static Content:</p> <ul> <li>Use Next.js when you need a mix of dynamic content (like user dashboards) and static pages (like marketing pages).</li> </ul> </li> <li> <p>Full-Stack Development:</p> <ul> <li>If you want to manage both frontend and backend logic within the same codebase, Next.js API routes provide a straightforward way to build and manage APIs.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>When you need performance features like automatic code splitting, image optimization, and incremental static regeneration.</li> </ul> </li> <li> <p>Complex Routing:</p> <ul> <li>If your application has complex routing requirements, Next.js\u2019s file-based routing system simplifies the process.</li> </ul> </li> <li> <p>Rapid Development:</p> <ul> <li>For projects that require quick iteration and development speed, Next.js offers built-in features that speed up the process.</li> </ul> </li> </ol> <ol> <li> <p>Single-Page Applications (SPAs):</p> <ul> <li>If you\u2019re building a traditional SPA where SEO is not a primary concern, a plain React application may be sufficient.</li> </ul> </li> <li> <p>Simple or Smaller Projects:</p> <ul> <li>For smaller applications or prototypes that don\u2019t require the complexity of server-side rendering or API routes.</li> </ul> </li> <li> <p>Custom Backend Solutions:</p> <ul> <li>If you already have a backend solution and want to focus purely on the frontend without Next.js\u2019s built-in backend capabilities.</li> </ul> </li> <li> <p>Learning and Experimentation:</p> <ul> <li>If you\u2019re learning React or experimenting with components, using React alone can be simpler without the additional layer that Next.js introduces.</li> </ul> </li> <li> <p>Client-Side Rendering:</p> <ul> <li>If your application primarily relies on client-side rendering and doesn\u2019t need server-rendered pages, a standard React setup may be enough.</li> </ul> </li> </ol> Summary <ul> <li>Choose <code>Next.js</code> for SEO, mixed content, full-stack capabilities, and performance optimizations.</li> <li>Choose <code>React</code> for simpler SPAs, smaller projects, or when you already have a backend in place.</li> </ul> <p>Ultimately, the choice depends on your project requirements and goals!</p>"},{"location":"reactPattern/functional-pattern-and-technique/","title":"Functional Pattern & Technique","text":"<p>Functional Patterns and Techniques in React</p>"},{"location":"reactPattern/functional-pattern-and-technique/#1-functional-components","title":"1. Functional Components","text":"<p>Use functional components instead of class components for simpler syntax and hooks.</p> <pre><code>const MyComponent = () =&gt; {\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#2-hooks","title":"2. Hooks","text":"<p>Leverage React hooks for state and side effects.</p> a. useStateb. useEffect <p>Manage state in functional components.</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <p>Handle side effects like data fetching and subscriptions.</p> <pre><code>import React, { useEffect, useState } from 'react';\n\nconst DataFetcher = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; setData(data));\n    }, []); // Empty array means this runs once on mount\n\n    return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>Encapsulate logic for reuse.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then(response =&gt; response.json())\n      .then(data =&gt; setData(data));\n  }, [url]);\n\n  return data;\n};\n\n// Usage\nconst DataDisplay = () =&gt; {\n  const data = useFetch('https://api.example.com/data');\n  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#4-context-api","title":"4. Context API","text":"<p>Share state across components without prop drilling.</p> a. Create Context <pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [value, setValue] = useState('Default Value');\n\n    return (\n        &lt;MyContext.Provider value={{ value, setValue }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n\n// Usage\nconst Component = () =&gt; {\n    const { value, setValue } = useContext(MyContext);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;{value}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setValue('New Value')}&gt;Change Value&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#5-memoization","title":"5. Memoization","text":"<p>Optimize performance with <code>React.memo</code> and <code>useMemo</code>.</p> a. React.memob. useMemo <p>Prevent unnecessary re-renders.</p> <pre><code>const MyComponent = React.memo(({ value }) =&gt; {\n    console.log('Rendered');\n    return &lt;div&gt;{value}&lt;/div&gt;;\n});\n</code></pre> <p>Memoize expensive calculations.</p> <pre><code>import { useMemo } from 'react';\n\nconst ExpensiveComponent = ({ num }) =&gt; {\n    const computedValue = useMemo(() =&gt; {\n        // Expensive calculation\n        return num * 2;\n    }, [num]);\n\n    return &lt;div&gt;{computedValue}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#6-rendering-lists","title":"6. Rendering Lists","text":"<p>Render dynamic lists efficiently.</p> <pre><code>const ItemList = ({ items }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {items.map(item =&gt; (\n        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#7-render-props","title":"7. Render Props","text":"<p>This pattern involves passing a function as a prop to a component, allowing for more flexible and reusable components.</p> <pre><code>const RenderPropComponent = ({ render }) =&gt; {\n  return &lt;div&gt;{render()}&lt;/div&gt;;\n};\n\n// Usage\n&lt;RenderPropComponent render={() =&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;} /&gt;;\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#conclusion","title":"Conclusion","text":"<p>Using functional patterns and techniques in React can lead to cleaner, more maintainable code. Embrace hooks, context, and optimization strategies to enhance your React applications!</p>"},{"location":"reactPattern/functional-updated-pattern/","title":"Functional Update Pattern","text":"<p>Understanding the Functional Update Pattern in React: Techniques and Related Patterns</p>"},{"location":"reactPattern/functional-updated-pattern/#functional-update-pattern","title":"Functional Update Pattern","text":"<p>Definition</p> <p>The Functional Update Pattern is a technique used in React to update state based on the previous state. This is particularly useful in scenarios where state updates are dependent on the current state value, ensuring that updates are not lost due to asynchronous behavior.</p> <p>Usage</p> <p>You typically use this pattern with the <code>setState</code> function from the <code>useState</code> hook, or in class components with <code>this.setState</code>.</p> <p>Example</p> <p>Using <code>useState</code></p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount(prevCount =&gt; prevCount + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Benefits</p> <ul> <li>Avoid Race Conditions: By using the previous state as an input for the new state, you avoid issues that can arise from multiple updates occurring in quick succession.</li> </ul>"},{"location":"reactPattern/functional-updated-pattern/#related-patterns","title":"Related Patterns","text":"<ol> <li> <p>Callback Functions with State</p> <ul> <li>Similar to the Functional Update Pattern, you can provide a function to <code>setState</code> that takes the previous state and returns the new state.</li> </ul> <pre><code>const toggle = () =&gt; {\n    setIsActive(prev =&gt; !prev);\n};\n</code></pre> </li> <li> <p>Reducer Pattern</p> <ul> <li> <p>Using <code>useReducer</code> for more complex state management. This pattern involves defining a reducer function that updates state based on actions.</p> <pre><code>const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n\nconst Counter = () =&gt; {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        &lt;div&gt;\n            Count: {state.count}\n            &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;+&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;-&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> </li> </ul> </li> <li> <p>Controlled <code>vs.</code> Uncontrolled Components</p> <ul> <li>Controlled components manage their own state, while uncontrolled components rely on the DOM for state. Controlled components often use the Functional Update Pattern for form inputs.</li> </ul> <pre><code>const ControlledInput = () =&gt; {\n    const [value, setValue] = useState('');\n\n    return (\n        &lt;input\n            value={value}\n            onChange={e =&gt; setValue(e.target.value)}\n        /&gt;\n    );\n};\n</code></pre> </li> <li> <p>Context API with Functional Updates</p> <ul> <li> <p>When using the Context API, you can employ the Functional Update Pattern to manage global state efficiently.</p> <pre><code>const MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [state, setState] = useState({ count: 0 });\n\n    const increment = () =&gt; {\n        setState(prevState =&gt; ({ count: prevState.count + 1 }));\n    };\n\n    return (\n        &lt;MyContext.Provider value={{ state, increment }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"reactPattern/functional-updated-pattern/#conclusion","title":"Conclusion","text":"<p>The Functional Update Pattern is a key technique in React for managing state updates that depend on previous state values. It promotes better state management and prevents common pitfalls associated with asynchronous updates. Other patterns, like using reducers and the Context API, can complement this approach for more complex applications.</p>"},{"location":"reactPattern/when-not-to-use-functional-update/","title":"When not to use Functional Update","text":"<p>Certainly! Here are some guidelines on when to use the Functional Update Pattern in React, as well as situations where it may not be necessary:</p>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-to-use-the-functional-update-pattern","title":"When to Use the Functional Update Pattern","text":"<ol> <li> <p>Dependent State Updates:</p> <ul> <li> <p>Use it when the new state depends on the previous state. This is especially important in cases where state updates may be batched or occur asynchronously.</p> <pre><code>setCount(prevCount =&gt; prevCount + 1);\n</code></pre> </li> </ul> </li> <li> <p>Multiple Updates in Quick Succession:</p> <ul> <li>If you have multiple state updates that rely on the current value (e.g., in event handlers), the Functional Update Pattern helps prevent race conditions.</li> </ul> <pre><code>const handleMultipleClicks = () =&gt; {\n    setCount(prev =&gt; prev + 1);\n    setCount(prev =&gt; prev + 1); // Both updates are based on the latest state\n};\n</code></pre> </li> <li> <p>Complex State Logic:</p> <p>When managing complex state transitions that might involve conditions, using a function to handle state updates can improve clarity.</p> <pre><code>setState(prevState =&gt; {\n    // complex logic based on prevState\n});\n</code></pre> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-not-to-use-the-functional-update-pattern","title":"When Not to Use the Functional Update Pattern","text":"<ol> <li> <p>Simple Static Updates:</p> <ul> <li> <p>If you're setting state to a constant value or not relying on the previous state, using the Functional Update Pattern is unnecessary.</p> <pre><code>setCount(10); // Direct assignment is simpler here\n</code></pre> </li> </ul> </li> <li> <p>No Dependency on Previous State:</p> <ul> <li>If the new state does not depend on the current state (e.g., setting a fixed value or fetching new data), you can set the state directly.</li> </ul> </li> <li> <p>Performance Concerns:</p> <ul> <li>In rare cases, excessive use of functional updates may introduce unnecessary complexity or performance overhead if not needed. However, this is generally not a significant concern.</li> </ul> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#summary","title":"Summary","text":"<ul> <li>Use the Functional Update Pattern when state updates depend on previous values, especially in situations with multiple rapid updates.</li> <li>Avoid it for simple or static updates where the current state is not relevant.</li> </ul> <p>This approach helps maintain clarity and prevents bugs in your React applications!</p>"},{"location":"state-management/","title":"Intro","text":"<p>state</p>"},{"location":"state-management/immer/example/","title":"Example","text":""},{"location":"state-management/immer/example/#refactored-with-immer","title":"Refactored with Immer","text":"<p>Your <code>profileReducer</code> is structured well for handling gender-related actions in a Redux store. However, if you want to refactor it using Immer for better readability and reduced boilerplate, here\u2019s how you could do it:</p> Standard ReduxImmer ExampleKey ChangesBenefits of This ApproachInstallation <pre><code>export default function profileReducer(state = INITIAL_STATE, action) {\n    switch (action.type) {\n        // gender list\n        case PROFILE_TYPES.GET_GENDER_INIT:\n            return {\n                ...state,\n                genders: [],\n                gendersLoading: true,\n            };\n        case PROFILE_TYPES.GET_GENDER_SUCCESS:\n            // console.log(\"gendersssss\", action.payload);\n            return {\n                ...state,\n                genders: action.payload,\n                gendersLoading: false,\n            };\n        case PROFILE_TYPES.GET_GENDER_FINISH:\n            return {\n                ...state,\n                gendersLoading: false,\n            };\n\n        default:\n            return {\n                ...state,\n            };\n}\n</code></pre> <p>Then, you can refactor your reducer like this:</p> <pre><code>import produce from \"immer\";\nimport { PROFILE_TYPES } from \"./actionTypes\"; // Adjust the import based on your project structure\n\nconst INITIAL_STATE = {\n    genders: [],\n    gendersLoading: false,\n};\n\nconst profileReducer = produce((draft, action) =&gt; {\n    switch (action.type) {\n        case PROFILE_TYPES.GET_GENDER_INIT:\n            draft.genders = [];\n            draft.gendersLoading = true;\n            break;\n        case PROFILE_TYPES.GET_GENDER_SUCCESS:\n            draft.genders = action.payload;\n            draft.gendersLoading = false;\n            break;\n        case PROFILE_TYPES.GET_GENDER_FINISH:\n            draft.gendersLoading = false;\n            break;\n        default:\n            // No need to modify the draft if the action type is unknown\n            break;\n    }\n}, INITIAL_STATE);\n\nexport default profileReducer;\n</code></pre> <ol> <li> <p>Using <code>produce</code>:</p> <p>The reducer is wrapped in <code>produce</code>, which allows you to mutate the <code>draft</code> state directly. This eliminates the need to use the spread operator (<code>...</code>) for state updates.</p> </li> <li> <p>Direct Mutation:</p> <p>You directly set properties on the <code>draft</code>, making the code cleaner and more straightforward.</p> </li> <li> <p>Default Case:</p> <p>In the default case, you don\u2019t need to return the state since it remains unchanged.</p> </li> </ol> <ul> <li>Readability: The intent of each case is clearer, as you can see direct assignments without boilerplate.</li> <li>Less Error-Prone: Mutating the <code>draft</code> reduces the risk of mistakes related to immutability, especially in more complex state updates.</li> </ul> <p>First, ensure you have Immer installed:</p> <pre><code>npm install immer\n</code></pre> <p>Conclusion</p> <p>Using Immer in your Redux reducer can simplify your code while still adhering to best practices. If you have a larger codebase, this approach can help maintain readability and reduce boilerplate across multiple reducers.</p>"},{"location":"state-management/immer/example/#return","title":"Return","text":"<p>When using Immer, you don\u2019t need to explicitly return the draft state because Immer automatically handles returning the new state for you. The <code>produce</code> function creates a new state based on the changes you make to the <code>draft</code>.</p> How It WorksExample <p>Here's a quick overview:</p> <ul> <li>Draft Mutability: Inside the <code>produce</code> function, you can mutate the <code>draft</code> as if it were mutable. Immer tracks these changes.</li> <li>Automatic Return: After the function completes, Immer produces a new immutable state object based on the modifications you made to the <code>draft</code>.</li> </ul> <p>Here\u2019s your refactored reducer again for clarity:</p> <pre><code>import produce from \"immer\";\nimport { PROFILE_TYPES } from \"./actionTypes\";\n\nconst INITIAL_STATE = {\n    questionTypeGetResponse: {\n        items: [],\n    },\n    questionTypeAddResponse: null,\n    questionTypeAddLoading: false,\n};\n\nconst profileReducer = produce((draft, action) =&gt; {\n    switch (action.type) {\n        case PROFILE_TYPES.QUESTION_TYPE_ADD_SUCCESS:\n            const { id } = action.payload;\n\n            const existingItemIndex = draft.questionTypeGetResponse.items.findIndex(\n                (item) =&gt; item.id === id\n            );\n\n            if (existingItemIndex !== -1) {\n                draft.questionTypeGetResponse.items[existingItemIndex] = action.payload;\n            } else {\n                draft.questionTypeGetResponse.items.push(action.payload);\n            }\n\n            draft.questionTypeGetResponse.items =\n                draft.questionTypeGetResponse.items.filter(\n                (item) =&gt; item.isActive !== false\n                );\n\n            draft.questionTypeAddResponse = action.payload;\n            draft.questionTypeAddLoading = false;\n            break;\n\n        default:\n            break;\n    }\n}, INITIAL_STATE);\n\nexport default profileReducer;\n</code></pre> <p>Conclusion</p> <p>In summary, you don't need a <code>return</code> statement in an Immer reducer because Immer takes care of returning the new state for you after the <code>produce</code> function executes. This makes the code cleaner and focuses more on the logic of state changes.</p>"},{"location":"state-management/immer/example/#return-statement-is-not-neccessary-in-immer","title":"Return statement is not neccessary in immer","text":"<p>Yes, you can use a <code>return</code> statement inside the <code>produce</code> function, but it's not necessary or typical. When using Immer, the <code>produce</code> function automatically returns the new state based on the changes made to the <code>draft</code>. However, if you prefer to make it explicit, you can return the <code>draft</code> at the end of your function.</p> Example with Return StatementConsiderations <p>Here\u2019s how it would look if you include a return statement:</p> <pre><code>import produce from \"immer\";\nimport { PROFILE_TYPES } from \"./actionTypes\";\n\nconst INITIAL_STATE = {\n    questionTypeGetResponse: {\n        items: [],\n    },\n    questionTypeAddResponse: null,\n    questionTypeAddLoading: false,\n};\n\nconst profileReducer = produce((draft, action) =&gt; {\n    switch (action.type) {\n        case PROFILE_TYPES.QUESTION_TYPE_ADD_SUCCESS:\n            const { id } = action.payload;\n\n            const existingItemIndex = draft.questionTypeGetResponse.items.findIndex(\n                (item) =&gt; item.id === id\n            );\n\n            if (existingItemIndex !== -1) {\n                draft.questionTypeGetResponse.items[existingItemIndex] = action.payload;\n            } else {\n                draft.questionTypeGetResponse.items.push(action.payload);\n            }\n\n            draft.questionTypeGetResponse.items =\n                draft.questionTypeGetResponse.items.filter(\n                (item) =&gt; item.isActive !== false\n                );\n\n            draft.questionTypeAddResponse = action.payload;\n            draft.questionTypeAddLoading = false;\n\n            return draft; // Explicitly returning the draft\n        default:\n            return draft; // This line is actually not necessary\n    }\n}, INITIAL_STATE);\n\nexport default profileReducer;\n</code></pre> <ul> <li> <p>Redundancy: While you can return the <code>draft</code>, it\u2019s generally not required. The <code>produce</code> function will automatically return the new state without an explicit return.</p> </li> <li> <p>Clarity: Some developers may prefer to include a return for clarity, especially in complex reducers where the logic is more involved. However, it\u2019s mostly a matter of style.</p> </li> <li> <p>Default Case: In the default case, if you return <code>draft</code>, it would be the same as not returning anything because <code>draft</code> remains unchanged.</p> </li> </ul> <p>Conclusion</p> <p>While you can use <code>return</code> in an Immer reducer, it's not necessary since Immer handles state returns automatically. Whether to include it is up to personal or team preference, but the common practice is to omit the return statement for cleaner code.</p>"},{"location":"state-management/immer/with-and-without-immer/","title":"With and Without Immer","text":"<p>Using Immer in reducers simplifies the handling of immutable state by allowing you to write \"mutable\" code that actually produces an immutable update. Here\u2019s a comparison of using Immer versus not using it in Redux reducers:</p> Without ImmerWith ImmerKey Differences <p>When you manage state immutably without Immer, you typically have to create new copies of the state for any updates. This often involves using methods like <code>Object.assign</code>, the <code>spread operator</code>, or libraries like <code>immutable.js</code>. Here\u2019s an example:</p> <p>Example Reducer without Immer</p> <pre><code>const initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case FETCH_DATA_REQUEST:\n            return {\n                ...state,\n                loading: true,\n                error: null,\n            };\n        case FETCH_DATA_SUCCESS:\n            return {\n                ...state,\n                loading: false,\n                data: action.payload,\n            };\n        case FETCH_DATA_FAILURE:\n            return {\n                ...state,\n                loading: false,\n                error: action.payload,\n            };\n        default:\n            return state;\n    }\n};\n</code></pre> <p>Using Immer allows you to write code as if you're directly mutating the state, but it actually creates a new immutable state under the hood. This leads to cleaner, more readable code. Here\u2019s the same example using Immer:</p> <p>Example Reducer with Immer</p> <pre><code>import produce from 'immer';\n\nconst initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt;\n    produce(state, (draft) =&gt; {\n        switch (action.type) {\n            case FETCH_DATA_REQUEST:\n                draft.loading = true;\n                draft.error = null;\n                break;\n            case FETCH_DATA_SUCCESS:\n                draft.loading = false;\n                draft.data = action.payload;\n                break;\n            case FETCH_DATA_FAILURE:\n                draft.loading = false;\n                draft.error = action.payload;\n                break;\n            default:\n                break;\n        }\n    });\n</code></pre> <ol> <li> <p>Readability:</p> <ul> <li>Without Immer: You need to create a new object every time, which can make the code more verbose and harder to read.</li> <li>With Immer: You write more straightforward code, directly modifying the draft, which looks cleaner.</li> </ul> </li> <li> <p>Boilerplate:</p> <ul> <li>Without Immer: More boilerplate code is often necessary for cloning state and merging changes.</li> <li>With Immer: Less boilerplate, as Immer handles the immutability for you.</li> </ul> </li> <li> <p>Error-Prone:</p> <ul> <li>Without Immer: It's easy to forget to spread the previous state or create a new object, leading to bugs.</li> <li>With Immer: The risk of mutating the original state is eliminated, as Immer manages this automatically.</li> </ul> </li> <li> <p>Performance:</p> <ul> <li>Without Immer: Depending on how state is updated, performance can be affected by excessive copying of state.</li> <li>With Immer: Immer optimizes performance by tracking changes and only producing a new state for modified parts.</li> </ul> </li> <li> <p>Learning Curve:</p> <ul> <li>Without Immer: Familiarity with functional programming concepts and immutability patterns is required.</li> <li>With Immer: Easier for those coming from mutable programming backgrounds since it allows a more intuitive way to write reducers.</li> </ul> </li> </ol>"},{"location":"state-management/immer/with-and-without-immer/#summary","title":"Summary","text":"<p>Using Immer can significantly streamline your Redux reducers, making them easier to read and maintain while ensuring immutability. If your application has complex state updates, Immer can be particularly beneficial. However, for simple cases, the traditional approach may suffice.</p>"},{"location":"state-management/immer/with-and-without-immer/#additional","title":"Additional","text":"<p>Sure! Let\u2019s break it down in a simple and detailed way.</p>"},{"location":"state-management/immer/with-and-without-immer/#the-concept-of-immutability","title":"The Concept of Immutability","text":"<p>Immutability means that once you create an object (like your state in Redux), you cannot change it. Instead, when you want to update it, you create a new object with the new values. This helps prevent unexpected changes and makes it easier to track state changes.</p> Without ImmerWith Immer <p>When you write a reducer without Immer, you have to manually create new copies of the state every time you want to update it. Here\u2019s a step-by-step explanation:</p> <ol> <li> <p>Copying State: Each time an action occurs, you make a copy of the current state and change only the part you want. This requires using spread operators or functions like <code>Object.assign</code>.</p> </li> <li> <p>Example:</p> <pre><code>const initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'FETCH_DATA_REQUEST':\n            return {\n                ...state, // Copy the existing state\n                loading: true, // Update loading\n                error: null, // Reset error\n            };\n        // More cases...\n        default:\n            return state; // Return unchanged state\n    }\n};\n</code></pre> <pre><code>// reducer.js\n\nconst initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt; {\n    switch (action.type) {\n        case 'FETCH_DATA_REQUEST':\n            return {\n                ...state, // Copy the existing state\n                loading: true, // Update loading\n                error: null, // Reset error\n            };\n        case 'FETCH_DATA_SUCCESS':\n            return {\n                ...state, // Copy the existing state\n                loading: false, // Update loading\n                data: action.payload, // Set the fetched data\n            };\n        case 'FETCH_DATA_FAILURE':\n            return {\n                ...state, // Copy the existing state\n                loading: false, // Update loading\n                error: action.payload, // Set the error message\n            };\n        default:\n            return state; // Return unchanged state\n    }\n};\n\nexport default dataReducer;\n</code></pre> </li> <li> <p>Challenges:</p> <ul> <li>Verbose: You need to write a lot of code to handle updates.</li> <li>Error-Prone: It\u2019s easy to forget to spread the state or accidentally mutate the original state.</li> <li>More Boilerplate: Each action requires more lines of code for updates.</li> </ul> </li> </ol> <p>Immer simplifies this process by allowing you to \"mutate\" a draft state directly while it ensures immutability behind the scenes.</p> <ol> <li> <p>Draft State: When you call the <code>produce</code> function from Immer, it gives you a draft copy of your state that you can modify directly.</p> </li> <li> <p>Example:</p> <pre><code>import produce from 'immer';\n\nconst initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt;\n    produce(state, (draft) =&gt; {\n        switch (action.type) {\n            case 'FETCH_DATA_REQUEST':\n                draft.loading = true; // Directly modify the draft\n                draft.error = null; // Directly modify the draft\n                break;\n            // More cases...\n            default:\n                break; // No change for default\n        }\n    });\n</code></pre> <pre><code>// reducer.js\nimport produce from 'immer';\nimport { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './action';\n\nconst initialState = {\n    loading: false,\n    data: null,\n    error: null,\n};\n\nconst dataReducer = (state = initialState, action) =&gt;\n    produce(state, (draft) =&gt; {\n        switch (action.type) {\n            case FETCH_DATA_REQUEST:\n                draft.loading = true;\n                draft.error = null;\n                break;\n            case FETCH_DATA_SUCCESS:\n                draft.loading = false;\n                draft.data = action.payload;\n                break;\n            case FETCH_DATA_FAILURE:\n                draft.loading = false;\n                draft.error = action.payload;\n                break;\n            default:\n                break; // No change for default\n        }\n    });\n\nexport default dataReducer;\n</code></pre> </li> <li> <p>Benefits:</p> <ul> <li>Less Code: You write less code because you directly change the draft.</li> <li>Easier to Read: It\u2019s clearer and more straightforward to see what\u2019s being updated.</li> <li>No Risk of Mutation: Immer takes care of ensuring that the original state isn\u2019t modified.</li> </ul> </li> </ol> <p>Summary of Differences</p> Feature Without Immer With Immer Code Style More verbose, requires copying state Cleaner, direct modifications Ease of Use More complicated; error-prone Intuitive and straightforward Boilerplate More boilerplate for updates Less boilerplate Safety Risk of accidental mutations Guarantees immutability Readability Harder to read and follow Easier to understand <p>Conclusion</p> <p>Using Immer in your Redux reducers helps you write cleaner, safer, and more maintainable code. It allows you to focus on what you want to change without worrying about immutability rules. This makes it especially useful in applications with complex state updates.</p>"},{"location":"state-management/zustand/intro/","title":"Intro","text":"<p>Zustand is a small, fast state management library for React that provides a simple API for managing state.</p> Installation <pre><code>npm install zustand\n</code></pre> <p>Zustand is a lightweight state management library for React that emphasizes simplicity and minimalism. Its main philosophy revolves around providing a straightforward API for managing state without the boilerplate typically associated with other state management solutions.</p> Additional Features <p>Zustand also supports:</p> <ul> <li>Middleware for logging and persistence.</li> <li>Selectors for more efficient state access.</li> <li>Devtools for debugging.</li> </ul> <p>Here\u2019s a breakdown of what makes Zustand unique and how it differs from Redux:</p> Main Philosophy of ZustandKey Differences from Redux <ol> <li>Simplicity: Zustand aims to provide an intuitive and minimalistic approach to state management, allowing developers to create and manage state with very little setup.</li> <li>Direct Access to State: Zustand allows components to directly access and manipulate state, making it easy to use and understand.</li> <li>No Boilerplate: Unlike Redux, Zustand does not require extensive boilerplate code or complex setups (like action types, reducers, etc.).</li> <li>Flexibility: Zustand supports both global and local state management, making it adaptable to various use cases.</li> </ol> <ol> <li> <p>Setup and Configuration:</p> <ul> <li>Zustand: Requires minimal setup. You define a store and can use it directly in your components.</li> <li>Redux: Involves more boilerplate, including actions, reducers, and middleware setup.</li> </ul> </li> <li> <p>API Design:</p> <ul> <li>Zustand: Provides a simple hook-based API. You can create a store and consume it using hooks with minimal syntax.</li> <li>Redux: Uses a more complex API that involves dispatching actions to update state.</li> </ul> </li> <li> <p>Performance:</p> <ul> <li>Zustand: Updates components selectively based on the parts of the state they subscribe to, which can lead to more efficient re-renders.</li> <li>Redux: Typically updates all connected components on state change unless optimizations (like <code>useSelector</code>) are used.</li> </ul> </li> <li> <p>Middleware:</p> <ul> <li>Zustand: Supports middleware but doesn\u2019t enforce it. You can use it as needed (e.g., for logging or persisting state).</li> <li>Redux: Middleware is a core part of its architecture for handling side effects (like Redux Thunk or Saga).</li> </ul> </li> <li> <p>DevTools Integration:</p> <ul> <li>Zustand: Offers a simpler integration for devtools without needing a complex setup.</li> <li>Redux: Has a more robust and established devtools ecosystem, which provides extensive debugging capabilities.</li> </ul> </li> <li> <p>Community and Ecosystem:</p> <ul> <li>Zustand: A newer library with a smaller but growing community. It\u2019s designed to work well within React but may not have as extensive an ecosystem as Redux.</li> <li>Redux: Has a larger community and a rich ecosystem of middleware, libraries, and tools due to its longer presence in the React ecosystem.</li> </ul> </li> </ol> <p>Summary</p> <p>Zustand is designed for developers who want a straightforward, flexible, and efficient way to manage state in React applications without the complexity and boilerplate often associated with libraries like Redux. It\u2019s particularly useful for small to medium-sized applications or scenarios where quick state management is needed.</p>"},{"location":"state-management/zustand/intro/#suggested-folder-structure","title":"Suggested Folder Structure","text":"<p>Creating a modular, reusable, and scalable folder structure for a Zustand-based React application is important for maintainability and organization.</p> <p>Here\u2019s a suggested folder structure and some practices to achieve these goals:</p> <pre><code>/src\n\u2502\n\u251c\u2500\u2500 /components          # Reusable UI components\n\u2502   \u251c\u2500\u2500 Button.jsx\n\u2502   \u251c\u2500\u2500 Counter.jsx\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /hooks               # Custom hooks for reusable logic\n\u2502   \u251c\u2500\u2500 useCounter.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /stores              # Zustand stores\n\u2502   \u251c\u2500\u2500 counterStore.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /contexts            # (Optional) React Context for global state\n\u2502   \u2514\u2500\u2500 AppContext.js\n\u2502\n\u251c\u2500\u2500 /utils               # Utility functions\n\u2502   \u251c\u2500\u2500 api.js\n\u2502   \u2514\u2500\u2500 helpers.js\n\u2502\n\u251c\u2500\u2500 /styles              # Global styles or component styles\n\u2502   \u251c\u2500\u2500 App.css\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /pages               # Page components (for routing)\n\u2502   \u251c\u2500\u2500 HomePage.jsx\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 App.jsx              # Main application component\n\u2514\u2500\u2500 index.js             # Entry point\n</code></pre>"},{"location":"state-management/zustand/intro/#login","title":"Login","text":"<p>You can integrate Ant Design (antd) components to create a more polished login form using Zustand for state management.</p> authStore.jsAuth.jsApp.js <pre><code>// stores/authStore.js\nimport create from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\nconst useAuthStore = create(\n    persist((set) =&gt; ({\n        token: null,\n        user: null,\n        login: async (username, password) =&gt; {\n            try {\n                const response = await fetch(\"https://api.example.com/login\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({ username, password }),\n                });\n\n                if (!response.ok) throw new Error(\"Login failed\");\n\n                const data = await response.json();\n                set({ token: data.token, user: data.user });\n            } catch (error) {\n                console.error(error);\n                set({ error: error.message });\n            }\n        },\n        logout: () =&gt; {\n            set({ token: null, user: null });\n        },\n    }),\n    {\n        name: \"auth-storage\", // Unique name for local storage\n    })\n);\n\nexport default useAuthStore;\n</code></pre> <pre><code>// components/Auth.js\nimport React, { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport useAuthStore from '../stores/authStore';\n\nconst Auth = () =&gt; {\n    const { token, user, login, logout } = useAuthStore();\n    const [loading, setLoading] = useState(false);\n\n    const handleLogin = async (values) =&gt; {\n        setLoading(true);\n        await login(values.username, values.password);\n        setLoading(false);\n        if (token) {\n            message.success('Login successful!');\n        } else {\n            message.error('Login failed. Please check your credentials.');\n        }\n    };\n\n    const handleLogout = () =&gt; {\n        logout();\n        message.success('Logged out successfully!');\n    };\n\n    return (\n        &lt;div style={{ maxWidth: '300px', margin: 'auto' }}&gt;\n            {token ? (\n                &lt;div&gt;\n                    &lt;h1&gt;Welcome, {user?.name}!&lt;/h1&gt;\n                    &lt;Button type=\"primary\" onClick={handleLogout}&gt;\n                        Logout\n                    &lt;/Button&gt;\n                &lt;/div&gt;\n            ) : (\n                &lt;Form onFinish={handleLogin}&gt;\n                    &lt;Form.Item\n                        name=\"username\"\n                        rules={[{ required: true, message: 'Please input your username!' }]}\n                    &gt;\n                        &lt;Input placeholder=\"Username\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item\n                        name=\"password\"\n                        rules={[{ required: true, message: 'Please input your password!' }]}\n                    &gt;\n                        &lt;Input.Password placeholder=\"Password\" /&gt;\n                    &lt;/Form.Item&gt;\n                    &lt;Form.Item&gt;\n                        &lt;Button type=\"primary\" htmlType=\"submit\" loading={loading}&gt;\n                        Login\n                        &lt;/Button&gt;\n                    &lt;/Form.Item&gt;\n                &lt;/Form&gt;\n            )}\n        &lt;/div&gt;\n    );\n};\n\nexport default Auth;\n</code></pre> <pre><code>// App.js\nimport React from \"react\";\nimport \"antd/dist/antd.css\"; // Import Ant Design styles\nimport Auth from \"./components/Auth\";\n\nconst App = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1 style={{ textAlign: \"center\" }}&gt;\n                Authentication with Ant Design and Zustand\n            &lt;/h1&gt;\n            &lt;Auth /&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default App;\n</code></pre> Important Considerations <ul> <li>API Integration: Ensure the API endpoint (<code>https://api.example.com/login</code>) matches your backend setup.</li> <li>Error Handling: The error message handling is basic; you can expand this to display more detailed error messages as needed.</li> <li>Security: As always, be cautious with user credentials and API tokens.</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Index","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""}]}