{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#javascript-compiler","title":"JavaScript Compiler","text":"<p>programiz.com/javascript/online-compiler/</p>"},{"location":"auth/intro/","title":"Intro","text":"<p>auth</p>"},{"location":"auth/not-found-component/","title":"Not Found","text":"<p>Here\u2019s an example of how you might implement a simple <code>NotFound</code> component to be used with a catch-all route in React Router v6.</p>"},{"location":"auth/not-found-component/#example","title":"Example","text":"NotFound ComponentUsage in Your RoutesExplanation <pre><code>import React from 'react';\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: 'center', marginTop: '50px' }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>You can then use this <code>NotFound</code> component in your routing setup like this:</p> <pre><code>import React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport About from './About'; // Your About component\nimport Home from './Home';   // Your Home component\nimport NotFound from './NotFound'; // Your NotFound component\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <ul> <li>NotFound Component: This component simply displays a message and provides a link to return to the homepage.</li> <li>Catch-All Route: The <code>path=\"*\"</code> route captures any undefined paths and renders the <code>NotFound</code> component, ensuring users have feedback when they navigate to a nonexistent route.</li> </ul> <p>This setup provides a user-friendly experience by guiding users back to valid pages!</p>"},{"location":"auth/not-found-component/#folder-struture","title":"Folder Struture","text":"<p>Here\u2019s a suggested folder structure for a React application that includes a NotFound component. This structure promotes organization and scalability:</p> Suggested Folder StructureExplanation of Structure <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u2514\u2500\u2500 NotFound.jsx   // Store your NotFound component here\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages             // Optional: for more complex structures\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles            // Optional: for CSS or styled components\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>/public</code>: Contains static assets and the main HTML file.</li> <li><code>/src</code>: Main source folder for your application.<ul> <li><code>/components</code>: This folder holds your React components, including the <code>NotFound</code> component.</li> <li><code>/pages</code>: (Optional) Useful if you want to separate different pages of your app into their own components, enhancing organization.</li> <li><code>/styles</code>: (Optional) Store your CSS or styled components here.</li> <li><code>App.jsx</code>: The main application file where you can set up your routes.</li> <li><code>index.js</code>: The entry point of your React application.</li> </ul> </li> </ul> <p>By organizing your components this way, you can easily manage and locate your files as your application grows!</p>"},{"location":"auth/not-found-component/#advanced","title":"Advanced","text":"<p>Here\u2019s a more advanced example of a React application that uses the <code>NotFound</code> component along with several routes, including nested routes, dynamic routing, and a simple layout.</p> <p>Folder Structure</p> <pre><code>/my-react-app\n\u2502\n\u251c\u2500\u2500 /public\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 /src\n\u2502   \u251c\u2500\u2500 /components\n\u2502   \u2502   \u251c\u2500\u2500 About.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Home.jsx\n\u2502   \u2502   \u251c\u2500\u2500 NotFound.jsx\n\u2502   \u2502   \u251c\u2500\u2500 Navbar.jsx\n\u2502   \u2502   \u2514\u2500\u2500 UserProfile.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /pages\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.jsx\n\u2502   \u2502   \u2514\u2500\u2500 HomePage.jsx\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 /styles\n\u2502   \u2502   \u2514\u2500\u2500 App.css\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 App.jsx\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Example</p> index.jsApp.jsxNavbar.jsxHomePage.jsxAboutPage.jsxUserProfile.jsxNotFound.jsx <pre><code>import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./styles/App.css\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport HomePage from \"./pages/HomePage\";\nimport AboutPage from \"./pages/AboutPage\";\nimport NotFound from \"./components/NotFound\";\nimport Navbar from \"./components/Navbar\";\n\nconst App = () =&gt; {\n    return (\n        &lt;Router&gt;\n            &lt;Navbar /&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt;\n                &lt;Route path=\"/user/:id\" element={&lt;UserProfile /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt; {/* Catch-all route */}\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n};\n\nexport default App;\n</code></pre> <pre><code>import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1 Profile&lt;/Link&gt;\n            &lt;Link to=\"/user/2\"&gt;User 2 Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <pre><code>import React from \"react\";\n\nconst HomePage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default HomePage;\n</code></pre> <pre><code>import React from \"react\";\n\nconst AboutPage = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;About Us&lt;/h1&gt;\n            &lt;p&gt;This is the about page.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default AboutPage;\n</code></pre> <pre><code>import React from \"react\";\nimport { useParams } from \"react-router-dom\";\n\nconst UserProfile = () =&gt; {\n    const { id } = useParams();\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;User Profile&lt;/h1&gt;\n            &lt;p&gt;Displaying profile for user ID: {id}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default UserProfile;\n</code></pre> <pre><code>import React from \"react\";\n\nconst NotFound = () =&gt; {\n    return (\n        &lt;div style={{ textAlign: \"center\", marginTop: \"50px\" }}&gt;\n            &lt;h1&gt;404 - Page Not Found&lt;/h1&gt;\n            &lt;p&gt;Sorry, the page you are looking for does not exist.&lt;/p&gt;\n            &lt;a href=\"/\"&gt;Go to Homepage&lt;/a&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default NotFound;\n</code></pre> <p>Explanation</p> <ol> <li>Routing Setup: The <code>App</code> component uses <code>BrowserRouter</code> to wrap the application and Routes to define paths.</li> <li>Dynamic Routing: The <code>UserProfile</code> component uses <code>useParams</code> to extract the user ID from the URL.</li> <li>Catch-All Route: The route <code>path=\"*\"</code> ensures that any undefined paths render the <code>NotFound</code> component.</li> <li>Navigation: The <code>Navbar</code> component provides links to navigate between the home page, about page, and user profiles.</li> </ol> <p>This setup showcases a more advanced application structure with routing, making it easier to manage and expand as your application grows!</p>"},{"location":"auth/react-router/","title":"React Router","text":"<p>React Router is a library that enables routing in React applications. It allows you to create single-page applications with navigation and different views without reloading the page. With React Router, you can define routes in your app, manage navigation, and render specific components based on the current URL.</p> <p>Since you've created a React app using npx create-react-app, you'll need to install React Router separately, as it's not included by default. You can install it using npm:</p> <pre><code>npm install react-router-dom\n</code></pre>"},{"location":"auth/react-router/#what-react-router-does","title":"What React Router Does:","text":"<ul> <li>Routing: Maps URLs to components, allowing different components to render based on the current path.</li> <li>Navigation: Provides components like <code>&lt;Link&gt;</code> and <code>&lt;NavLink&gt;</code> for navigation without full page reloads.</li> <li>Dynamic Routing: Supports parameters in routes, enabling you to create dynamic routes based on data.</li> <li>Nested Routes: Allows you to nest routes for better organization of your components.</li> <li>Programmatic Navigation: Offers functionality to navigate programmatically using hooks like <code>useNavigate</code>.</li> </ul> Basic Example <p>Here\u2019s a simple example to illustrate how to use React Router:</p> <ol> <li>Install it (as mentioned above).</li> <li> <p>Create some basic components:</p> <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n</code></pre> </li> <li> <p>Set up routing in your main component (e.g., <code>App.js</code>):</p> <pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\nimport Home from './Home';\nimport About from './About';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/nav&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <p>This example sets up a basic navigation between a home page and an about page. When you click the links, React Router will render the corresponding component without reloading the page.</p> </li> </ol>"},{"location":"auth/router-version/","title":"Version","text":"<ul> <li>React Router v4 - October 2017</li> <li>React Router v5 - February 2019</li> <li>React Router v6 - November 2021</li> <li>React Router v6.4 - June 2022</li> <li>React Router v6.8 - August 2023</li> </ul>"},{"location":"auth/router-version/#major-updates","title":"Major Updates","text":"<p>Here are the major updates from the key React Router versions that you should remember:</p> React Router v4React Router v5React Router v6React Router v6.4React Router v6.8 <ul> <li>Component-based API: Introduced a declarative way to define routes using components.</li> <li>Nested Routes: Allowed for easier management of nested routing.</li> <li> <p>Key Update: Component-based API and Nested Routes</p> Example<pre><code>import { BrowserRouter as Router, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;Route path=\"/about\" component={About} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Hooks: Introduced <code>useParams</code>, <code>useLocation</code>, and other hooks for better access to routing data.</li> <li>Improved Redirects: Added more control over route rendering with props on <code>&lt;Route&gt;</code>.</li> <li> <p>Key Update: Hooks (<code>useParams</code>, <code>useLocation</code>)</p> Example<pre><code>import { BrowserRouter as Router, Route, Link, useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams();\n    return &lt;h2&gt;User ID: {id}&lt;/h2&gt;;\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Route path=\"/user/:id\" component={User} /&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li><code>Routes</code> Component: Replaced <code>Switch</code> for improved route matching.</li> <li>Route Ranking: Enhanced routing logic for better performance.</li> <li>Nested Routes: Simplified nested route definitions.</li> <li> <p>Key Update: <code>Routes</code> Component and Route Ranking</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n        &lt;/nav&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Data APIs: Introduced loaders and actions for handling data fetching directly in routes.</li> <li>Layout Routes: Enhanced support for layouts in nested routes.</li> <li> <p>Key Update: Data APIs (Loaders and Actions)</p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst loader = async () =&gt; {\n    const data = await fetch('/api/data'); // Fetch data\n    return data.json();\n};\n\nconst DataComponent = () =&gt; {\n    // Use data in your component\n};\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul> <ul> <li>Refinements: Continued improvements based on user feedback, focusing on data handling and route management.</li> <li> <p>Key Update: Refinements for improved data handling</p> <p><code>(Similar to v6.4 but with more refined API usage)</code></p> Example<pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/data\" element={&lt;DataComponent /&gt;} loader={loader} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> </li> </ul>"},{"location":"auth/router-version/#additional","title":"Additional","text":"<p>In React Router v6, the <code>Routes</code> component replaced the <code>Switch</code> component from previous versions, and this change brought several improvements in how route matching works. Here\u2019s what it means:</p> <ol> <li> <p>Improved Route Matching</p> <ul> <li>Order of Matching:</li> </ul> <p>With <code>Switch</code>, the first route that matched was rendered, which could lead to issues if more specific routes were placed after more general ones. The new <code>Routes</code> component performs better by automatically ranking routes, meaning it will always match the most specific route first.</p> <ul> <li>Simplified Syntax:</li> </ul> <p><code>Routes</code> allows you to define routes using the <code>element</code> prop directly, making the syntax cleaner and easier to read.</p> Using <code>Switch</code> (v5)Using Routes (v6) <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this example, if you navigate to <code>/</code>, the <code>Home</code> component will render because it's matched first. However, if you had a more specific route, such as <code>/about</code>, it could potentially lead to unexpected behavior if not ordered correctly.</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this version with <code>Routes</code>, it handles matching more efficiently. It automatically prioritizes more specific paths, so you can be confident that the correct component will render based on the current URL.</p> </li> <li> <p>No Need for <code>exact</code></p> <p>In <code>v5</code>, you often had to use the <code>exact</code> prop to ensure that a route only matched when the path was exactly as specified. With <code>Routes</code>, the matching logic is more intuitive, and <code>exact</code> is no longer necessary.</p> </li> </ol> <p>Conclusion</p> <p>Overall, the shift from Switch to Routes in React Router v6 enhances route handling by making it more efficient, reducing potential errors, and simplifying the syntax for developers.</p>"},{"location":"auth/router-version/#route-ordering","title":"Route Ordering","text":""},{"location":"auth/router-version/#before-v6","title":"Before v6","text":"<p>Before React Router v6, specifically in versions 4 and 5, the order of matching was important when using the <code>Switch</code> component. Here's how it worked:</p> Key Points on Order of Matching with Switch <ol> <li> <p>First Match Wins:</p> <ul> <li>The <code>Switch</code> component rendered the first <code>&lt;Route&gt;</code> that matched the current location. This meant that if you had more specific routes after less specific ones, those specific routes would never be reached because the first matching route would take precedence.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>To prevent more general routes from matching, you often had to use the <code>exact</code> prop. This ensured that a route only matched if the path was exactly as specified.</li> </ul> </li> </ol> <p>Example</p> <p>Here's a demonstration of the matching behavior with <code>Switch</code>:</p> Incorrect Order Without <code>exact</code>Correct Order With <code>exact</code> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>If you navigate to <code>/</code>, this setup would render the <code>Home</code> component, and the <code>About</code> route would never be reached because it comes after the <code>/</code> route.</li> </ul> <pre><code>import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ul> <li>In this setup, using exact on the <code>/</code> route means it will only match when the path is exactly <code>/</code>. This allows the <code>/about</code> route to be matched correctly when you navigate to <code>/about</code>.</li> </ul> <p>Conclusion</p> <p>In summary, before v6, the order of routes and the use of the <code>exact</code> prop were crucial for ensuring the correct component rendered based on the URL. With the introduction of <code>Routes</code> in v6, these concerns have largely been alleviated, allowing for more intuitive and error-free routing!</p> <p>Sure! Here\u2019s an example of a React Router setup with multiple routes using Switch in versions 4 or 5. I'll illustrate how to properly order them to ensure the correct components render.</p> <p>Example with Multiple Routes</p> <p>Let\u2019s consider a scenario where we have the following components:</p> <ul> <li><code>Home</code></li> <li><code>About</code></li> <li><code>Contact</code></li> <li><code>AboutDetails</code></li> <li><code>UserProfile</code></li> </ul> ComponentsProper Ordering with <code>Switch</code>Explanation of Route OrderingConclusion <pre><code>// Home.js\nconst Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;\n\n// About.js\nconst About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;\n\n// Contact.js\nconst Contact = () =&gt; &lt;h2&gt;Contact&lt;/h2&gt;;\n\n// AboutDetails.js\nconst AboutDetails = () =&gt; &lt;h2&gt;About Details&lt;/h2&gt;;\n\n// UserProfile.js\nconst UserProfile = () =&gt; &lt;h2&gt;User Profile&lt;/h2&gt;;\n</code></pre> <pre><code>import { BrowserRouter as Router, Switch, Route, Link } from 'react-router-dom';\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;nav&gt;\n            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;Link to=\"/contact\"&gt;Contact&lt;/Link&gt;\n            &lt;Link to=\"/about/details\"&gt;About Details&lt;/Link&gt;\n            &lt;Link to=\"/user/john\"&gt;User Profile&lt;/Link&gt;\n        &lt;/nav&gt;\n\n        &lt;Switch&gt;\n            {/* Specific routes should come first */}\n            &lt;Route path=\"/about/details\" component={AboutDetails} /&gt;\n            &lt;Route path=\"/about\" component={About} /&gt;\n            &lt;Route path=\"/contact\" component={Contact} /&gt;\n            &lt;Route path=\"/user/:username\" component={UserProfile} /&gt;\n\n            {/* This should be the last route to match the root path */}\n            &lt;Route path=\"/\" exact component={Home} /&gt;\n        &lt;/Switch&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <ol> <li> <p>Specific Routes First:</p> <ul> <li>The <code>/about/details</code> route is placed first because it is more specific than the <code>/about</code> route. If you placed <code>/about</code> first, navigating to <code>/about/details</code> would incorrectly render the About component.</li> </ul> </li> <li> <p>General Routes Last:</p> <ul> <li>The root path (<code>/</code>) is placed last. If it were placed earlier, it would match any path and render the <code>Home</code> component, preventing any of the more specific routes from rendering.</li> </ul> </li> <li> <p>Using <code>exact</code>:</p> <ul> <li>The <code>exact</code> prop on the root path (<code>/</code>) ensures it only matches the exact URL <code>/</code>, allowing all other routes to be matched properly without interference.</li> </ul> </li> </ol> <p>This setup demonstrates how to structure and order your routes effectively using the <code>Switch</code> component before React Router v6. Proper ordering is crucial to ensure that the intended components render based on the URL, especially when dealing with multiple routes and nested paths!</p>"},{"location":"auth/router-version/#after-v6","title":"After v6","text":"<p>In React Router v6, you do not need to worry about the order of matching in the same way you did in previous versions with Switch. Here\u2019s why:</p> Automatic Route Ranking <ul> <li> <p>Specificity:</p> <p>React Router v6 automatically ranks routes based on their specificity. This means that it will match the most specific route first, regardless of the order you define them in your <code>Routes</code>.</p> </li> <li> <p>No Need for <code>exact</code>:</p> <p>Unlike in v5, where you often had to use the <code>exact</code> prop to avoid unintentional matches, v6 handles this internally. A route will only match if it corresponds precisely to the current URL.</p> </li> </ul> Example <p>Here\u2019s an example to illustrate this:</p> <pre><code>import { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\n\nconst App = () =&gt; (\n    &lt;Router&gt;\n        &lt;Routes&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about/details\" element={&lt;AboutDetails /&gt;} /&gt;\n        &lt;/Routes&gt;\n    &lt;/Router&gt;\n);\n</code></pre> <p>In this case:</p> <ul> <li>If you navigate to <code>/about/details</code>, it will render the <code>AboutDetails</code> component.</li> <li>If you navigate to <code>/about</code>, it will render the <code>About</code> component.</li> <li>If you navigate to <code>/</code>, it will render the <code>Home</code> component.</li> </ul> <p>Conclusion</p> <p>You can define your routes in any order, and React Router v6 will ensure that the correct component is rendered based on the URL, making it easier to manage your routes without worrying about their sequence. This significantly simplifies routing logic and reduces the potential for errors!</p>"},{"location":"auth/routing/","title":"Routing","text":"<p>Routing logic in web applications defines how different URLs (or paths) correspond to various components or views in the application. In React, this is primarily handled by libraries like react-router-dom.</p> <pre><code>-   Basic Routing\n-   Dynamic Routing\n-   Nested Routes\n-   Redirects\n-   Protected Routes\n-   404 Handling\n-   Lazy Loading\n-   History Management\n-   Custom Hooks for Routing\n-   Route Guards\n</code></pre> Install React Router <p>First, ensure you have <code>react-router-dom</code> installed:</p> <pre><code>npm install react-router-dom\n</code></pre> <p>Here are some key concepts and techniques related to routing logic:</p>"},{"location":"auth/routing/#1-basic-routing","title":"1. Basic Routing","text":"<ul> <li> <p>Single Page Application (SPA): In SPAs, routing is done client-side. The browser loads a single HTML page and JavaScript takes care of changing views without reloading the page.</p> </li> <li> <p>Route Definition: Routes are defined to map URL paths to React components, usually using <code>&lt;Route&gt;</code> components. Each route specifies a <code>path</code> and the corresponding <code>element</code> to render.</p> </li> </ul> AppRoutes.js (Basic Example) <pre><code>import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport Home from '../components/Home/Home';\nimport About from '../components/About/About';\nimport NotFound from '../components/NotFound/NotFound';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n\nexport default AppRoutes;\n</code></pre>"},{"location":"auth/routing/#2-dynamic-routing","title":"2. Dynamic Routing","text":"<ul> <li>Route Parameters: You can create dynamic routes that accept parameters. For example, <code>/user/:id</code> can capture the <code>id</code> of a user, allowing you to render user-specific components based on the URL.</li> </ul> User.js (Dynamic Example) <pre><code>import React from 'react';\nimport { useParams } from 'react-router-dom';\n\nconst User = () =&gt; {\n    const { id } = useParams(); // Fetching dynamic parameter\n    return &lt;h1&gt;User Profile: {id}&lt;/h1&gt;;\n};\n\nexport default User;\n</code></pre>"},{"location":"auth/routing/#3-nested-routes","title":"3. Nested Routes","text":"<ul> <li>Hierarchy: You can have routes within routes, enabling more complex structures. This is useful for layouts where certain components (like a sidebar or header) are always present.</li> </ul> AppRoutes.js (Advanced with Nested Routes) <pre><code>import User from '../components/User/User';\nimport UserProfile from '../components/User/UserProfile';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;}&gt;\n                &lt;Route path=\"profile\" element={&lt;UserProfile /&gt;} /&gt; {/* Nested route */}\n            &lt;/Route&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/routing/#4-redirects","title":"4. Redirects","text":"<ul> <li>Redirecting Users: You can use redirect logic to send users to different paths based on certain conditions, like authentication status or specific URL patterns.</li> </ul> AppRoutes.js (Redirect Example) <p>You can use <code>&lt;Navigate /&gt;</code> for redirects:</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/old-path\" element={&lt;Navigate to=\"/new-path\" replace /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/routing/#5-protected-routes","title":"5. Protected Routes","text":"<ul> <li>Authentication Checks: Certain routes can be protected, requiring users to be authenticated. You can create higher-order components (HOCs) or render logic that checks authentication before allowing access.</li> </ul> AuthContext.jsProtectedRoute.jsAdmin.jsAppRoutes.js <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\nconst AuthContext = createContext();\n\nexport const AuthProvider = ({ children }) =&gt; {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n    const login = () =&gt; setIsAuthenticated(true);\n    const logout = () =&gt; setIsAuthenticated(false);\n\n    return (\n        &lt;AuthContext.Provider value={{ isAuthenticated, login, logout }}&gt;\n            {children}\n        &lt;/AuthContext.Provider&gt;\n    );\n};\n\nexport const useAuth = () =&gt; useContext(AuthContext);\n</code></pre> <pre><code>import React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\n\nconst ProtectedRoute = ({ element }) =&gt; {\n    const { isAuthenticated } = useAuth();\n    return isAuthenticated ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n\nexport default ProtectedRoute;\n</code></pre> <p><code>Admin.js</code> (Protected Route Example)</p> <pre><code>import React from 'react';\n\nconst Admin = () =&gt; {\n    return &lt;h1&gt;Admin Page - Access Restricted&lt;/h1&gt;;\n};\n</code></pre> <p><code>AppRoutes.js</code> (Including Protected Routes)</p> <pre><code>import ProtectedRoute from '../components/ProtectedRoute';\nimport Admin from '../components/Admin/Admin';\n\nconst AppRoutes = () =&gt; {\n    return (\n        &lt;Routes&gt;\n            &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n            &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n            &lt;Route path=\"/admin\" element={&lt;ProtectedRoute element={&lt;Admin /&gt;} /&gt;} /&gt;\n            &lt;Route path=\"/user/:id\" element={&lt;User /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n    );\n};\n</code></pre>"},{"location":"auth/routing/#6-404-not-found-routes","title":"6. 404 Not Found Routes","text":"<ul> <li>Catch-All Route: A route can be defined to catch all unmatched paths, typically rendering a \"Not Found\" component. This helps in providing a better user experience for invalid URLs.</li> </ul> Example <p>This is already covered in the earlier examples, but the wildcard route (<code>path=\"*\"</code>) ensures that any unmatched route renders the <code>NotFound</code> component.</p>"},{"location":"auth/routing/#7-lazy-loading-routes","title":"7. Lazy Loading Routes","text":"<ul> <li>Code Splitting: Use React\u2019s <code>lazy</code> and <code>Suspense</code> to load components only when needed, improving initial load times. This is particularly useful for larger applications with many routes.</li> </ul> User.js (Lazy Loading Example) <p>You can use <code>React.lazy</code> to lazily load components.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nconst UserProfile = lazy(() =&gt; import('./UserProfile'));\n\nconst User = () =&gt; {\n    return (\n        &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n            &lt;UserProfile /&gt;\n        &lt;/Suspense&gt;\n    );\n};\n</code></pre>"},{"location":"auth/routing/#8-history-management","title":"8. History Management","text":"<ul> <li>Browser History: React Router uses the browser's history API to manage navigation. This allows for back and forward navigation without reloading the page.</li> </ul> <p>react-router-dom handles browser history automatically, allowing for back and forward navigation. You can also use <code>useNavigate</code> for programmatic navigation.</p> Example of <code>useNavigate</code> <pre><code>import { useNavigate } from 'react-router-dom';\n\nconst SomeComponent = () =&gt; {\n    const navigate = useNavigate();\n\n    const handleClick = () =&gt; {\n        navigate('/about'); // Programmatically navigate to about\n    };\n\n    return &lt;button onClick={handleClick}&gt;Go to About&lt;/button&gt;;\n};\n</code></pre>"},{"location":"auth/routing/#9-custom-route-logic","title":"9. Custom Route Logic","text":"<ul> <li>Custom Hooks: You can create custom hooks for complex routing logic, like checking user roles or fetching data before rendering a route.</li> </ul> useCurrentPath.js <p>You can create custom hooks to access the current path.</p> <pre><code>import { useLocation } from 'react-router-dom';\n\nconst useCurrentPath = () =&gt; {\n    const location = useLocation();\n    return location.pathname;\n};\n\nexport default useCurrentPath;\n</code></pre>"},{"location":"auth/routing/#10-using-route-guards","title":"10. Using Route Guards","text":"<ul> <li>Authorization Checks: Implement route guards to restrict access to certain components based on user roles or permissions, enhancing security in your application</li> </ul> Custom Guard Example <p>You can create more complex guards using custom logic.</p> <pre><code>import { Navigate } from 'react-router-dom';\n\nconst RoleBasedRoute = ({ element, allowedRoles }) =&gt; {\n    const { userRole } = useAuth(); // Assume you have user roles in context\n    return allowedRoles.includes(userRole) ? element : &lt;Navigate to=\"/\" /&gt;;\n};\n</code></pre> <p>Final Setup in <code>App.js</code></p> App.js<pre><code>import React from \"react\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar/Navbar\";\nimport AppRoutes from \"./routes/AppRoutes\";\nimport { AuthProvider } from \"./context/AuthContext\";\n\nfunction App() {\n  return (\n    &lt;AuthProvider&gt;\n      &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n          &lt;Navbar /&gt;\n          &lt;AppRoutes /&gt;\n        &lt;/div&gt;\n      &lt;/Router&gt;\n    &lt;/AuthProvider&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"auth/routing/#summary","title":"Summary","text":"<p>Routing logic can be simple or complex depending on the application's requirements. Understanding these techniques allows you to create more robust, maintainable, and user-friendly web applications. Here's a brief summary of techniques:</p>"},{"location":"auth/routing/#summary-of-concepts","title":"Summary of Concepts","text":"<ol> <li>Basic Routing: Defined straightforward paths to components.</li> <li>Dynamic Routing: Used URL parameters to dynamically render content.</li> <li>Nested Routes: Demonstrated child routes for complex layouts.</li> <li>Redirects: Redirected users based on certain conditions.</li> <li>Protected Routes: Restricted access based on authentication.</li> <li>404 Handling: Managed unmatched routes gracefully.</li> <li>Lazy Loading: Improved performance by loading components only when needed.</li> <li>History Management: Utilized the built-in browser history.</li> <li>Custom Hooks for Routing: Created reusable hooks for accessing routing data.</li> <li>Route Guards: Implemented role-based access control.</li> </ol>"},{"location":"auth/routing/#folder-structure","title":"Folder Structure","text":"<pre><code>/src\n  /components\n    /Navbar\n      Navbar.js\n      Navbar.css\n    /Home\n      Home.js\n    /About\n      About.js\n    /NotFound\n      NotFound.js\n    /User\n      User.js\n      UserProfile.js\n    /Admin\n      Admin.js\n  /routes\n    AppRoutes.js\n  /context\n    AuthContext.js\n  App.js\n  index.js\n</code></pre>"},{"location":"auth/why-react-router/","title":"Why React Router","text":"<p>React Router is beneficial for several reasons:</p> <ol> <li>Dynamic Routing: It allows you to create routes that can change based on user interaction or application state, enabling a more dynamic user experience.</li> <li>Nested Routing: You can set up nested routes, which helps maintain a clear structure in larger applications, making it easier to manage related components.</li> <li>Code Splitting: React Router supports lazy loading of routes, which improves performance by loading only the necessary code for the current view.</li> <li>Browser History Management: It simplifies managing browser history, allowing users to navigate back and forth seamlessly.</li> <li>URL Management: React Router enables clean and meaningful URLs, which is important for usability and SEO.</li> <li>Declarative Routing: You define routes in a declarative manner, which integrates well with the React component model.</li> <li>State Preservation: It allows you to maintain state across different routes, making it easier to build a consistent user experience.</li> </ol> <p>Overall, while you can build applications without it, React Router makes managing navigation and routing in React apps much easier and more efficient, especially as they grow in complexity.</p>"},{"location":"auth/why-react-router/#additional","title":"Additional","text":"<p>Here are some lesser-known aspects and potential pitfalls of React Router that you might want to be aware of:</p> <ol> <li> <p>Route Rendering: The way you render routes can affect your app\u2019s performance. Using <code>component</code> vs. <code>render</code> props can lead to unnecessary re-renders if not handled carefully.</p> </li> <li> <p>Data Fetching: While React Router itself doesn\u2019t handle data fetching, it\u2019s common to implement data loading in route components, which can lead to duplicated logic if not structured properly.</p> </li> <li> <p>Context Issues: If you\u2019re using multiple routers or nesting, managing context can become complex. Be cautious about how context providers interact with router components.</p> </li> <li> <p>Use of <code>Link</code>: Always use the <code>Link</code> component for navigation instead of anchor (<code>&lt;a&gt;</code>) tags. This prevents a full page reload and ensures that React Router can manage the app\u2019s history correctly.</p> </li> <li> <p>Nested Routes Complexity: While nested routes can be powerful, they can also add complexity to your routing logic. It\u2019s important to manage props and state effectively when dealing with deeply nested routes.</p> </li> <li> <p>404 Handling: Setting up a catch-all route for handling 404 pages can sometimes be overlooked, leading to a poor user experience when users navigate to nonexistent routes.</p> </li> <li> <p>Browser History Management: Understanding how React Router interacts with the browser\u2019s history stack is crucial. Mismanagement can lead to issues with the back and forward buttons.</p> </li> <li> <p>Version Changes: Keep an eye on version changes and breaking changes. React Router has gone through significant changes over versions, particularly from v5 to v6.</p> </li> <li> <p>Custom Route Matching: You can create custom route matching logic, but it can get tricky if not well-documented within your codebase.</p> </li> <li> <p>Accessibility: Ensure that your routing and navigation components are accessible, as React Router does not automatically handle ARIA roles and attributes.</p> </li> </ol> <p>Being aware of these nuances can help you use React Router more effectively and avoid common pitfalls!</p>"},{"location":"auth/why-react-router/#example","title":"Example","text":"<p>Sure! Here are some examples of good and bad practices with React Router:</p>"},{"location":"auth/why-react-router/#1-route-rendering","title":"1. Route Rendering","text":"Bad Example: Using <code>component</code> Prop <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This approach can lead to unnecessary re-renders if the About component's props change.</p> <p><code>Fine with v5</code></p> Good Example: Using <code>element</code> Prop (React Router v6) <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <p>Using the <code>element</code> prop helps maintain a clean render and optimizes performance.</p>"},{"location":"auth/why-react-router/#2-conditional-rendering","title":"2. Conditional Rendering","text":"Bad Example: Conditional Logic in Route Definition <pre><code>&lt;Route path=\"/profile\" render={() =&gt; user ? &lt;Profile /&gt; : &lt;Redirect to=\"/login\" /&gt;} /&gt;\n</code></pre> <p>This can be harder to read and maintain.</p> Good Example: Use a Wrapper Component <pre><code>const PrivateRoute = ({ children }) =&gt; {\n    return user ? children : &lt;Navigate to=\"/login\" /&gt;;\n};\n\n// Usage\n&lt;Route path=\"/profile\" element={&lt;PrivateRoute&gt;&lt;Profile /&gt;&lt;/PrivateRoute&gt;} /&gt;\n</code></pre> <p>This keeps your routes cleaner and separates concerns.</p>"},{"location":"auth/why-react-router/#3-handling-404-pages","title":"3. Handling 404 Pages","text":"Bad Example: Not Defining a Catch-All Route <p>If you forget to handle undefined routes, users might just see a blank page.</p> Good Example: Defining a Catch-All Route <pre><code>&lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n</code></pre> <p>This way, users will always have feedback if they navigate to a nonexistent route.</p>"},{"location":"auth/why-react-router/#4-navigation-with-link","title":"4. Navigation with <code>Link</code>","text":"Bad Example: Using <code>&lt;a&gt;</code> Tag for Navigation <pre><code>&lt;a href=\"/about\"&gt;About&lt;/a&gt;\n</code></pre> <p>This causes a full page reload, losing the single-page app experience.</p> Good Example: Using <code>&lt;Link&gt;</code> <pre><code>&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n</code></pre> <p>This enables React Router to manage navigation without reloading the page.</p>"},{"location":"auth/why-react-router/#5-nested-routes","title":"5. Nested Routes","text":"Bad Example: Deeply Nested Routes Without Organization <pre><code>&lt;Route path=\"/dashboard\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n    // more deeply nested routes...\n&lt;/Route&gt;\n</code></pre> <p>This can get confusing and hard to manage.</p> Good Example: Clear Nested Structure <pre><code>&lt;Route path=\"/dashboard/*\" element={&lt;Dashboard /&gt;}&gt;\n    &lt;Route path=\"settings\" element={&lt;Settings /&gt;} /&gt;\n    &lt;Route path=\"users\" element={&lt;Users /&gt;} /&gt;\n&lt;/Route&gt;\n</code></pre> <p>Using <code>/*</code> makes it clear that more routes are nested under <code>/dashboard</code>.</p> <p>Summary</p> <p>Using React Router effectively involves keeping your code organized, making good use of props, and handling navigation and state management thoughtfully. Following these good practices will lead to a cleaner, more maintainable, and more user-friendly application!</p>"},{"location":"auth/why-react-router/#changes-v5-vs-v6","title":"Changes <code>v5</code> vs <code>v6</code>","text":"<p>Exactly! Here\u2019s a breakdown:</p> In React Router v5In React Router v6Why the Change? <p>Using this syntax is perfectly acceptable:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>This correctly renders the <code>About</code> component when the path matches. It\u2019s a standard practice for v5.</p> <p>This syntax becomes outdated and not recommended:</p> <pre><code>&lt;Route path=\"/about\" component={About} /&gt;\n</code></pre> <p>In v6, you should use:</p> <pre><code>&lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n</code></pre> <ul> <li>Simpler API: The v6 <code>element</code> prop allows you to directly pass a React element, which can help avoid issues with re-renders and make the code cleaner.</li> <li>Consistency: It aligns better with how React works, encouraging the use of JSX for rendering.</li> </ul> <p>So, in summary, while the original example is good practice in v5, it becomes a bad example in v6 due to the API changes. Always make sure to follow the guidelines specific to the version you\u2019re using!</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/","title":"The Functional Update Pattern Explained","text":"<p>The functional update pattern in React is a method of updating state by using a function that takes the previous state as an argument. This pattern ensures that you always work with the most current state value, which is especially important in scenarios where state updates may be batched or occur in quick succession.</p> <p>Mastering State Management in React: The Functional Update Pattern Explained</p>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#key-features-of-the-functional-update-pattern","title":"Key Features of the Functional Update Pattern","text":"<ol> <li> <p>Access to Previous State:</p> <ul> <li>The function you provide to the state updater (like setState) receives the previous state as an argument. This allows you to derive the new state based on the most recent value.</li> </ul> </li> <li> <p>Asynchronous Updates:</p> <ul> <li>React's state updates can be asynchronous. By using the functional update pattern, you avoid issues that can arise from referencing a stale state value.</li> </ul> </li> <li> <p>Prevents Bugs:</p> <ul> <li>When multiple updates depend on the previous state, using this pattern can prevent bugs related to incorrect state values due to overlapping updates.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#example-of-the-functional-update-pattern","title":"Example of the Functional Update Pattern","text":"<p>Here\u2019s a simple example using a counter component:</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount((prevCount) =&gt; prevCount + 1); // Using functional update\n  };\n\n  const decrement = () =&gt; {\n    setCount((prevCount) =&gt; prevCount - 1); // Using functional update\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Counter;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#why-use-the-functional-update-pattern","title":"Why Use the Functional Update Pattern?","text":"<ol> <li>Accuracy: Ensures that you are working with the latest state value, preventing errors due to outdated references.</li> <li>Simplicity: Keeps your state updates straightforward and clear, especially when the new state depends on the previous state.</li> <li>Better Performance: Helps React optimize re-renders, as it can determine more efficiently when state updates occur.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#conclusion","title":"Conclusion","text":"<p>The functional update pattern is an essential technique in React for managing state updates accurately. By utilizing this pattern, you can create more reliable and maintainable components, ensuring that your application behaves as expected even in complex scenarios.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/","title":"Understanding the Importance of Using Previous State in React","text":"<p>In React, managing state efficiently is crucial for building responsive and bug-free applications. One common practice that developers should adopt is using the previous state when updating state values.</p> <p>This simple pattern can prevent a range of issues related to state management, especially in dynamic applications where multiple updates may occur rapidly.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#why-use-previous-state","title":"Why Use Previous State?","text":"<ol> <li> <p>Accurate Updates:</p> <p>When you use the previous state, you ensure that each update is based on the most current value. This is particularly important when multiple state updates are triggered in quick succession. If you simply rely on the current state, you risk missing updates, leading to incorrect values.</p> <p>For example:</p> <pre><code>setCount(count + 1); // May lead to missed increments\n</code></pre> <p>Instead, using the previous state guarantees accurate calculations:</p> <pre><code>setCount((prevCount) =&gt; prevCount + 1); // Safely increments the count\n</code></pre> </li> <li> <p>Functional Updates:</p> <p>React allows state updates to be made using a function that receives the previous state as an argument. This functional update pattern enhances clarity and ensures that you\u2019re working with the most recent state.</p> <pre><code>setCount((prevCount) =&gt; prevCount - 1); // Decrements reliably\n</code></pre> </li> <li> <p>Asynchronous Nature of State Updates:</p> <p>React state updates are asynchronous, meaning they don\u2019t occur immediately. Without using the previous state, you might inadvertently work with a stale value, leading to unexpected behavior in your application.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#conclusion","title":"Conclusion","text":"<p>Using the previous state when updating values in React is a best practice that enhances the reliability and accuracy of your state management. By adopting this pattern, developers can avoid potential bugs and ensure that their components respond correctly to user interactions. Next time you\u2019re updating state, remember to use (prevState) to maintain the integrity of your application\u2019s data flow!</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#additional","title":"Additional","text":"ExampleExplanationConclusion <pre><code>import React, { useState } from 'react';\n\nconst ItemList = () =&gt; {\n    const [items, setItems] = useState([\n        { id: 1, name: 'Item 1' },\n        { id: 2, name: 'Item 2' },\n    ]);\n\n    const [newItemName, setNewItemName] = useState('');\n\n    // Adding an item using previous state\n    const addItem = () =&gt; {\n        if (newItemName.trim() === '') return; // Prevent adding empty items\n            const newItem = {\n            id: items.length + 1, // Simple ID generation\n            name: newItemName,\n        };\n        setItems((prevItems) =&gt; [...prevItems, newItem]); // Use previous state to add a new item\n        setNewItemName(''); // Clear input field\n    };\n\n    // Removing an item using previous state\n    const removeItem = (id) =&gt; {\n        setItems((prevItems) =&gt; prevItems.filter(item =&gt; item.id !== id)); // Use previous state to filter out the item\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Item List&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newItemName}\n                onChange={(e) =&gt; setNewItemName(e.target.value)} // Handle input change\n                placeholder=\"Add new item\"\n            /&gt;\n            &lt;button onClick={addItem}&gt;Add Item&lt;/button&gt;\n\n            &lt;ul&gt;\n                {items.map((item) =&gt; (\n                &lt;li key={item.id}&gt;\n                    {item.name}\n                    &lt;button onClick={() =&gt; removeItem(item.id)}&gt;Remove&lt;/button&gt;\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ItemList;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>items</code>: An array of objects representing the list of items, where each object has an <code>id</code> and a <code>name</code>.</li> <li><code>newItemName</code>: A string for the input field to capture the new item's name.</li> </ul> </li> <li> <p>Using Previous State:</p> <ul> <li>Adding Items: When adding a new item, we use the previous state with <code>setItems((prevItems) =&gt; [...prevItems, newItem])</code>. This ensures that we're working with the most current version of the <code>items</code> array.</li> <li>Removing Items: The <code>removeItem</code> function also utilizes the previous state to filter out the item by its ID, ensuring that we accurately reflect the current list.</li> </ul> </li> <li> <p>Rendering:</p> <ul> <li>An input field captures the new item's name, and a button adds it to the list.</li> <li>The list of items is displayed, with a \"Remove\" button for each item that allows users to delete it.</li> </ul> </li> </ol> <p>Using the previous state when managing complex data structures like lists in React is crucial for maintaining data integrity. It helps ensure that updates reflect the current state accurately, especially in scenarios involving asynchronous updates or multiple rapid interactions. By adopting this practice, developers can create more reliable and bug-free applications.</p>","tags":["react"]},{"location":"blog/2024/07/06/folder-structure-for-large-react-application/","title":"Folder Structure for Large React Application","text":"<p>Sure! For a larger React application, an advanced folder structure helps maintain organization and scalability. Here\u2019s an example:</p> Folder StructureExplanation of the StructureAdditional Considerations <pre><code>my-large-react-app/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u2514\u2500\u2500 assets/\n\u2502       \u251c\u2500\u2500 images/\n\u2502       \u2514\u2500\u2500 fonts/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 api/                  # API calls and services\n\u2502   \u2502   \u251c\u2500\u2500 userService.js\n\u2502   \u2502   \u2514\u2500\u2500 postService.js\n\u2502   \u251c\u2500\u2500 components/           # Shared components\n\u2502   \u2502   \u251c\u2500\u2500 Button/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Button.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Button.css\n\u2502   \u2502   \u251c\u2500\u2500 Navbar/\n\u2502   \u2502   \u2514\u2500\u2500 Footer/\n\u2502   \u251c\u2500\u2500 features/             # Feature-specific components\n\u2502   \u2502   \u251c\u2500\u2500 auth/             # Authentication feature\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Login.js\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Register.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 authSlice.js   # Redux slice or context\n\u2502   \u2502   \u251c\u2500\u2500 dashboard/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Dashboard.js\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 dashboardSlice.js\n\u2502   \u2502   \u2514\u2500\u2500 posts/\n\u2502   \u2502       \u251c\u2500\u2500 PostList.js\n\u2502   \u2502       \u251c\u2500\u2500 PostDetail.js\n\u2502   \u2502       \u2514\u2500\u2500 postSlice.js\n\u2502   \u251c\u2500\u2500 hooks/                # Custom hooks\n\u2502   \u2502   \u251c\u2500\u2500 useAuth.js\n\u2502   \u2502   \u2514\u2500\u2500 useFetch.js\n\u2502   \u251c\u2500\u2500 context/              # Context API files\n\u2502   \u2502   \u251c\u2500\u2500 AuthContext.js\n\u2502   \u2502   \u2514\u2500\u2500 ThemeContext.js\n\u2502   \u251c\u2500\u2500 pages/                # Page components\n\u2502   \u2502   \u251c\u2500\u2500 HomePage.js\n\u2502   \u2502   \u251c\u2500\u2500 AboutPage.js\n\u2502   \u2502   \u2514\u2500\u2500 ContactPage.js\n\u2502   \u251c\u2500\u2500 routes/               # Route configuration\n\u2502   \u2502   \u2514\u2500\u2500 AppRoutes.js\n\u2502   \u251c\u2500\u2500 styles/               # Global styles\n\u2502   \u2502   \u251c\u2500\u2500 variables.css\n\u2502   \u2502   \u2514\u2500\u2500 global.css\n\u2502   \u251c\u2500\u2500 utils/                # Utility functions\n\u2502   \u2502   \u251c\u2500\u2500 formatDate.js\n\u2502   \u2502   \u2514\u2500\u2500 constants.js\n\u2502   \u251c\u2500\u2500 App.js                # Main App component\n\u2502   \u251c\u2500\u2500 index.js              # Entry point\n\u2502   \u2514\u2500\u2500 store/                # Redux or global state management\n\u2502       \u251c\u2500\u2500 store.js\n\u2502       \u2514\u2500\u2500 rootReducer.js\n\u251c\u2500\u2500 .env                      # Environment variables\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 README.md\n</code></pre> <ul> <li> <p><code>public/</code>: Contains static assets and the main HTML file.</p> </li> <li> <p><code>src/</code>: The core of your application.</p> <ul> <li> <p><code>api/</code>: Contains files for making API calls or managing external services.</p> </li> <li> <p><code>components/</code>: Shared components that can be reused across the application, organized in subfolders by component name.</p> </li> <li> <p><code>features/</code>: Group components, slices (if using Redux), and logic by feature. This can help keep related functionality together.</p> </li> <li> <p><code>hooks/</code>: Custom hooks to encapsulate reusable logic.</p> </li> <li> <p><code>context/</code>: Files related to the Context API, useful for managing global state.</p> </li> <li> <p><code>pages/</code>: Components that correspond to different pages or views of the application.</p> </li> <li> <p><code>routes/</code>: Centralized route configuration for organizing application routes.</p> </li> <li> <p><code>styles/</code>: Global styles and variables for consistent theming.</p> </li> <li> <p><code>utils/</code>: Utility functions and constants that are used throughout the app.</p> </li> <li> <p><code>store/</code>: Redux or other global state management setup, including the store and root reducer.</p> </li> </ul> </li> </ul> <ul> <li>Testing: You might want to add a <code>__tests__</code> folder within relevant directories for unit tests.</li> <li>Assets: A dedicated assets folder can be useful for images, icons, and fonts.</li> <li>Documentation: Consider a <code>docs/</code> folder if your project requires extensive documentation.</li> </ul> <p>This structure supports scalability and maintainability, making it easier for developers to navigate and manage the application as it grows!</p>","tags":["react"]},{"location":"blog/2024/07/06/folder-structure-for-large-react-application/#features-folder","title":"<code>features/</code> Folder","text":"<p>The <code>features/</code> folder in a large React application serves as a way to organize components, logic, and state management related to specific features or sections of the application. This approach helps in keeping related code together, making it easier to manage and scale.</p> Structure of the <code>features/</code> Folder <p>Here\u2019s an example of how you might structure a <code>features/</code> folder:</p> StructureExplanation of Each Feature Folder <pre><code>src/\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 auth/\n    \u2502   \u251c\u2500\u2500 Login.js\n    \u2502   \u251c\u2500\u2500 Register.js\n    \u2502   \u251c\u2500\u2500 authSlice.js         # Redux slice for auth state\n    \u2502   \u2514\u2500\u2500 authAPI.js           # API calls related to authentication\n    \u251c\u2500\u2500 dashboard/\n    \u2502   \u251c\u2500\u2500 Dashboard.js\n    \u2502   \u251c\u2500\u2500 Stats.js\n    \u2502   \u251c\u2500\u2500 dashboardSlice.js     # Redux slice for dashboard state\n    \u2502   \u2514\u2500\u2500 dashboardAPI.js       # API calls related to dashboard\n    \u2514\u2500\u2500 posts/\n        \u251c\u2500\u2500 PostList.js\n        \u251c\u2500\u2500 PostDetail.js\n        \u251c\u2500\u2500 postSlice.js          # Redux slice for posts state\n        \u2514\u2500\u2500 postAPI.js            # API calls related to posts\n</code></pre> <ol> <li> <p>Feature Folder: Each feature (e.g., <code>auth</code>, <code>dashboard</code>, <code>posts</code>) has its own folder. This keeps all related files together.</p> </li> <li> <p>Component Files: Each feature folder contains component files specific to that feature. For example:</p> <ul> <li><code>Login.js</code> and <code>Register.js</code> handle user authentication.</li> <li><code>Dashboard.js</code> manages the main dashboard view.</li> <li><code>PostList.js</code> and <code>PostDetail.js</code> are used to display posts.</li> </ul> </li> <li> <p>State Management: Each feature can have its own state management file (like <code>authSlice.js</code>, <code>dashboardSlice.js</code>, <code>postSlice.js</code>) if you\u2019re using Redux or similar libraries. This file typically includes:</p> <ul> <li>Actions: Functions that define how to update the state.</li> <li>Reducers: Functions that handle the state changes based on actions.</li> </ul> </li> <li> <p>API Handling: Each feature can also have its own API handling file (like <code>authAPI.js</code>, <code>dashboardAPI.js</code>, <code>postAPI.js</code>) to manage API calls specific to that feature. This keeps the API logic separated and organized.</p> </li> </ol> <p>Example of the <code>auth/</code> Feature</p> authSlice.jsauthAPI.jsLogin.js <pre><code>import { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { loginUser, registerUser } from \"./authAPI\";\n\nexport const login = createAsyncThunk(\"auth/login\", async (userData) =&gt; {\n    const response = await loginUser(userData);\n    return response.data;\n});\n\nexport const register = createAsyncThunk(\"auth/register\", async (userData) =&gt; {\n    const response = await registerUser(userData);\n    return response.data;\n});\n\nconst authSlice = createSlice({\n    name: \"auth\",\n    initialState: { user: null, status: \"idle\" },\n    reducers: {\n        logout: (state) =&gt; {\n            state.user = null;\n        },\n    },\n    extraReducers: (builder) =&gt; {\n        builder\n            .addCase(login.pending, (state) =&gt; {\n                state.status = \"loading\";\n            })\n            .addCase(login.fulfilled, (state, action) =&gt; {\n                state.user = action.payload;\n                state.status = \"succeeded\";\n            });\n    },\n});\n\nexport const { logout } = authSlice.actions;\nexport default authSlice.reducer;\n</code></pre> <pre><code>import axios from \"axios\";\n\nexport const loginUser = async (userData) =&gt; {\n    const response = await axios.post(\"/api/auth/login\", userData);\n    return response;\n};\n\nexport const registerUser = async (userData) =&gt; {\n    const response = await axios.post(\"/api/auth/register\", userData);\n    return response;\n};\n</code></pre> <pre><code>import React, { useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\nimport { login } from \"./authSlice\";\n\nconst Login = () =&gt; {\n    const dispatch = useDispatch();\n    const [email, setEmail] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n\n    const handleSubmit = (e) =&gt; {\n        e.preventDefault();\n        dispatch(login({ email, password }));\n    };\n\n    return (\n        &lt;form onSubmit={handleSubmit}&gt;\n            &lt;input\n                type=\"email\"\n                value={email}\n                onChange={(e) =&gt; setEmail(e.target.value)}\n                placeholder=\"Email\"\n            /&gt;\n            &lt;input\n                type=\"password\"\n                value={password}\n                onChange={(e) =&gt; setPassword(e.target.value)}\n                placeholder=\"Password\"\n            /&gt;\n            &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    );\n};\n\nexport default Login;\n</code></pre> Benefits of the <code>features/</code> Folder Structure <ul> <li>Modularity: Each feature is self-contained, making it easier to manage and update without affecting other parts of the application.</li> <li>Scalability: As the application grows, adding new features or modifying existing ones becomes straightforward.</li> <li>Readability: New developers can quickly understand the structure and locate related files.</li> </ul> <p>This organization helps maintain clarity and order, especially in larger applications where multiple features and components are in play!</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/","title":"Where to Define the Navigation Links in a React Application","text":"<p>In a React application that uses React Router, navigation links should typically be defined in a separate component that serves as your navigation bar. This approach enhances modularity and keeps your code organized</p> <p>Here\u2019s how you can effectively implement navigation links in your app.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#recommended-structure","title":"Recommended Structure","text":"<ol> <li>Create a Navbar Component: This component will contain your navigation links, making it reusable across different parts of your application.</li> <li>Place the Navbar in <code>App.js</code>: By including the Navbar in your main <code>App.js</code> component, it will be visible on all pages where you have defined your routes.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#example-implementation","title":"Example Implementation","text":"1. Create a Navbar Component2. Update Your <code>App.js</code>Benefits of This Approach <p>First, create a file called <code>Navbar.jsx</code> in your <code>components</code> directory.</p> <pre><code>// src/components/Navbar.jsx\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/2\"&gt;User 2&lt;/Link&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <p>Now, import and include the Navbar component in your App.js file:</p> <pre><code>// src/App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nimport NotFound from './components/NotFound';\nimport Navbar from './components/Navbar';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n        &lt;div className=\"App\"&gt;\n            &lt;Navbar /&gt; {/* Include the Navbar here */}\n            &lt;header className=\"App-header\"&gt;\n                &lt;h1&gt;My React App&lt;/h1&gt;\n            &lt;/header&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/div&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> <ol> <li>Modularity: By separating the Navbar into its own component, you create a modular design that is easier to maintain and update.</li> <li>Reusability: You can use the <code>Navbar</code> component across different parts of your application without repeating code.</li> <li>Clear Structure: Including the Navbar in <code>App.js</code> keeps your layout clear, showing that navigation is an integral part of the app structure.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#conclusion","title":"Conclusion","text":"<p>Defining your navigation links in a separate <code>Navbar</code> component and including it in <code>App.js</code> promotes a clean, modular approach. This not only enhances maintainability but also aligns with best practices in React development, making your application easier to navigate and manage as it grows.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#addtional","title":"Addtional","text":"<p>so we should put the nav link and routes in the same file</p> <p>Yes, it's generally a good practice to keep the navigation links and routes in the same file (specifically, in your main <code>App.js</code> file). Here\u2019s why this approach is beneficial:</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#benefits-of-combining-navigation-links-and-routes-in-appjs","title":"Benefits of Combining Navigation Links and Routes in <code>App.js</code>","text":"<ol> <li> <p>Centralized Structure: By defining both your navigation links and routes in <code>App.js</code>, you create a clear and centralized structure for your application. This makes it easier to see how different parts of your app are connected.</p> </li> <li> <p>Simplified Navigation: It allows you to quickly add or update routes and navigation links in one place. When you need to change a route, you can easily update the corresponding link in the navigation.</p> </li> <li> <p>Enhanced Readability: Keeping related components (like routes and navigation) together improves the readability of your code. Developers can quickly understand the flow of the application by looking at a single file.</p> </li> <li> <p>Modular Design: While the navigation links are part of the layout, they are logically connected to the routes they lead to. This modularity makes it easier to manage larger applications.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#example-structure","title":"Example Structure","text":"<p>Here\u2019s an example to illustrate this approach:</p> <pre><code>// src/App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Routes, Route, Link } from \"react-router-dom\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;div className=\"App\"&gt;\n        {/* Navigation Links */}\n        &lt;nav&gt;\n          &lt;ul&gt;\n            &lt;li&gt;\n              &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n              &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n            &lt;/li&gt;\n          &lt;/ul&gt;\n        &lt;/nav&gt;\n\n        {/* Routes */}\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n          &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#alternative-approach","title":"Alternative Approach","text":"<p>If your application grows larger, you might choose to separate the Navbar into its own component to keep things organized while still importing it in <code>App.js</code>:</p> <pre><code>// src/components/Navbar.jsx\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nconst Navbar = () =&gt; (\n  &lt;nav&gt;\n    &lt;ul&gt;\n      &lt;li&gt;\n        &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/nav&gt;\n);\n\nexport default Navbar;\n</code></pre> <p>Then import and use the Navbar in <code>App.js</code>:</p> <pre><code>// src/App.js\nimport React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Navbar from \"./components/Navbar\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;div className=\"App\"&gt;\n        &lt;Navbar /&gt; {/* Separate Navbar component */}\n        &lt;Routes&gt;\n          &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n          &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n          &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#conclusion_1","title":"Conclusion","text":"<p>Combining navigation links and routes in the same file, or using a separate component for the navigation while keeping routes in <code>App.js</code>, provides a clean and organized structure. This approach enhances the maintainability and readability of your code as your application scales.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-define-the-navigation-links-in-a-react-application/#additional-2","title":"Additional 2","text":"<p>Leveraging Component Reusability: Using Navbar in Multiple Parts of Your React Application</p> <p>Yes, you can absolutely use the <code>Navbar</code> component in any other component within your React application, not just in <code>App.js</code>. This flexibility allows you to structure your app in a way that fits your needs.</p> How to Use the Navbar Component in Other Components <ol> <li>Define the Navbar Component: First, ensure that your <code>Navbar</code> component is defined, as shown previously.</li> <li>Import and Use the Navbar: You can import and use the <code>Navbar</code> component in any other component, such as a <code>Home</code> or <code>About</code> page.</li> </ol> <p>Example Implementation</p> Navbar ComponentUsing ComponentApp.js <p><code>1. Navbar Component</code></p> <pre><code>// src/components/Navbar.jsx\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Navbar = () =&gt; {\n    return (\n        &lt;nav&gt;\n            &lt;ul&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/1\"&gt;User 1&lt;/Link&gt;\n                &lt;/li&gt;\n                &lt;li&gt;\n                    &lt;Link to=\"/user/2\"&gt;User 2&lt;/Link&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    );\n};\n\nexport default Navbar;\n</code></pre> <p><code>2. Using Navbar in Other Components</code></p> <p>Suppose you want to use the <code>Navbar</code> in a <code>Home</code> component:</p> <pre><code>// src/components/Home.jsx\nimport React from 'react';\nimport Navbar from './Navbar'; // Importing the Navbar\n\nconst Home = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;Navbar /&gt; {/* Use the Navbar here */}\n            &lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;\n            &lt;p&gt;This is the home page content.&lt;/p&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Home;\n</code></pre> <p><code>3. App.js</code></p> <p>You can also use the <code>Navbar</code> in <code>App.js</code> or anywhere else as needed:</p> <pre><code>// src/App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport Home from './components/Home';\nimport About from './components/About';\nimport NotFound from './components/NotFound';\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;Routes&gt;\n                &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n            &lt;/Routes&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre> Key Points <ol> <li>Reusable Component: By defining <code>Navbar</code> separately, you make it reusable across multiple components, not just <code>App.js</code>.</li> <li>Component Flexibility: You can decide where to place the <code>Navbar</code> based on the layout you want. For instance, you might want it to be present on every page, or only on specific pages.</li> <li>Modular Design: This modular design keeps your application organized and helps maintain a clear separation of concerns.</li> </ol> <p>Conclusion</p> <p>You can certainly use the Navbar component in any other component, giving you flexibility in how you structure your application. This approach enhances the modularity and maintainability of your code, allowing you to scale your React application more easily.</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/","title":"React State Updates Explained","text":"<p>Certainly! Let\u2019s explore the concept of asynchronous state updates in React with a detailed example.</p> <p>React State Updates Explained: The Importance of Asynchronous Behavior</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#example-understanding-asynchronous-state-updates","title":"Example: Understanding Asynchronous State Updates","text":"<p>Suppose we have a simple counter component that increments the count when a button is clicked.</p> Initial Component Without Functional UpdatesWhat Happens Here? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount(count + 1); // Attempt to increment the count\n        setCount(count + 2); // Attempt to increment the count again\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>When you click the \"Increment\" button, the <code>handleIncrement</code> function is called.</li> <li>The first <code>setCount(count + 1)</code> is executed, but it doesn't update the state immediately.</li> <li>The second <code>setCount(count + 2)</code> is called right after, referencing the same initial <code>count</code> value.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, both updates reference the same value, and you may expect the count to be 3 (0 + 1 + 2). However, because the updates are batched, the final state remains 2 (0 + 2) instead of 3.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#fixing-it-with-functional-updates","title":"Fixing It with Functional Updates","text":"<p>To correctly manage the updates, we can use the functional update pattern:</p> ExampleWhat Happens Now? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount((prevCount) =&gt; prevCount + 1); // Correctly increments by 1\n        setCount((prevCount) =&gt; prevCount + 2); // Correctly increments by 2\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>The first <code>setCount</code> now uses the previous state <code>prevCount</code> to increment the count by 1.</li> <li>The second <code>setCount</code> also uses the latest <code>prevCount</code>, which is now updated.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, the first update correctly sets it to 1, and the second update then sets it to 3 (1 + 2). This yields the expected behavior.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#summary-of-asynchronous-updates","title":"Summary of Asynchronous Updates","text":"<ul> <li>Batched Updates: In the initial example, React batched the updates. The state didn\u2019t update immediately after each call, which led to unexpected results.</li> <li>Using Previous State: By using the functional update pattern, you ensure each update correctly references the most recent state value.</li> <li>Performance and Consistency: This pattern prevents potential issues and allows React to optimize rendering, providing a smoother user experience.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#conclusion","title":"Conclusion","text":"<p>Understanding how asynchronous state updates work in React helps developers avoid common pitfalls and write more reliable code. Using functional updates ensures that state changes are predictable and accurate, especially in scenarios with multiple rapid updates.</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/","title":"When to Use <code>.jsx</code> vs <code>.js</code> in react","text":"<p>In React, the choice between using <code>.js</code> and <code>.jsx</code> file extensions is largely a matter of convention and team preferences.</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#overview","title":"Overview","text":"<p>Here's a breakdown of when to use each:</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#use-jsx-when","title":"Use <code>.jsx</code> When:","text":"<ol> <li> <p>JSX Syntax:</p> <p>The file contains JSX syntax. JSX is the XML-like syntax used in React to describe UI components. If a file includes JSX, it's common to use the <code>.jsx</code> extension to make that clear.</p> <pre><code>// ExampleComponent.jsx\nimport React from \"react\";\n\nconst ExampleComponent = () =&gt; {\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n};\n\nexport default ExampleComponent;\n</code></pre> </li> <li> <p>Component Files:</p> <p>When defining React components that use JSX, many developers prefer <code>.jsx</code> for clarity.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#use-js-when","title":"Use <code>.js</code> When:","text":"<ol> <li> <p>JavaScript Logic:</p> <p>The file contains only standard JavaScript code without any JSX. This could include utility functions, configurations, or any JavaScript logic that doesn\u2019t interact with React\u2019s rendering process.</p> <pre><code>// utils.js\nexport const add = (a, b) =&gt; a + b;\n</code></pre> </li> <li> <p>Non-Component Files:</p> <p>For files that do not define React components (like context providers, hooks, or configurations), <code>.js</code> is often used.</p> </li> <li> <p>Conventional Use:</p> <p>In many projects, especially those created with Create React App, <code>.js</code> is the default extension. Using <code>.js</code> for all files (including those with JSX) is perfectly acceptable, as long as it\u2019s consistent.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#conclusion","title":"Conclusion","text":"<ul> <li>Use <code>.jsx</code> for files that contain JSX, particularly for React components.</li> <li>Use <code>.js</code> for files that are pure JavaScript or do not use JSX.</li> </ul> <p>Ultimately, it\u2019s important to maintain consistency within your project or team. Choose a convention that works for everyone and stick with it!</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#naming-files-for-jsx-js","title":"Naming files for <code>.jsx</code> &amp; <code>.js</code>","text":"<p>Naming files in React, whether they use the <code>.jsx</code> or <code>.js</code> extension, follows some common conventions to enhance clarity, maintainability, and organization.</p> <p>Here\u2019s a breakdown of standard practices for naming files in both cases:</p>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#1-file-naming-conventions","title":"1. File Naming Conventions","text":"For <code>.jsx</code> FilesFor <code>.js</code> Files <ul> <li> <p>Component Names: Use PascalCase (also known as UpperCamelCase) for naming component files. This helps distinguish components from regular JavaScript files and indicates they are React components.</p> </li> <li> <p>Examples:</p> <pre><code>-   MyComponent.jsx\n-   UserProfile.jsx\n-   HeaderNav.jsx\n</code></pre> </li> <li> <p>Folder Structure: For components with related files (like styles or tests), consider creating a folder for each component.</p> </li> <li> <p>Example:</p> <pre><code>/components\n    /MyComponent\n        MyComponent.jsx\n        MyComponent.css\n        MyComponent.test.jsx\n</code></pre> </li> </ul> <ul> <li> <p>Utility Functions and Hooks: Use camelCase for naming utility files or custom hooks, which typically do not represent components.</p> </li> <li> <p>Examples:</p> <pre><code>-   formatDate.js\n-   useFetchData.js\n-   mathUtils.js\n</code></pre> </li> <li> <p>Configuration and Context Files: Use kebab-case or camelCase based on personal/team preference. These files usually represent non-component logic.</p> </li> <li> <p>Examples:</p> <pre><code>-   authContext.js\n-   apiConfig.js\n</code></pre> </li> </ul>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#2-reasons-for-these-conventions","title":"2. Reasons for These Conventions","text":"<ul> <li> <p>Clarity: PascalCase for components helps immediately identify files that export React components, making it easier for developers to navigate the codebase.</p> </li> <li> <p>Organization: Grouping related files in folders (especially for components) keeps the structure clean and manageable, facilitating easier development and testing.</p> </li> <li> <p>Consistency: Following a standardized naming convention across the project makes the codebase more predictable and easier to read. New developers can quickly understand the structure.</p> </li> <li> <p>Avoiding Confusion: By clearly distinguishing between components and utility/helper functions, developers can avoid mistakes, like trying to render a utility function as a component.</p> </li> </ul>","tags":["react"]},{"location":"blog/2024/07/09/when-to-use-jsx-vs-js-in-react/#3-summary","title":"3. Summary","text":"<ul> <li>Use PascalCase for <code>.jsx</code> component files (e.g., <code>MyComponent.jsx</code>).</li> <li>Use camelCase for <code>.js</code> utility and hook files (e.g., <code>useFetchData.js</code>).</li> <li>Organize related files within folders to enhance clarity and maintainability.</li> </ul> <p>By adhering to these conventions, you create a more organized, understandable, and maintainable codebase, which is especially beneficial in larger projects.</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/","title":"Where to Place Your Router Setup","text":"<p>When building a React application, you may wonder where to place your routing logic using React Router. Should it go in <code>index.js</code> or <code>App.js</code>? Understanding the best practices in structuring your application can help ensure scalability and maintainability.</p> <p>Integrating React Router: Where to Place Your Router Setup</p>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#standard-practice-place-the-router-in-appjs","title":"Standard Practice: Place the Router in <code>App.js</code>","text":"Why Use <code>App.js</code> for Routing? <ol> <li> <p>Separation of Concerns: By placing the router in <code>App.js</code>, you keep your routing logic separate from your application entry point. This separation enhances readability and helps manage the complexity of your application as it grows.</p> </li> <li> <p>Component Structure: <code>App.js</code> is designed to be the main component that renders your application\u2019s structure. Adding the router here allows you to encapsulate all your routes and their components in one place. This makes it easier to visualize how different parts of your app interact.</p> </li> <li> <p>Flexibility for Future Enhancements: If you decide to add more complex routing features (like nested routes or context providers), having the router in <code>App.js</code> allows you to manage those changes without cluttering <code>index.js</code>.</p> </li> <li> <p>Consistency with React's Component-Based Architecture: React encourages a component-based approach. By keeping the router in <code>App.js</code>, you align with this philosophy, making your app easier to understand for other developers.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#example-implementation","title":"Example Implementation","text":"<p>Here\u2019s how you can structure your application with React Router in <code>App.js</code>:</p> index.jsApp.js <pre><code>import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n    &lt;React.StrictMode&gt;\n        &lt;App /&gt;\n    &lt;/React.StrictMode&gt;\n);\n</code></pre> <pre><code>import React from \"react\";\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport Home from \"./components/Home\";\nimport About from \"./components/About\";\nimport NotFound from \"./components/NotFound\";\n\nfunction App() {\n    return (\n        &lt;Router&gt;\n            &lt;div className=\"App\"&gt;\n                &lt;header className=\"App-header\"&gt;\n                    &lt;h1&gt;My React App&lt;/h1&gt;\n                &lt;/header&gt;\n                &lt;Routes&gt;\n                    &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;\n                    &lt;Route path=\"/about\" element={&lt;About /&gt;} /&gt;\n                    &lt;Route path=\"*\" element={&lt;NotFound /&gt;} /&gt;\n                &lt;/Routes&gt;\n            &lt;/div&gt;\n        &lt;/Router&gt;\n    );\n}\n\nexport default App;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/08/where-to-place-your-router-setup/#conclusion","title":"Conclusion","text":"<p>By placing the router in <code>App.js</code>, you maintain a clean and organized codebase. This approach not only improves readability but also sets a solid foundation for future enhancements. Following standard practices like this will help you and your team work more efficiently, leading to a more maintainable and scalable React application.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/","title":"Why Props are Objects in React","text":"<p>In React, props (short for \"properties\") are a fundamental concept that enables components to communicate and share data. One of the key reasons props are implemented as objects is to streamline data handling and enhance component reusability. </p> <p>Here\u2019s a closer look at why this design choice is beneficial.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#1-simplicity-of-data-transfer","title":"1. Simplicity of Data Transfer","text":"<p>By using an object to bundle props, React simplifies the process of passing multiple values to a component. Instead of needing to pass individual parameters, developers can group related data together in a single object. For example:</p> <pre><code>&lt;MyComponent name=\"Alice\" age={25} /&gt;\n</code></pre> <p>This translates into a single props object:</p> <pre><code>{\n  name: \"Alice\",\n  age: 25\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#2-flexibility-in-data-types","title":"2. Flexibility in Data Types","text":"<p>Props as objects allow for various data types to be passed seamlessly. A single props object can contain strings, numbers, arrays, functions, or even other objects. This flexibility makes it easy to manage complex data structures without changing the fundamental way props are passed:</p> <pre><code>&lt;MyComponent \n  user={{ id: 1, name: \"Alice\" }} \n  items={[1, 2, 3]} \n  onClick={() =&gt; alert(\"Clicked!\")} \n/&gt;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#3-destructuring-for-cleaner-code","title":"3. Destructuring for Cleaner Code","text":"<p>Using an object allows developers to take advantage of JavaScript destructuring, resulting in cleaner and more readable code. Instead of accessing props with <code>props.name</code>, you can destructure directly in the function signature:</p> <pre><code>function MyComponent({ name, age }) {\n  return &lt;div&gt;{name} is {age} years old.&lt;/div&gt;;\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#4-easier-component-reusability","title":"4. Easier Component Reusability","text":"<p>Since props are objects, you can easily create reusable components by passing different props without altering the component's core functionality. This leads to a more modular design, making your codebase easier to maintain and extend.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#conclusion","title":"Conclusion","text":"<p>Props being objects in React is a deliberate design choice that enhances simplicity, flexibility, and reusability. By allowing multiple data types to be bundled into a single structure, React makes it easier for developers to create dynamic, interactive user interfaces while keeping their code organized and manageable. Understanding this foundational concept is crucial for building efficient React applications.</p>","tags":["react"]},{"location":"programmingNepali/callbackfunction/","title":"callback function","text":""},{"location":"programmingNepali/callbackfunction/#callback-function","title":"Callback Function (\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u090f\u0909\u091f\u093e \u092f\u0938\u094d\u0924\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b \u091c\u0941\u0928 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u0928\u094d\u091b \u0930 \u0924\u094d\u092f\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u090f\u092a\u091b\u093f \u092f\u0938\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u0932\u093e\u0908 \u0938\u093e\u092e\u093e\u0928\u094d\u092f\u0924\u092f\u093e \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923 <pre><code>function calculateSum(a, b, callback) {\n    const sum = a + b; // \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u091b\n    callback(sum);     // \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u092a\u0930\u093f\u0923\u093e\u092e\u0938\u0939\u093f\u0924 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\nfunction printResult(result) {\n    console.log(\"\u0928\u0924\u093f\u091c\u093e \u0939\u094b:\", result);\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\ncalculateSum(5, 3, printResult);\n</code></pre>"},{"location":"programmingNepali/callbackfunction/#inner-function","title":"Inner Function (\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u092d\u093f\u0924\u094d\u0930 \u092a\u0930\u093f\u092d\u093e\u0937\u093f\u0924 \u0917\u0930\u093f\u090f\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u0930 \u0938\u094d\u0915\u094b\u092a\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093f\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u091b\u094c\u0902? <pre><code>function outerFunction() {\n    const greeting = \"\u0928\u092e\u0938\u094d\u0915\u093e\u0930\";\n\n    function innerFunction() {\n        console.log(greeting); // \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u091b\n    }\n\n    innerFunction(); // \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\nouterFunction();\n</code></pre> <ol> <li>\u0915\u094b\u0921\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928: \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0927\u0947\u0930\u0948 \u0938\u092b\u093e \u0930 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942: \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u093f\u0919\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0939\u0941\u0928\u094d\u091b\u0964</li> <li>\u0938\u094d\u0915\u094b\u092a: \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b, \u091c\u0938\u0932\u0947 \u0915\u094b\u0921\u0915\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u0930 \u0935\u094d\u092f\u093e\u0935\u0939\u093e\u0930\u093f\u0915\u0924\u093e \u092c\u0922\u093e\u0909\u0901\u091b\u0964</li> </ol> <p>\u092f\u0940 \u0915\u093e\u0930\u0923\u0932\u0947 \u0917\u0930\u094d\u0926\u093e \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0930 \u0909\u092a\u092f\u094b\u0917\u0940 \u091b\u0928\u094d\u0964</p> <p>why we need to pass function in arguments in another function. explain me in nepali.</p> <p>\u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u092a\u0930\u094d\u0928\u0947 \u0915\u093e\u0930\u0923\u0939\u0930\u0942 \u0924\u0932 \u0935\u094d\u092f\u093e\u0916\u094d\u092f\u093e \u0917\u0930\u093f\u090f\u0915\u093e \u091b\u0928\u094d:</p> <ol> <li> <p>\u0915\u093e\u0930\u094d\u092f\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928 (Separation of Concerns)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u092f\u0938\u0932\u0947 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0905\u0932\u0917 \u0917\u0930\u094d\u0928\u0947 \u092e\u094c\u0915\u093e \u0926\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u092e\u0941\u0916\u094d\u092f \u0915\u093e\u0930\u094d\u092f \u0930 \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0939\u0941\u0928\u0947 \u0915\u093e\u0930\u094d\u092f \u0905\u0932\u0917 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f, \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928 \u0930 \u092a\u0930\u093f\u0923\u093e\u092e\u0932\u093e\u0908 \u092a\u094d\u0930\u0926\u0930\u094d\u0936\u0928 \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u091b\u0941\u091f\u094d\u091f\u0948 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0932\u091a\u093f\u0932\u094b\u092a\u0928 (Flexibility)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u0924\u094d\u092f\u0938\u0915\u094b \u0905\u0930\u094d\u0925 \u0939\u093e\u092e\u0940 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0938\u094b\u0939\u0940 \u092e\u0942\u0932 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0935\u094d\u092f\u0935\u0939\u093e\u0930 \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u094c\u0902\u0964 \u092f\u0938\u0932\u0947 \u0939\u093e\u092e\u0940\u0932\u093e\u0908 \u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e \u0905\u0928\u0941\u0938\u093e\u0930 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u0930\u0939\u0930\u0942 \u092c\u0928\u093e\u0909\u0928\u0947 \u0905\u0935\u0938\u0930 \u0926\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 (Usage in Asynchronous Operations)</p> <p>\u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u0927\u0947\u0930\u0948 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0939\u0941\u0928\u094d\u091b\u0928\u094d, \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u0964 \u091c\u092c \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u0939\u0941\u0928\u094d\u091b, \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0928\u0924\u093f\u091c\u093e \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932 \u0917\u0930\u094d\u0928\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0928\u0924\u093f\u091c\u093e \u092a\u093e\u090f\u0915\u093e \u092c\u0947\u0932\u093e \u0915\u0941\u0928\u0948 \u0935\u093f\u0936\u0947\u0937 \u0915\u093e\u0930\u094d\u092f \u0917\u0930\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> <li> <p>\u0938\u094d\u0915\u094b\u092a\u0915\u094b \u092a\u0939\u0941\u0901\u091a (Access to Scope)</p> <p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0928\u094d\u0964 \u092f\u0938\u0932\u0947 \u092b\u0919\u094d\u0938\u0928\u092d\u093f\u0924\u094d\u0930\u0915\u094b \u0921\u0947\u091f\u093e \u0930 \u0938\u094d\u0925\u093f\u0924\u093f \u0938\u0941\u0930\u0915\u094d\u0937\u093f\u0924 \u0930\u093e\u0916\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u0915\u094b\u0921\u0932\u0947 \u0920\u0942\u0932\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> </ol> \u0909\u0926\u093e\u0939\u0930\u0923\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937 <pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n        callback(data);\n    }, 2000);\n}\n\nfunction handleData(data) {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n}\n\n// \u092f\u0939\u093e\u0901 fetchData \u0932\u093e\u0908 handleData \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u090f\u0915\u094b \u091b\nfetchData(handleData);\n</code></pre> <p>\u092f\u0938\u0948\u0932\u0947, \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u091b\u0964 \u092f\u0938\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b, \u0932\u091a\u093f\u0932\u094b \u0930 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u0937\u092e \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"programmingNepali/callbackfunction/#alternative-to-callback-function","title":"Alternative to callback function","text":"<p>what are the advance alternative to callback function. explain in nepali</p> <p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u091f\u094d\u091f\u093e\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u0947 \u0915\u0947\u0939\u0940 \u0909\u0928\u094d\u0928\u0924 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942 \u0928\u093f\u092e\u094d\u0928\u0932\u093f\u0916\u093f\u0924 \u091b\u0928\u094d:</p> <ol> <li> <p>\u092a\u094d\u0930\u092e\u093f\u0938 (Promises)</p> <p>\u092a\u094d\u0930\u092e\u093f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u092e\u093f\u0932\u094d\u0928\u0947 \u092c\u0928\u093e\u0909\u0901\u091b\u0964 \u092f\u0938\u0932\u0947 \u0926\u0941\u0908 \u092e\u0941\u0916\u094d\u092f \u0905\u0935\u0938\u094d\u0925\u093e\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0926\u091b: \"fulfilled\" (\u0938\u092b\u0932\u0924\u093e) \u0930 \"rejected\" (\u0905\u0938\u094d\u0935\u0940\u0915\u0943\u0924\u093f)\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n            resolve(data); // \u0938\u092b\u0932\u0924\u093e\u0938\u093e\u0925 \u0921\u0947\u091f\u093e \u092a\u0920\u093e\u0909\u0901\u091b\n        }, 2000);\n    });\n}\n\nfetchData()\n    .then(data =&gt; {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    })\n    .catch(error =&gt; {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    });\n</code></pre> </li> <li> <p>Async/Await</p> <p>Async/Await \u092a\u094d\u0930\u092e\u093f\u0938\u0939\u0930\u0942\u0915\u094b \u0905\u0927\u093f\u0915 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u0920\u0928\u0940\u092f\u0924\u093e \u092d\u090f\u0915\u094b \u0924\u0930\u093f\u0915\u093e \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u094b\u0921\u0932\u093e\u0908 \u0938\u092e\u093e\u0928\u094d\u092f \u0915\u094b\u0921 \u091c\u0938\u094d\u0924\u0948 \u0932\u0947\u0916\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>async function getData() {\n    try {\n        const data = await fetchData(); // \u092a\u094d\u0930\u092e\u093f\u0938\u0915\u094b \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u092a\u094d\u0930\u0924\u0940\u0915\u094d\u0937\u093e \u0917\u0930\u094d\u091b\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    } catch (error) {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    }\n}\n\ngetData();\n</code></pre> </li> <li> <p>Observables (RxJS)</p> <p>Observables\u0932\u0947 \u0921\u0947\u091f\u093e \u0938\u094d\u091f\u094d\u0930\u0940\u092e\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0902\u0932\u093e\u0908 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0918\u091f\u0928\u093e\u0939\u0930\u0942\u0915\u094b \u0938\u0941\u091a\u0928\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b \u0930 \u0927\u0947\u0930\u0948 \u0936\u0915\u094d\u0924\u093f\u0936\u093e\u0932\u0940 \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>import { Observable } from 'rxjs';\n\nconst dataObservable = new Observable(subscriber =&gt; {\n    setTimeout(() =&gt; {\n        subscriber.next({ id: 1, name: \"\u0930\u093e\u092e\" });\n        subscriber.complete(); // \u0938\u092e\u093e\u092a\u094d\u0924\n    }, 2000);\n});\n\ndataObservable.subscribe({\n    next(data) {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    },\n    complete() {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u0915\u094d\u0930\u093f\u092f\u093e \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u092f\u094b\");\n    }\n});\n</code></pre> </li> <li> <p>Event Emitter</p> <p>Event Emitter\u0939\u0930\u0942\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f \u0921\u094d\u0930\u093f\u092d\u0928 \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919\u0915\u094b \u0932\u093e\u0917\u093f \u0909\u092a\u092f\u0941\u0915\u094d\u0924 \u0939\u0941\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u0941\u0928\u094d\u0928 \u0930 \u0924\u093f\u0928\u0940\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>const EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\nmyEmitter.on('dataReceived', (data) =&gt; {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n});\n\n// \u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u0907\u092d\u0947\u0928\u094d\u091f\u0932\u093e\u0908 \u091f\u094d\u0930\u093f\u0917\u0930 \u0917\u0930\u094d\u091b\nsetTimeout(() =&gt; {\n    myEmitter.emit('dataReceived', { id: 1, name: \"\u0930\u093e\u092e\" });\n}, 2000);\n</code></pre> </li> </ol> <p>\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937</p> <p>\u092f\u0940 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942\u0932\u0947 \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u0940\u092e\u093e\u0939\u0930\u0942 \u0930 \u091c\u091f\u093f\u0932\u0924\u093e\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u092e\u0947\u091f\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092a\u094d\u0930\u092e\u093f\u0938, Async/Await, Observables, \u0930 Event Emitters\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b, \u092a\u0920\u0928\u0940\u092f \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"programmingNepali/intro/","title":"Intro","text":""},{"location":"programmingNepali/intro/#in-nepali","title":"In Nepali","text":""},{"location":"reactPattern/functional-pattern-and-technique/","title":"Functional Pattern & Technique","text":"<p>Functional Patterns and Techniques in React</p>"},{"location":"reactPattern/functional-pattern-and-technique/#1-functional-components","title":"1. Functional Components","text":"<p>Use functional components instead of class components for simpler syntax and hooks.</p> <pre><code>const MyComponent = () =&gt; {\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#2-hooks","title":"2. Hooks","text":"<p>Leverage React hooks for state and side effects.</p> a. useStateb. useEffect <p>Manage state in functional components.</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <p>Handle side effects like data fetching and subscriptions.</p> <pre><code>import React, { useEffect, useState } from 'react';\n\nconst DataFetcher = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; setData(data));\n    }, []); // Empty array means this runs once on mount\n\n    return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>Encapsulate logic for reuse.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then(response =&gt; response.json())\n      .then(data =&gt; setData(data));\n  }, [url]);\n\n  return data;\n};\n\n// Usage\nconst DataDisplay = () =&gt; {\n  const data = useFetch('https://api.example.com/data');\n  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#4-context-api","title":"4. Context API","text":"<p>Share state across components without prop drilling.</p> a. Create Context <pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [value, setValue] = useState('Default Value');\n\n    return (\n        &lt;MyContext.Provider value={{ value, setValue }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n\n// Usage\nconst Component = () =&gt; {\n    const { value, setValue } = useContext(MyContext);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;{value}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setValue('New Value')}&gt;Change Value&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#5-memoization","title":"5. Memoization","text":"<p>Optimize performance with <code>React.memo</code> and <code>useMemo</code>.</p> a. React.memob. useMemo <p>Prevent unnecessary re-renders.</p> <pre><code>const MyComponent = React.memo(({ value }) =&gt; {\n    console.log('Rendered');\n    return &lt;div&gt;{value}&lt;/div&gt;;\n});\n</code></pre> <p>Memoize expensive calculations.</p> <pre><code>import { useMemo } from 'react';\n\nconst ExpensiveComponent = ({ num }) =&gt; {\n    const computedValue = useMemo(() =&gt; {\n        // Expensive calculation\n        return num * 2;\n    }, [num]);\n\n    return &lt;div&gt;{computedValue}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#6-rendering-lists","title":"6. Rendering Lists","text":"<p>Render dynamic lists efficiently.</p> <pre><code>const ItemList = ({ items }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {items.map(item =&gt; (\n        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#7-render-props","title":"7. Render Props","text":"<p>This pattern involves passing a function as a prop to a component, allowing for more flexible and reusable components.</p> <pre><code>const RenderPropComponent = ({ render }) =&gt; {\n  return &lt;div&gt;{render()}&lt;/div&gt;;\n};\n\n// Usage\n&lt;RenderPropComponent render={() =&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;} /&gt;;\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#conclusion","title":"Conclusion","text":"<p>Using functional patterns and techniques in React can lead to cleaner, more maintainable code. Embrace hooks, context, and optimization strategies to enhance your React applications!</p>"},{"location":"reactPattern/functional-updated-pattern/","title":"Functional Update Pattern","text":"<p>Understanding the Functional Update Pattern in React: Techniques and Related Patterns</p>"},{"location":"reactPattern/functional-updated-pattern/#functional-update-pattern","title":"Functional Update Pattern","text":"<p>Definition</p> <p>The Functional Update Pattern is a technique used in React to update state based on the previous state. This is particularly useful in scenarios where state updates are dependent on the current state value, ensuring that updates are not lost due to asynchronous behavior.</p> <p>Usage</p> <p>You typically use this pattern with the <code>setState</code> function from the <code>useState</code> hook, or in class components with <code>this.setState</code>.</p> <p>Example</p> <p>Using <code>useState</code></p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount(prevCount =&gt; prevCount + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Benefits</p> <ul> <li>Avoid Race Conditions: By using the previous state as an input for the new state, you avoid issues that can arise from multiple updates occurring in quick succession.</li> </ul>"},{"location":"reactPattern/functional-updated-pattern/#related-patterns","title":"Related Patterns","text":"<ol> <li> <p>Callback Functions with State</p> <ul> <li>Similar to the Functional Update Pattern, you can provide a function to <code>setState</code> that takes the previous state and returns the new state.</li> </ul> <pre><code>const toggle = () =&gt; {\n    setIsActive(prev =&gt; !prev);\n};\n</code></pre> </li> <li> <p>Reducer Pattern</p> <ul> <li> <p>Using <code>useReducer</code> for more complex state management. This pattern involves defining a reducer function that updates state based on actions.</p> <pre><code>const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n\nconst Counter = () =&gt; {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        &lt;div&gt;\n            Count: {state.count}\n            &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;+&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;-&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> </li> </ul> </li> <li> <p>Controlled <code>vs.</code> Uncontrolled Components</p> <ul> <li>Controlled components manage their own state, while uncontrolled components rely on the DOM for state. Controlled components often use the Functional Update Pattern for form inputs.</li> </ul> <pre><code>const ControlledInput = () =&gt; {\n    const [value, setValue] = useState('');\n\n    return (\n        &lt;input\n            value={value}\n            onChange={e =&gt; setValue(e.target.value)}\n        /&gt;\n    );\n};\n</code></pre> </li> <li> <p>Context API with Functional Updates</p> <ul> <li> <p>When using the Context API, you can employ the Functional Update Pattern to manage global state efficiently.</p> <pre><code>const MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [state, setState] = useState({ count: 0 });\n\n    const increment = () =&gt; {\n        setState(prevState =&gt; ({ count: prevState.count + 1 }));\n    };\n\n    return (\n        &lt;MyContext.Provider value={{ state, increment }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"reactPattern/functional-updated-pattern/#conclusion","title":"Conclusion","text":"<p>The Functional Update Pattern is a key technique in React for managing state updates that depend on previous state values. It promotes better state management and prevents common pitfalls associated with asynchronous updates. Other patterns, like using reducers and the Context API, can complement this approach for more complex applications.</p>"},{"location":"reactPattern/when-not-to-use-functional-update/","title":"When not to use Functional Update","text":"<p>Certainly! Here are some guidelines on when to use the Functional Update Pattern in React, as well as situations where it may not be necessary:</p>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-to-use-the-functional-update-pattern","title":"When to Use the Functional Update Pattern","text":"<ol> <li> <p>Dependent State Updates:</p> <ul> <li> <p>Use it when the new state depends on the previous state. This is especially important in cases where state updates may be batched or occur asynchronously.</p> <pre><code>setCount(prevCount =&gt; prevCount + 1);\n</code></pre> </li> </ul> </li> <li> <p>Multiple Updates in Quick Succession:</p> <ul> <li>If you have multiple state updates that rely on the current value (e.g., in event handlers), the Functional Update Pattern helps prevent race conditions.</li> </ul> <pre><code>const handleMultipleClicks = () =&gt; {\n    setCount(prev =&gt; prev + 1);\n    setCount(prev =&gt; prev + 1); // Both updates are based on the latest state\n};\n</code></pre> </li> <li> <p>Complex State Logic:</p> <p>When managing complex state transitions that might involve conditions, using a function to handle state updates can improve clarity.</p> <pre><code>setState(prevState =&gt; {\n    // complex logic based on prevState\n});\n</code></pre> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-not-to-use-the-functional-update-pattern","title":"When Not to Use the Functional Update Pattern","text":"<ol> <li> <p>Simple Static Updates:</p> <ul> <li> <p>If you're setting state to a constant value or not relying on the previous state, using the Functional Update Pattern is unnecessary.</p> <pre><code>setCount(10); // Direct assignment is simpler here\n</code></pre> </li> </ul> </li> <li> <p>No Dependency on Previous State:</p> <ul> <li>If the new state does not depend on the current state (e.g., setting a fixed value or fetching new data), you can set the state directly.</li> </ul> </li> <li> <p>Performance Concerns:</p> <ul> <li>In rare cases, excessive use of functional updates may introduce unnecessary complexity or performance overhead if not needed. However, this is generally not a significant concern.</li> </ul> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#summary","title":"Summary","text":"<ul> <li>Use the Functional Update Pattern when state updates depend on previous values, especially in situations with multiple rapid updates.</li> <li>Avoid it for simple or static updates where the current state is not relevant.</li> </ul> <p>This approach helps maintain clarity and prevents bugs in your React applications!</p>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}