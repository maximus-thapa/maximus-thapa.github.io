{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#javascript-compiler","title":"JavaScript Compiler","text":"<p>programiz.com/javascript/online-compiler/</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/","title":"The Functional Update Pattern Explained","text":"<p>The functional update pattern in React is a method of updating state by using a function that takes the previous state as an argument. This pattern ensures that you always work with the most current state value, which is especially important in scenarios where state updates may be batched or occur in quick succession.</p> <p>Mastering State Management in React: The Functional Update Pattern Explained</p>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#key-features-of-the-functional-update-pattern","title":"Key Features of the Functional Update Pattern","text":"<ol> <li> <p>Access to Previous State:</p> <ul> <li>The function you provide to the state updater (like setState) receives the previous state as an argument. This allows you to derive the new state based on the most recent value.</li> </ul> </li> <li> <p>Asynchronous Updates:</p> <ul> <li>React's state updates can be asynchronous. By using the functional update pattern, you avoid issues that can arise from referencing a stale state value.</li> </ul> </li> <li> <p>Prevents Bugs:</p> <ul> <li>When multiple updates depend on the previous state, using this pattern can prevent bugs related to incorrect state values due to overlapping updates.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#example-of-the-functional-update-pattern","title":"Example of the Functional Update Pattern","text":"<p>Here\u2019s a simple example using a counter component:</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount((prevCount) =&gt; prevCount + 1); // Using functional update\n  };\n\n  const decrement = () =&gt; {\n    setCount((prevCount) =&gt; prevCount - 1); // Using functional update\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Count: {count}&lt;/h1&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Counter;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#why-use-the-functional-update-pattern","title":"Why Use the Functional Update Pattern?","text":"<ol> <li>Accuracy: Ensures that you are working with the latest state value, preventing errors due to outdated references.</li> <li>Simplicity: Keeps your state updates straightforward and clear, especially when the new state depends on the previous state.</li> <li>Better Performance: Helps React optimize re-renders, as it can determine more efficiently when state updates occur.</li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/the-functional-update-pattern-explained/#conclusion","title":"Conclusion","text":"<p>The functional update pattern is an essential technique in React for managing state updates accurately. By utilizing this pattern, you can create more reliable and maintainable components, ensuring that your application behaves as expected even in complex scenarios.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/","title":"Understanding the Importance of Using Previous State in React","text":"<p>In React, managing state efficiently is crucial for building responsive and bug-free applications. One common practice that developers should adopt is using the previous state when updating state values.</p> <p>This simple pattern can prevent a range of issues related to state management, especially in dynamic applications where multiple updates may occur rapidly.</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#why-use-previous-state","title":"Why Use Previous State?","text":"<ol> <li> <p>Accurate Updates:</p> <p>When you use the previous state, you ensure that each update is based on the most current value. This is particularly important when multiple state updates are triggered in quick succession. If you simply rely on the current state, you risk missing updates, leading to incorrect values.</p> <p>For example:</p> <pre><code>setCount(count + 1); // May lead to missed increments\n</code></pre> <p>Instead, using the previous state guarantees accurate calculations:</p> <pre><code>setCount((prevCount) =&gt; prevCount + 1); // Safely increments the count\n</code></pre> </li> <li> <p>Functional Updates:</p> <p>React allows state updates to be made using a function that receives the previous state as an argument. This functional update pattern enhances clarity and ensures that you\u2019re working with the most recent state.</p> <pre><code>setCount((prevCount) =&gt; prevCount - 1); // Decrements reliably\n</code></pre> </li> <li> <p>Asynchronous Nature of State Updates:</p> <p>React state updates are asynchronous, meaning they don\u2019t occur immediately. Without using the previous state, you might inadvertently work with a stale value, leading to unexpected behavior in your application.</p> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#conclusion","title":"Conclusion","text":"<p>Using the previous state when updating values in React is a best practice that enhances the reliability and accuracy of your state management. By adopting this pattern, developers can avoid potential bugs and ensure that their components respond correctly to user interactions. Next time you\u2019re updating state, remember to use (prevState) to maintain the integrity of your application\u2019s data flow!</p>","tags":["react"]},{"location":"blog/2024/07/02/understanding-the-importance-of-using-previous-state-in-react/#additional","title":"Additional","text":"ExampleExplanationConclusion <pre><code>import React, { useState } from 'react';\n\nconst ItemList = () =&gt; {\n    const [items, setItems] = useState([\n        { id: 1, name: 'Item 1' },\n        { id: 2, name: 'Item 2' },\n    ]);\n\n    const [newItemName, setNewItemName] = useState('');\n\n    // Adding an item using previous state\n    const addItem = () =&gt; {\n        if (newItemName.trim() === '') return; // Prevent adding empty items\n            const newItem = {\n            id: items.length + 1, // Simple ID generation\n            name: newItemName,\n        };\n        setItems((prevItems) =&gt; [...prevItems, newItem]); // Use previous state to add a new item\n        setNewItemName(''); // Clear input field\n    };\n\n    // Removing an item using previous state\n    const removeItem = (id) =&gt; {\n        setItems((prevItems) =&gt; prevItems.filter(item =&gt; item.id !== id)); // Use previous state to filter out the item\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Item List&lt;/h1&gt;\n            &lt;input\n                type=\"text\"\n                value={newItemName}\n                onChange={(e) =&gt; setNewItemName(e.target.value)} // Handle input change\n                placeholder=\"Add new item\"\n            /&gt;\n            &lt;button onClick={addItem}&gt;Add Item&lt;/button&gt;\n\n            &lt;ul&gt;\n                {items.map((item) =&gt; (\n                &lt;li key={item.id}&gt;\n                    {item.name}\n                    &lt;button onClick={() =&gt; removeItem(item.id)}&gt;Remove&lt;/button&gt;\n                &lt;/li&gt;\n                ))}\n            &lt;/ul&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default ItemList;\n</code></pre> <ol> <li> <p>State Management:</p> <ul> <li><code>items</code>: An array of objects representing the list of items, where each object has an <code>id</code> and a <code>name</code>.</li> <li><code>newItemName</code>: A string for the input field to capture the new item's name.</li> </ul> </li> <li> <p>Using Previous State:</p> <ul> <li>Adding Items: When adding a new item, we use the previous state with <code>setItems((prevItems) =&gt; [...prevItems, newItem])</code>. This ensures that we're working with the most current version of the <code>items</code> array.</li> <li>Removing Items: The <code>removeItem</code> function also utilizes the previous state to filter out the item by its ID, ensuring that we accurately reflect the current list.</li> </ul> </li> <li> <p>Rendering:</p> <ul> <li>An input field captures the new item's name, and a button adds it to the list.</li> <li>The list of items is displayed, with a \"Remove\" button for each item that allows users to delete it.</li> </ul> </li> </ol> <p>Using the previous state when managing complex data structures like lists in React is crucial for maintaining data integrity. It helps ensure that updates reflect the current state accurately, especially in scenarios involving asynchronous updates or multiple rapid interactions. By adopting this practice, developers can create more reliable and bug-free applications.</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/","title":"React State Updates Explained","text":"<p>Certainly! Let\u2019s explore the concept of asynchronous state updates in React with a detailed example.</p> <p>React State Updates Explained: The Importance of Asynchronous Behavior</p>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#example-understanding-asynchronous-state-updates","title":"Example: Understanding Asynchronous State Updates","text":"<p>Suppose we have a simple counter component that increments the count when a button is clicked.</p> Initial Component Without Functional UpdatesWhat Happens Here? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount(count + 1); // Attempt to increment the count\n        setCount(count + 2); // Attempt to increment the count again\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>When you click the \"Increment\" button, the <code>handleIncrement</code> function is called.</li> <li>The first <code>setCount(count + 1)</code> is executed, but it doesn't update the state immediately.</li> <li>The second <code>setCount(count + 2)</code> is called right after, referencing the same initial <code>count</code> value.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, both updates reference the same value, and you may expect the count to be 3 (0 + 1 + 2). However, because the updates are batched, the final state remains 2 (0 + 2) instead of 3.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#fixing-it-with-functional-updates","title":"Fixing It with Functional Updates","text":"<p>To correctly manage the updates, we can use the functional update pattern:</p> ExampleWhat Happens Now? <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n\n    const handleIncrement = () =&gt; {\n        setCount((prevCount) =&gt; prevCount + 1); // Correctly increments by 1\n        setCount((prevCount) =&gt; prevCount + 2); // Correctly increments by 2\n    };\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Count: {count}&lt;/h1&gt;\n            &lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Counter;\n</code></pre> <ol> <li> <p>Clicking the Button:</p> <ul> <li>The first <code>setCount</code> now uses the previous state <code>prevCount</code> to increment the count by 1.</li> <li>The second <code>setCount</code> also uses the latest <code>prevCount</code>, which is now updated.</li> </ul> </li> <li> <p>Result:</p> <ul> <li>If <code>count</code> was initially 0, the first update correctly sets it to 1, and the second update then sets it to 3 (1 + 2). This yields the expected behavior.</li> </ul> </li> </ol>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#summary-of-asynchronous-updates","title":"Summary of Asynchronous Updates","text":"<ul> <li>Batched Updates: In the initial example, React batched the updates. The state didn\u2019t update immediately after each call, which led to unexpected results.</li> <li>Using Previous State: By using the functional update pattern, you ensure each update correctly references the most recent state value.</li> <li>Performance and Consistency: This pattern prevents potential issues and allows React to optimize rendering, providing a smoother user experience.</li> </ul>","tags":["react"]},{"location":"blog/2024/07/03/react-state-updates-explained/#conclusion","title":"Conclusion","text":"<p>Understanding how asynchronous state updates work in React helps developers avoid common pitfalls and write more reliable code. Using functional updates ensures that state changes are predictable and accurate, especially in scenarios with multiple rapid updates.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/","title":"Why Props are Objects in React","text":"<p>In React, props (short for \"properties\") are a fundamental concept that enables components to communicate and share data. One of the key reasons props are implemented as objects is to streamline data handling and enhance component reusability. </p> <p>Here\u2019s a closer look at why this design choice is beneficial.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#1-simplicity-of-data-transfer","title":"1. Simplicity of Data Transfer","text":"<p>By using an object to bundle props, React simplifies the process of passing multiple values to a component. Instead of needing to pass individual parameters, developers can group related data together in a single object. For example:</p> <pre><code>&lt;MyComponent name=\"Alice\" age={25} /&gt;\n</code></pre> <p>This translates into a single props object:</p> <pre><code>{\n  name: \"Alice\",\n  age: 25\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#2-flexibility-in-data-types","title":"2. Flexibility in Data Types","text":"<p>Props as objects allow for various data types to be passed seamlessly. A single props object can contain strings, numbers, arrays, functions, or even other objects. This flexibility makes it easy to manage complex data structures without changing the fundamental way props are passed:</p> <pre><code>&lt;MyComponent \n  user={{ id: 1, name: \"Alice\" }} \n  items={[1, 2, 3]} \n  onClick={() =&gt; alert(\"Clicked!\")} \n/&gt;\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#3-destructuring-for-cleaner-code","title":"3. Destructuring for Cleaner Code","text":"<p>Using an object allows developers to take advantage of JavaScript destructuring, resulting in cleaner and more readable code. Instead of accessing props with <code>props.name</code>, you can destructure directly in the function signature:</p> <pre><code>function MyComponent({ name, age }) {\n  return &lt;div&gt;{name} is {age} years old.&lt;/div&gt;;\n}\n</code></pre>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#4-easier-component-reusability","title":"4. Easier Component Reusability","text":"<p>Since props are objects, you can easily create reusable components by passing different props without altering the component's core functionality. This leads to a more modular design, making your codebase easier to maintain and extend.</p>","tags":["react"]},{"location":"blog/2024/07/04/why-props-are-objects-in-react/#conclusion","title":"Conclusion","text":"<p>Props being objects in React is a deliberate design choice that enhances simplicity, flexibility, and reusability. By allowing multiple data types to be bundled into a single structure, React makes it easier for developers to create dynamic, interactive user interfaces while keeping their code organized and manageable. Understanding this foundational concept is crucial for building efficient React applications.</p>","tags":["react"]},{"location":"programmingNepali/callbackfunction/","title":"callback function","text":""},{"location":"programmingNepali/callbackfunction/#callback-function","title":"Callback Function (\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u090f\u0909\u091f\u093e \u092f\u0938\u094d\u0924\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b \u091c\u0941\u0928 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u0928\u094d\u091b \u0930 \u0924\u094d\u092f\u094b \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u090f\u092a\u091b\u093f \u092f\u0938\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u0932\u093e\u0908 \u0938\u093e\u092e\u093e\u0928\u094d\u092f\u0924\u092f\u093e \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923 <pre><code>function calculateSum(a, b, callback) {\n    const sum = a + b; // \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u091b\n    callback(sum);     // \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u092a\u0930\u093f\u0923\u093e\u092e\u0938\u0939\u093f\u0924 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\nfunction printResult(result) {\n    console.log(\"\u0928\u0924\u093f\u091c\u093e \u0939\u094b:\", result);\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\ncalculateSum(5, 3, printResult);\n</code></pre>"},{"location":"programmingNepali/callbackfunction/#inner-function","title":"Inner Function (\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928)","text":"<p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928 \u092d\u0928\u0947\u0915\u094b \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u092d\u093f\u0924\u094d\u0930 \u092a\u0930\u093f\u092d\u093e\u0937\u093f\u0924 \u0917\u0930\u093f\u090f\u0915\u094b \u092b\u0919\u094d\u0938\u0928 \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u0930 \u0938\u094d\u0915\u094b\u092a\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093f\u0928 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u091b\u094c\u0902? <pre><code>function outerFunction() {\n    const greeting = \"\u0928\u092e\u0938\u094d\u0915\u093e\u0930\";\n\n    function innerFunction() {\n        console.log(greeting); // \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932 \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u091b\n    }\n\n    innerFunction(); // \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0915\u0932 \u0917\u0930\u094d\u091b\n}\n\n// \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0926\u0948\nouterFunction();\n</code></pre> <ol> <li>\u0915\u094b\u0921\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928: \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u0927\u0947\u0930\u0948 \u0938\u092b\u093e \u0930 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</li> <li>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942: \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u093f\u0919\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0939\u0941\u0928\u094d\u091b\u0964</li> <li>\u0938\u094d\u0915\u094b\u092a: \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b, \u091c\u0938\u0932\u0947 \u0915\u094b\u0921\u0915\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u0930 \u0935\u094d\u092f\u093e\u0935\u0939\u093e\u0930\u093f\u0915\u0924\u093e \u092c\u0922\u093e\u0909\u0901\u091b\u0964</li> </ol> <p>\u092f\u0940 \u0915\u093e\u0930\u0923\u0932\u0947 \u0917\u0930\u094d\u0926\u093e \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u0930 \u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u0930 \u0909\u092a\u092f\u094b\u0917\u0940 \u091b\u0928\u094d\u0964</p> <p>why we need to pass function in arguments in another function. explain me in nepali.</p> <p>\u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941\u092a\u0930\u094d\u0928\u0947 \u0915\u093e\u0930\u0923\u0939\u0930\u0942 \u0924\u0932 \u0935\u094d\u092f\u093e\u0916\u094d\u092f\u093e \u0917\u0930\u093f\u090f\u0915\u093e \u091b\u0928\u094d:</p> <ol> <li> <p>\u0915\u093e\u0930\u094d\u092f\u0915\u094b \u0935\u093f\u092d\u093e\u091c\u0928 (Separation of Concerns)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u092f\u0938\u0932\u0947 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0905\u0932\u0917 \u0917\u0930\u094d\u0928\u0947 \u092e\u094c\u0915\u093e \u0926\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u092e\u0941\u0916\u094d\u092f \u0915\u093e\u0930\u094d\u092f \u0930 \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0939\u0941\u0928\u0947 \u0915\u093e\u0930\u094d\u092f \u0905\u0932\u0917 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u0909\u0926\u093e\u0939\u0930\u0923\u0915\u093e \u0932\u093e\u0917\u093f, \u0917\u0923\u0928\u093e \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928 \u0930 \u092a\u0930\u093f\u0923\u093e\u092e\u0932\u093e\u0908 \u092a\u094d\u0930\u0926\u0930\u094d\u0936\u0928 \u0917\u0930\u094d\u0928\u0947 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u091b\u0941\u091f\u094d\u091f\u0948 \u0930\u093e\u0916\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0932\u091a\u093f\u0932\u094b\u092a\u0928 (Flexibility)</p> <p>\u091c\u092c \u0939\u093e\u092e\u0940 \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u091b\u094c\u0902, \u0924\u094d\u092f\u0938\u0915\u094b \u0905\u0930\u094d\u0925 \u0939\u093e\u092e\u0940 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942 \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u0947\u0930 \u0938\u094b\u0939\u0940 \u092e\u0942\u0932 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0935\u094d\u092f\u0935\u0939\u093e\u0930 \u092a\u0930\u093f\u0935\u0930\u094d\u0924\u0928 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u094c\u0902\u0964 \u092f\u0938\u0932\u0947 \u0939\u093e\u092e\u0940\u0932\u093e\u0908 \u0906\u0935\u0936\u094d\u092f\u0915\u0924\u093e \u0905\u0928\u0941\u0938\u093e\u0930 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932\u0930\u0939\u0930\u0942 \u092c\u0928\u093e\u0909\u0928\u0947 \u0905\u0935\u0938\u0930 \u0926\u093f\u0928\u094d\u091b\u0964</p> </li> <li> <p>\u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 (Usage in Asynchronous Operations)</p> <p>\u091c\u093e\u092d\u093e\u0938\u094d\u0915\u094d\u0930\u093f\u092a\u094d\u091f\u092e\u093e \u0927\u0947\u0930\u0948 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0939\u0941\u0928\u094d\u091b\u0928\u094d, \u091c\u0938\u094d\u0924\u0948 API \u0915\u0932\u0939\u0930\u0942\u0964 \u091c\u092c \u0915\u0941\u0928\u0948 \u0915\u093e\u0930\u094d\u092f \u0938\u092e\u093e\u092a\u094d\u0924 \u0939\u0941\u0928\u094d\u091b, \u0924\u094d\u092f\u0938\u092a\u091b\u093f \u0928\u0924\u093f\u091c\u093e \u0939\u094d\u092f\u093e\u0928\u094d\u0921\u0932 \u0917\u0930\u094d\u0928\u0915\u093e \u0932\u093e\u0917\u093f \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0928\u0924\u093f\u091c\u093e \u092a\u093e\u090f\u0915\u093e \u092c\u0947\u0932\u093e \u0915\u0941\u0928\u0948 \u0935\u093f\u0936\u0947\u0937 \u0915\u093e\u0930\u094d\u092f \u0917\u0930\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> <li> <p>\u0938\u094d\u0915\u094b\u092a\u0915\u094b \u092a\u0939\u0941\u0901\u091a (Access to Scope)</p> <p>\u0907\u0928\u0930 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0932\u0947 \u092c\u093e\u0939\u093f\u0930\u0940 \u092b\u0919\u094d\u0938\u0928\u0915\u093e \u092d\u0947\u0930\u093f\u090f\u092c\u0932\u0939\u0930\u0942\u092e\u093e \u092a\u0939\u0941\u0901\u091a \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u091b\u0928\u094d\u0964 \u092f\u0938\u0932\u0947 \u092b\u0919\u094d\u0938\u0928\u092d\u093f\u0924\u094d\u0930\u0915\u094b \u0921\u0947\u091f\u093e \u0930 \u0938\u094d\u0925\u093f\u0924\u093f \u0938\u0941\u0930\u0915\u094d\u0937\u093f\u0924 \u0930\u093e\u0916\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092f\u0938\u092c\u093e\u091f \u0915\u094b\u0921\u0932\u0947 \u0920\u0942\u0932\u094b \u0932\u091a\u093f\u0932\u094b\u092a\u0928 \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u091b\u0964</p> </li> </ol> \u0909\u0926\u093e\u0939\u0930\u0923\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937 <pre><code>function fetchData(callback) {\n    setTimeout(() =&gt; {\n        const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n        callback(data);\n    }, 2000);\n}\n\nfunction handleData(data) {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n}\n\n// \u092f\u0939\u093e\u0901 fetchData \u0932\u093e\u0908 handleData \u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u093f\u090f\u0915\u094b \u091b\nfetchData(handleData);\n</code></pre> <p>\u092f\u0938\u0948\u0932\u0947, \u092b\u0919\u094d\u0938\u0928\u0932\u093e\u0908 \u0905\u0930\u094d\u0915\u094b \u092b\u0919\u094d\u0938\u0928\u0915\u094b \u0906\u0930\u094d\u0917\u094d\u092f\u0941\u092e\u0947\u0928\u094d\u091f\u0915\u094b \u0930\u0942\u092a\u092e\u093e \u092a\u093e\u0938 \u0917\u0930\u094d\u0928\u0941 \u092e\u0939\u0924\u094d\u0924\u094d\u0935\u092a\u0942\u0930\u094d\u0923 \u091b\u0964 \u092f\u0938\u0932\u0947 \u0915\u094b\u0921\u0932\u093e\u0908 \u092e\u0930\u094d\u092e\u0924 \u0917\u0930\u094d\u0928 \u0938\u091c\u093f\u0932\u094b, \u0932\u091a\u093f\u0932\u094b \u0930 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u092e\u093e \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0938\u0915\u094d\u0937\u092e \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"programmingNepali/callbackfunction/#alternative-to-callback-function","title":"Alternative to callback function","text":"<p>what are the advance alternative to callback function. explain in nepali</p> <p>\u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u091f\u094d\u091f\u093e\u092e\u093e \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u094d\u0928 \u0938\u0915\u093f\u0928\u0947 \u0915\u0947\u0939\u0940 \u0909\u0928\u094d\u0928\u0924 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942 \u0928\u093f\u092e\u094d\u0928\u0932\u093f\u0916\u093f\u0924 \u091b\u0928\u094d:</p> <ol> <li> <p>\u092a\u094d\u0930\u092e\u093f\u0938 (Promises)</p> <p>\u092a\u094d\u0930\u092e\u093f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u092e\u093f\u0932\u094d\u0928\u0947 \u092c\u0928\u093e\u0909\u0901\u091b\u0964 \u092f\u0938\u0932\u0947 \u0926\u0941\u0908 \u092e\u0941\u0916\u094d\u092f \u0905\u0935\u0938\u094d\u0925\u093e\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0926\u091b: \"fulfilled\" (\u0938\u092b\u0932\u0924\u093e) \u0930 \"rejected\" (\u0905\u0938\u094d\u0935\u0940\u0915\u0943\u0924\u093f)\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>function fetchData() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            const data = { id: 1, name: \"\u0930\u093e\u092e\" };\n            resolve(data); // \u0938\u092b\u0932\u0924\u093e\u0938\u093e\u0925 \u0921\u0947\u091f\u093e \u092a\u0920\u093e\u0909\u0901\u091b\n        }, 2000);\n    });\n}\n\nfetchData()\n    .then(data =&gt; {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    })\n    .catch(error =&gt; {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    });\n</code></pre> </li> <li> <p>Async/Await</p> <p>Async/Await \u092a\u094d\u0930\u092e\u093f\u0938\u0939\u0930\u0942\u0915\u094b \u0905\u0927\u093f\u0915 \u0938\u091c\u093f\u0932\u094b \u0930 \u092a\u0920\u0928\u0940\u092f\u0924\u093e \u092d\u090f\u0915\u094b \u0924\u0930\u093f\u0915\u093e \u0939\u094b\u0964 \u092f\u0938\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u094b\u0921\u0932\u093e\u0908 \u0938\u092e\u093e\u0928\u094d\u092f \u0915\u094b\u0921 \u091c\u0938\u094d\u0924\u0948 \u0932\u0947\u0916\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>async function getData() {\n    try {\n        const data = await fetchData(); // \u092a\u094d\u0930\u092e\u093f\u0938\u0915\u094b \u092a\u0930\u093f\u0923\u093e\u092e\u0915\u094b \u092a\u094d\u0930\u0924\u0940\u0915\u094d\u0937\u093e \u0917\u0930\u094d\u091b\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    } catch (error) {\n        console.log(\"\u0924\u094d\u0930\u0941\u091f\u093f:\", error);\n    }\n}\n\ngetData();\n</code></pre> </li> <li> <p>Observables (RxJS)</p> <p>Observables\u0932\u0947 \u0921\u0947\u091f\u093e \u0938\u094d\u091f\u094d\u0930\u0940\u092e\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u092a\u094d\u0930\u092f\u094b\u0917 \u0917\u0930\u093f\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0924\u092a\u093e\u0908\u0902\u0932\u093e\u0908 \u0935\u093f\u092d\u093f\u0928\u094d\u0928 \u0918\u091f\u0928\u093e\u0939\u0930\u0942\u0915\u094b \u0938\u0941\u091a\u0928\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b \u0930 \u0927\u0947\u0930\u0948 \u0936\u0915\u094d\u0924\u093f\u0936\u093e\u0932\u0940 \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>import { Observable } from 'rxjs';\n\nconst dataObservable = new Observable(subscriber =&gt; {\n    setTimeout(() =&gt; {\n        subscriber.next({ id: 1, name: \"\u0930\u093e\u092e\" });\n        subscriber.complete(); // \u0938\u092e\u093e\u092a\u094d\u0924\n    }, 2000);\n});\n\ndataObservable.subscribe({\n    next(data) {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n    },\n    complete() {\n        console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u0915\u094d\u0930\u093f\u092f\u093e \u0938\u092e\u093e\u092a\u094d\u0924 \u092d\u092f\u094b\");\n    }\n});\n</code></pre> </li> <li> <p>Event Emitter</p> <p>Event Emitter\u0939\u0930\u0942\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f \u0921\u094d\u0930\u093f\u092d\u0928 \u092a\u094d\u0930\u094b\u0917\u094d\u0930\u093e\u092e\u093f\u0919\u0915\u094b \u0932\u093e\u0917\u093f \u0909\u092a\u092f\u0941\u0915\u094d\u0924 \u0939\u0941\u0928\u094d\u091b\u0964 \u092f\u0938\u0932\u0947 \u0907\u092d\u0947\u0928\u094d\u091f\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u0941\u0928\u094d\u0928 \u0930 \u0924\u093f\u0928\u0940\u0939\u0930\u0942\u0932\u093e\u0908 \u092a\u094d\u0930\u092c\u0928\u094d\u0927 \u0917\u0930\u094d\u0928 \u0905\u0928\u0941\u092e\u0924\u093f \u0926\u093f\u0928\u094d\u091b\u0964</p> \u0909\u0926\u093e\u0939\u0930\u0923<pre><code>const EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\nmyEmitter.on('dataReceived', (data) =&gt; {\n    console.log(\"\u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u092d\u092f\u094b:\", data);\n});\n\n// \u0921\u0947\u091f\u093e \u092a\u094d\u0930\u093e\u092a\u094d\u0924 \u0917\u0930\u094d\u0928\u0915\u094b \u0932\u093e\u0917\u093f \u0907\u092d\u0947\u0928\u094d\u091f\u0932\u093e\u0908 \u091f\u094d\u0930\u093f\u0917\u0930 \u0917\u0930\u094d\u091b\nsetTimeout(() =&gt; {\n    myEmitter.emit('dataReceived', { id: 1, name: \"\u0930\u093e\u092e\" });\n}, 2000);\n</code></pre> </li> </ol> <p>\u0928\u093f\u0937\u094d\u0915\u0930\u094d\u0937</p> <p>\u092f\u0940 \u0935\u093f\u0915\u0932\u094d\u092a\u0939\u0930\u0942\u0932\u0947 \u0915\u094b\u0932\u092c\u094d\u092f\u093e\u0915 \u092b\u0919\u094d\u0938\u0928\u0939\u0930\u0942\u0915\u094b \u0938\u0940\u092e\u093e\u0939\u0930\u0942 \u0930 \u091c\u091f\u093f\u0932\u0924\u093e\u0939\u0930\u0942\u0932\u093e\u0908 \u0938\u092e\u0947\u091f\u094d\u0928 \u092e\u0926\u094d\u0926\u0924 \u0917\u0930\u094d\u091b\u0964 \u092a\u094d\u0930\u092e\u093f\u0938, Async/Await, Observables, \u0930 Event Emitters\u0932\u0947 \u0905\u0938\u093f\u0928\u094d\u0915\u094d\u0930\u094b\u0928\u0938 \u0915\u093e\u0930\u094d\u092f\u0939\u0930\u0942\u0915\u094b \u092a\u094d\u0930\u092c\u0928\u094d\u0927\u0932\u093e\u0908 \u0938\u091c\u093f\u0932\u094b, \u092a\u0920\u0928\u0940\u092f \u0930 \u0932\u091a\u093f\u0932\u094b \u092c\u0928\u093e\u0909\u0901\u091b\u0964</p>"},{"location":"programmingNepali/intro/","title":"Intro","text":""},{"location":"programmingNepali/intro/#in-nepali","title":"In Nepali","text":""},{"location":"reactPattern/functional-pattern-and-technique/","title":"Functional Pattern & Technique","text":"<p>Functional Patterns and Techniques in React</p>"},{"location":"reactPattern/functional-pattern-and-technique/#1-functional-components","title":"1. Functional Components","text":"<p>Use functional components instead of class components for simpler syntax and hooks.</p> <pre><code>const MyComponent = () =&gt; {\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#2-hooks","title":"2. Hooks","text":"<p>Leverage React hooks for state and side effects.</p> a. useStateb. useEffect <p>Manage state in functional components.</p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n    const [count, setCount] = useState(0);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Count: {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> <p>Handle side effects like data fetching and subscriptions.</p> <pre><code>import React, { useEffect, useState } from 'react';\n\nconst DataFetcher = () =&gt; {\n    const [data, setData] = useState(null);\n\n    useEffect(() =&gt; {\n        fetch('https://api.example.com/data')\n            .then(response =&gt; response.json())\n            .then(data =&gt; setData(data));\n    }, []); // Empty array means this runs once on mount\n\n    return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#3-custom-hooks","title":"3. Custom Hooks","text":"<p>Encapsulate logic for reuse.</p> <pre><code>import { useState, useEffect } from 'react';\n\nconst useFetch = (url) =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then(response =&gt; response.json())\n      .then(data =&gt; setData(data));\n  }, [url]);\n\n  return data;\n};\n\n// Usage\nconst DataDisplay = () =&gt; {\n  const data = useFetch('https://api.example.com/data');\n  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#4-context-api","title":"4. Context API","text":"<p>Share state across components without prop drilling.</p> a. Create Context <pre><code>import React, { createContext, useContext, useState } from 'react';\n\nconst MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [value, setValue] = useState('Default Value');\n\n    return (\n        &lt;MyContext.Provider value={{ value, setValue }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n\n// Usage\nconst Component = () =&gt; {\n    const { value, setValue } = useContext(MyContext);\n    return (\n        &lt;div&gt;\n            &lt;p&gt;{value}&lt;/p&gt;\n            &lt;button onClick={() =&gt; setValue('New Value')}&gt;Change Value&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#5-memoization","title":"5. Memoization","text":"<p>Optimize performance with <code>React.memo</code> and <code>useMemo</code>.</p> a. React.memob. useMemo <p>Prevent unnecessary re-renders.</p> <pre><code>const MyComponent = React.memo(({ value }) =&gt; {\n    console.log('Rendered');\n    return &lt;div&gt;{value}&lt;/div&gt;;\n});\n</code></pre> <p>Memoize expensive calculations.</p> <pre><code>import { useMemo } from 'react';\n\nconst ExpensiveComponent = ({ num }) =&gt; {\n    const computedValue = useMemo(() =&gt; {\n        // Expensive calculation\n        return num * 2;\n    }, [num]);\n\n    return &lt;div&gt;{computedValue}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#6-rendering-lists","title":"6. Rendering Lists","text":"<p>Render dynamic lists efficiently.</p> <pre><code>const ItemList = ({ items }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {items.map(item =&gt; (\n        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#7-render-props","title":"7. Render Props","text":"<p>This pattern involves passing a function as a prop to a component, allowing for more flexible and reusable components.</p> <pre><code>const RenderPropComponent = ({ render }) =&gt; {\n  return &lt;div&gt;{render()}&lt;/div&gt;;\n};\n\n// Usage\n&lt;RenderPropComponent render={() =&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;} /&gt;;\n</code></pre>"},{"location":"reactPattern/functional-pattern-and-technique/#conclusion","title":"Conclusion","text":"<p>Using functional patterns and techniques in React can lead to cleaner, more maintainable code. Embrace hooks, context, and optimization strategies to enhance your React applications!</p>"},{"location":"reactPattern/functional-updated-pattern/","title":"Functional Update Pattern","text":"<p>Understanding the Functional Update Pattern in React: Techniques and Related Patterns</p>"},{"location":"reactPattern/functional-updated-pattern/#functional-update-pattern","title":"Functional Update Pattern","text":"<p>Definition</p> <p>The Functional Update Pattern is a technique used in React to update state based on the previous state. This is particularly useful in scenarios where state updates are dependent on the current state value, ensuring that updates are not lost due to asynchronous behavior.</p> <p>Usage</p> <p>You typically use this pattern with the <code>setState</code> function from the <code>useState</code> hook, or in class components with <code>this.setState</code>.</p> <p>Example</p> <p>Using <code>useState</code></p> <pre><code>import React, { useState } from 'react';\n\nconst Counter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const increment = () =&gt; {\n    setCount(prevCount =&gt; prevCount + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Benefits</p> <ul> <li>Avoid Race Conditions: By using the previous state as an input for the new state, you avoid issues that can arise from multiple updates occurring in quick succession.</li> </ul>"},{"location":"reactPattern/functional-updated-pattern/#related-patterns","title":"Related Patterns","text":"<ol> <li> <p>Callback Functions with State</p> <ul> <li>Similar to the Functional Update Pattern, you can provide a function to <code>setState</code> that takes the previous state and returns the new state.</li> </ul> <pre><code>const toggle = () =&gt; {\n    setIsActive(prev =&gt; !prev);\n};\n</code></pre> </li> <li> <p>Reducer Pattern</p> <ul> <li> <p>Using <code>useReducer</code> for more complex state management. This pattern involves defining a reducer function that updates state based on actions.</p> <pre><code>const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n\nconst Counter = () =&gt; {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        &lt;div&gt;\n            Count: {state.count}\n            &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;+&lt;/button&gt;\n            &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;-&lt;/button&gt;\n        &lt;/div&gt;\n    );\n};\n</code></pre> </li> </ul> </li> <li> <p>Controlled <code>vs.</code> Uncontrolled Components</p> <ul> <li>Controlled components manage their own state, while uncontrolled components rely on the DOM for state. Controlled components often use the Functional Update Pattern for form inputs.</li> </ul> <pre><code>const ControlledInput = () =&gt; {\n    const [value, setValue] = useState('');\n\n    return (\n        &lt;input\n            value={value}\n            onChange={e =&gt; setValue(e.target.value)}\n        /&gt;\n    );\n};\n</code></pre> </li> <li> <p>Context API with Functional Updates</p> <ul> <li> <p>When using the Context API, you can employ the Functional Update Pattern to manage global state efficiently.</p> <pre><code>const MyContext = createContext();\n\nconst MyProvider = ({ children }) =&gt; {\n    const [state, setState] = useState({ count: 0 });\n\n    const increment = () =&gt; {\n        setState(prevState =&gt; ({ count: prevState.count + 1 }));\n    };\n\n    return (\n        &lt;MyContext.Provider value={{ state, increment }}&gt;\n            {children}\n        &lt;/MyContext.Provider&gt;\n    );\n};\n</code></pre> </li> </ul> </li> </ol>"},{"location":"reactPattern/functional-updated-pattern/#conclusion","title":"Conclusion","text":"<p>The Functional Update Pattern is a key technique in React for managing state updates that depend on previous state values. It promotes better state management and prevents common pitfalls associated with asynchronous updates. Other patterns, like using reducers and the Context API, can complement this approach for more complex applications.</p>"},{"location":"reactPattern/when-not-to-use-functional-update/","title":"When not to use Functional Update","text":"<p>Certainly! Here are some guidelines on when to use the Functional Update Pattern in React, as well as situations where it may not be necessary:</p>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-to-use-the-functional-update-pattern","title":"When to Use the Functional Update Pattern","text":"<ol> <li> <p>Dependent State Updates:</p> <ul> <li> <p>Use it when the new state depends on the previous state. This is especially important in cases where state updates may be batched or occur asynchronously.</p> <pre><code>setCount(prevCount =&gt; prevCount + 1);\n</code></pre> </li> </ul> </li> <li> <p>Multiple Updates in Quick Succession:</p> <ul> <li>If you have multiple state updates that rely on the current value (e.g., in event handlers), the Functional Update Pattern helps prevent race conditions.</li> </ul> <pre><code>const handleMultipleClicks = () =&gt; {\n    setCount(prev =&gt; prev + 1);\n    setCount(prev =&gt; prev + 1); // Both updates are based on the latest state\n};\n</code></pre> </li> <li> <p>Complex State Logic:</p> <p>When managing complex state transitions that might involve conditions, using a function to handle state updates can improve clarity.</p> <pre><code>setState(prevState =&gt; {\n    // complex logic based on prevState\n});\n</code></pre> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#when-not-to-use-the-functional-update-pattern","title":"When Not to Use the Functional Update Pattern","text":"<ol> <li> <p>Simple Static Updates:</p> <ul> <li> <p>If you're setting state to a constant value or not relying on the previous state, using the Functional Update Pattern is unnecessary.</p> <pre><code>setCount(10); // Direct assignment is simpler here\n</code></pre> </li> </ul> </li> <li> <p>No Dependency on Previous State:</p> <ul> <li>If the new state does not depend on the current state (e.g., setting a fixed value or fetching new data), you can set the state directly.</li> </ul> </li> <li> <p>Performance Concerns:</p> <ul> <li>In rare cases, excessive use of functional updates may introduce unnecessary complexity or performance overhead if not needed. However, this is generally not a significant concern.</li> </ul> </li> </ol>"},{"location":"reactPattern/when-not-to-use-functional-update/#summary","title":"Summary","text":"<ul> <li>Use the Functional Update Pattern when state updates depend on previous values, especially in situations with multiple rapid updates.</li> <li>Avoid it for simple or static updates where the current state is not relevant.</li> </ul> <p>This approach helps maintain clarity and prevents bugs in your React applications!</p>"},{"location":"blog/archive/2024/","title":"2024","text":""}]}